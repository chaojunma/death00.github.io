<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>death00</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-02T08:35:07.610Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>death00</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中Synchronized的优化</title>
    <link href="http://yoursite.com/2019/10/02/Java%E4%B8%ADSynchronized%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/10/02/Java中Synchronized的优化/</id>
    <published>2019-10-02T07:52:32.000Z</published>
    <updated>2019-10-02T08:35:07.610Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，从 JDK1.6 开始，Java 对 Synchronized 同步锁做了充分的优化，甚至在某些场景下，它的性能已经超越了 Lock 同步锁。那么就让我们来看看，它究竟是如何优化的。<br><a id="more"></a></p><h2 id="原本的问题"><a href="#原本的问题" class="headerlink" title="原本的问题"></a>原本的问题</h2><p><code>Synchronized</code>是基于底层操作系统的 Mutex Lock 实现的，每次获取锁和释放锁的操作都会带来<code>用户态</code>和<code>内核态</code>的切换，从而增加系统性能开销。</p><p>因此，在锁竞争激烈的情况下，<code>Synchronized</code>同步锁在性能上就表现得非常糟糕，它也常被大家称为<code>重量级锁</code>。</p><p>到了 JDK1.5 版本，并发包中新增了 Lock 接口来实现锁功能，它提供了与 Synchronized 关键字类似的同步功能，只是在使用时需要显示获取锁和释放锁。</p><p>在单个线程重复申请锁的情况下，JDK1.5 版本的 Lock 性能要比 Synchronized 锁的性能好很多，也就是当时的 Synchronized 并不具备<code>可重入锁</code>的功能。</p><p>那么当时的 Synchronized 是怎么实现的？又为什么不具备可重入的功能呢？</p><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><p>JVM 中的同步是基于进入和退出管程（Monitor）对象实现的。每个对象实例都会有一个 Monitor，Monitor 可以和对象一起创建、销毁。</p><p>当多个线程同时访问一段同步代码时，多个线程会先被存放在<code>EntryList集合</code>（也可称为<code>阻塞队列</code>）中，处于<code>BLOCKED</code>状态的线程，都会被加入到该列表。</p><p>接下来当线程获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，线程申请 Mutex 成功，则持有该 Mutex，其它线程将无法获取到该 Mutex。</p><p>如果线程调用 wait() 方法，就会释放当前持有的 Mutex，并且该线程会进入<code>WaitSet集合</code>（也可称为<code>等待队列</code>）中，等待下一次被唤醒。此时线程会处于<code>WAITING</code>或者<code>TIMEDWAITING</code>状态，</p><p>如果当前线程顺利执行完方法，也将释放 Mutex。</p><p>总的来说，就是同步锁在这种实现方式中，因 Monitor 是依赖于底层的操作系统实现，存在<code>用户态</code>与<code>内核态</code>之间的切换(可以理解为<code>上下文切换</code>)，所以增加了性能开销。</p><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>为了提升性能，JDK1.6 引入了偏向锁、轻量级锁、重量级锁概念，来减少锁竞争带来的上下文切换，而正是新增的<code>Java对象头</code>实现了<code>锁升级</code>功能。</p><p>所谓<code>锁升级</code>，就是指</p><blockquote><p>Synchronized 同步锁初始为<code>偏向锁</code>，随着线程竞争越来越激烈，<code>偏向锁</code>升级到<code>轻量级锁</code>，最终升级到<code>重量级锁</code>。</p></blockquote><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><code>偏向锁</code>主要用来优化同一线程多次申请同一个锁的竞争，也就是现在的<code>Synchronized锁</code>实际已经拥有了可重入锁的功能。</p><p>为什么要有<code>偏向锁</code>？因为在我们的应用中，可能大部分时间是同一个线程竞争锁资源（比如单线程操作一个线程安全的容器），如果这个线程每次都要获取锁和释放锁，那么就在不断的从<code>内核态</code>与<code>用户态</code>之间切换。</p><p>那么有了<code>偏向锁</code>，当一个线程再次访问这个同步代码或方法时，该线程只需去对象头中去判断一下是否当前线程是否持有该偏向锁就可以了。</p><p>一旦出现其它线程竞争锁资源时，偏向锁就会被撤销。偏向锁的撤销需要等待<code>全局安全点</code>(JVM的<code>stop the world</code>)，暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之则被其它线程抢占。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>当有另外一个线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头中的线程 ID 不是自己的线程 ID，就会进行 CAS 操作获取锁，如果获取成功，直接替换对象头中的线程 ID 为自己的 ID，该锁会保持<code>偏向锁</code>状态；如果获取锁失败，代表当前锁有一定的竞争，偏向锁将升级为<code>轻量级锁</code>。</p><p><code>轻量级锁</code>适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的竞争。</p><p>轻量级锁也支持<code>自旋</code>，因此其他线程再次争抢时，如果<code>CAS</code>失败，将不再会进入<code>阻塞状态</code>，而是不断自旋。</p><p>之所以自旋更好，是因为之前说了，默认线程持有锁的时间都不会太长，如果线程被挂起阻塞可能代价会更高。</p><p>如果自旋锁重试之后抢锁依然失败，那么同步锁就会升级至<code>重量级锁</code>。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>在这个状态下，未抢到锁的线程都会进入 Monitor，之后会被阻塞在<code>WaitSet集合</code>中，也就变成了优化之前的<code>Synchronized锁</code>。</p><h2 id="JVM参数优化"><a href="#JVM参数优化" class="headerlink" title="JVM参数优化"></a>JVM参数优化</h2><p><code>偏向锁</code>升级为<code>轻量级锁</code>时，会发生<code>stop the world</code>，如果系统常常是多线程竞争，那么禁止偏向锁也许是更好的选择，可以通过以下<code>JVM参数</code>进行优化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 关闭偏向锁（默认打开）</span><br><span class="line">-XX:-UseBiasedLocking</span><br><span class="line">// 设置重量级锁</span><br><span class="line">-XX:+UseHeavyMonitors</span><br></pre></td></tr></table></figure><p><code>轻量级锁</code>拥有<code>自旋锁</code>的功能，那么如果线程持有锁的时间很长，那么竞争的线程也会常常处于自旋状态，占用系统 CPU ，增加系统开销，那么此时关闭自旋锁的优化可以更好一些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseSpinning</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是 Java 中针对 Synchronized 锁的优化，也正是因为这个优化，ConcurrentHashMap 在 JDK1.8 之后，再次采用 Synchronized 锁。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，从 JDK1.6 开始，Java 对 Synchronized 同步锁做了充分的优化，甚至在某些场景下，它的性能已经超越了 Lock 同步锁。那么就让我们来看看，它究竟是如何优化的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Synchronized" scheme="http://yoursite.com/tags/Synchronized/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>升级@Scheduled-分布式定时任务</title>
    <link href="http://yoursite.com/2019/09/30/%E5%8D%87%E7%BA%A7@Scheduled-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/09/30/升级@Scheduled-分布式定时任务/</id>
    <published>2019-09-30T09:01:47.000Z</published>
    <updated>2019-10-01T01:16:41.430Z</updated>
    
    <content type="html"><![CDATA[<p>最近我在对项目的定时任务服务升级，希望改造成分布式，原本是利用<code>@Scheduled</code>注解实现，然而它并不支持分布式，如果改成<code>quartz</code>或者<code>Spring Cloud Task</code>，感觉对于自己这个简单的项目也没有必要。因此，我准备手写一个简单的支持分布式定时调度任务的框架。<br><a id="more"></a></p><p>项目地址是<a href="https://github.com/death00/dis-schedule" target="_blank" rel="noopener">https://github.com/death00/dis-schedule</a>，欢迎大家star、提意见。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先分析了一下自己的项目，全都是用的cron表达式，因此执行时间点都是固定的，如果升级为分布式的话，肯定是希望在同一个时间点只有一个应用去执行定时调度。</p><p>场景就变成了：</p><blockquote><p>多个应用在同一个时间都尝试去执行任务，但最终只有一个应用真正执行。</p></blockquote><p>这样的话，立马就会让人联想到使用<code>锁</code>去解决，因为是多个应用，所以就是<code>分布式锁</code>。那么，场景又变了：</p><blockquote><p>多个应用在同一个时间都尝试去获取<code>分布式锁</code>，只有一个应用能抢到这把锁，抢到锁的应用可以执行定时任务，其他应用则直接放弃，等待下一次执行时间。</p></blockquote><p>抢锁的时机是每次定时任务执行之前，这又让我联想到了<code>AOP</code>，那么利用<code>注解</code>也就顺理成章了。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>既然谈到了<code>分布式锁</code>，那么就想一下，这把锁的名称构成是什么。因为定时任务都有自己专门的时间，如果仅仅采用时间的话，那么当有两个任务同时执行时，则就是在抢一把锁，这同样是不合理的。</p><p>所以，锁的名称由两部分组成：任务执行时间、任务名称。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现方案其实已经很成熟了，可以利用<code>Redis</code>、<code>数据库</code>、<code>Zookeeper</code>等，<code>Redis</code>用的命令是<code>setNx</code>，<code>数据库</code>一般都是利用的<code>唯一索引</code>，<code>Zookeeper</code>这点我也不是很了解（如果有感兴趣的同学，欢迎在我的项目中添加）。</p><p>我的项目中实现了<code>Redis</code>、<code>数据库</code>两种方式，可以看类<code>DisScheduleRedisServiceImpl</code>、<code>DisScheduleMongodbServiceImpl</code>。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>其次，我自定义了一个注解<code>DisSchedule</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DisSchedule &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时调度任务的名称(默认是方法名)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务的间隔时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duration</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * duration的时间单位(默认：分钟)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">DisScheduleUnit <span class="title">unit</span><span class="params">()</span> <span class="keyword">default</span> DisScheduleUnit.MINUTES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>name</code>代表此次定时调度任务的名称。</li><li><code>duration</code>代表任务的间隔时间，配合<code>unit</code>。</li><li><code>unit</code>是自定义的时间单位，有秒、分钟。</li></ol><p>该注解需要配合<code>@Scheduled</code>共同使用，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisSchedule</span>(name = <span class="string">"testSchedule"</span>, duration = <span class="number">1</span>, unit = DisScheduleUnit.MINUTES)</span><br><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 0/1 * * * ?"</span>)</span><br></pre></td></tr></table></figure></p><p>该<code>cron</code>表达式代表1分钟执行一次，且是在整数分钟开始的时候执行，因此<code>@DisSchedule</code>也需要设置为1分钟的时间。</p><h2 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h2><p>接下来，我们只需要在<code>Aspect</code>中定义好切入点（有注解<code>@DisSchedule</code>的方法上），针对这些方法，需要使用<code>Around</code>(环绕增强)进行拦截，因为当抢不到锁的时候，就不允许执行。</p><p>具体可以参考类<code>DisScheduleAspect</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我实现的简单的分布式定时任务，虽然简单，但应该可以满足你的基础需求，接下来，我会在这个之上，逐步增加功能（比如监测、失败后预警等）。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近我在对项目的定时任务服务升级，希望改造成分布式，原本是利用&lt;code&gt;@Scheduled&lt;/code&gt;注解实现，然而它并不支持分布式，如果改成&lt;code&gt;quartz&lt;/code&gt;或者&lt;code&gt;Spring Cloud Task&lt;/code&gt;，感觉对于自己这个简单的项目也没有必要。因此，我准备手写一个简单的支持分布式定时调度任务的框架。&lt;br&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Scheduled" scheme="http://yoursite.com/tags/Scheduled/"/>
    
      <category term="定时任务" scheme="http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的负载均衡</title>
    <link href="http://yoursite.com/2019/09/30/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2019/09/30/Nginx的负载均衡/</id>
    <published>2019-09-30T01:34:06.000Z</published>
    <updated>2019-09-30T06:10:47.226Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，Nginx支持负载均衡，可以很方便的帮助我们进行水平扩容，然而它究竟是依据什么原则进行请求的分发，其中又有哪些负载均衡算法可供选择和配置，今天就让我们好好来了解一下。<br><a id="more"></a></p><h2 id="负载均衡的定义"><a href="#负载均衡的定义" class="headerlink" title="负载均衡的定义"></a>负载均衡的定义</h2><p>什么叫负载均衡，我们可以参考一下图片中的这种情况：</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019093001.png?raw=true" alt=""></p><ol><li>当客户端发送请求时，会先到Nginx，然后Nginx会将请求分发到后台不同的服务器上。</li><li>如果后台的服务器群中有一个宕机了，那么Nginx会自动忽略这台服务器，不会将请求再次分发到这台服务器上。</li><li>如果有新加入的服务器，Nginx也会将请求分发到这台服务器上。</li></ol><p>我所理解的负载均衡，就是：</p><blockquote><p>能够将客户端的请求均匀地分发到后台各个应用服务器上，从而缓解服务器压力。</p><p>并且当服务器出现宕机或者扩容时，也能正常运行。</p></blockquote><h2 id="负载均衡的方法"><a href="#负载均衡的方法" class="headerlink" title="负载均衡的方法"></a>负载均衡的方法</h2><p>上面了解了什么是负载均衡，那么Nginx是怎么实现这个功能的呢？</p><h3 id="upstream和server的使用"><a href="#upstream和server的使用" class="headerlink" title="upstream和server的使用"></a>upstream和server的使用</h3><p>Nginx中负责与上游交互的模块，统称为upstream模块。</p><p>而指定上游服务地址是通过<code>upstream</code>和<code>server</code>指令完成的，其关系为：</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019093002.png?raw=true" alt=""></p><p>指定上游服务器的<code>address</code>时，其地址可以是域名、IP地址或者unix socket地址。</p><p>可以在域名或者IP地址后加端口，如果不加端口，那么<code>默认使用80端口</code>。</p><p>在<code>address</code>后面可以添加一些参数，比如：</p><p><code>backup</code>：指定当前server为备份服务，仅当非备份server不可用时，请求才会转发到该server。</p><p><code>down</code>：标识某台服务已经下线，不再服务。</p><p>举个例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="round-robin"><a href="#round-robin" class="headerlink" title="round-robin"></a>round-robin</h3><p>在<code>upstream</code>这个模块中，它还提供了一个最基本的负载均衡算法<code>round-robin</code>。</p><p>其功能是：</p><blockquote><p>以加权轮询的方式访问server指令指定的上游服务。</p></blockquote><p>这个算法是默认集成在Nginx的框架中，无法移除，所以后面讲解的所有算法都是基于此，所有算法在某些特殊情况下最终都会变成<code>round-robin</code>。</p><p>涉及到的指令有：</p><ol><li><code>weight</code>：服务访问的权重，默认是1。</li><li><code>max_conns</code>：server的最大并发连接数，仅作用于单worker进程。</li><li><code>max_fails</code>：在<code>fail_timeout</code>时间内，最大的失败次数。当达到最大失败时，会在<code>fail_timeout</code>时间内不允许再次被选择。</li><li><code>fail_timeout</code>：单位为秒，默认是10秒。指定一段时间内，最大的失败次数<code>max_fails</code>。到达<code>max_fails</code>后，该server不能访问的时间。</li></ol><h3 id="简单的hash模块"><a href="#简单的hash模块" class="headerlink" title="简单的hash模块"></a>简单的hash模块</h3><p>有的时候，正常的轮询算法并不能满足我们的需求，</p><p>比如：带有cookie请求状态的连接，如果应用服务没有设置专门的管理cookie的服务器，那么我们就希望同一个用户能被分配到同一个服务器。</p><p>再比如：我们后端应用需要针对请求当中的参数或者URL，将相同的请求放到相同的服务器上进行处理。</p><p>针对第一种情况，就可以用<code>upstream_ip_hash</code>。针对第二种情况，可以使用<code>upstream_hash</code>。</p><h4 id="upstream-ip-hash"><a href="#upstream-ip-hash" class="headerlink" title="upstream_ip_hash"></a>upstream_ip_hash</h4><p>功能：</p><blockquote><p>以客户端的IP地址作为hash算法的关键字，映射到特定的上游服务器中。</p><ol><li>对IPV4地址使用前3个字节作为关键字，对IPV6则使用完整地址。</li><li>可以使用<code>round-robin</code>算法的参数。</li><li>可以基于<code>realip</code>模块修改用于执行算法的IP地址。</li></ol></blockquote><p>举个例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="upstream-hash"><a href="#upstream-hash" class="headerlink" title="upstream_hash"></a>upstream_hash</h4><p>功能：</p><blockquote><p>通过制定关键字作为hash key，基于hash算法映射到特定的上游服务器中。</p><ol><li>关键字可以含有变量、字符串。</li><li>可以使用<code>round-robin</code>算法的参数。</li></ol></blockquote><p>举个例子(以请求中的参数username作为hash key)：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    <span class="attribute">hash</span> user_<span class="variable">$arg_username</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>hash算法在一定程度上已经可以满足了我们的业务需求，但如果这个时候遇到应用宕机或者应用扩容，那么hash的总数就会变化，这样很有可能带来大量请求原本请求的服务器会更换，路由会失效，这样对于我们的应用服务也会产生极大的影响，这时候就可以采用一致性hash算法。</p><p>对于一致性哈希算法的理解，可以参考这篇文章：<a href="https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">一致性哈希算法的理解与实践</a></p><p>它的使用也十分简单，就是在之前说的<code>upstream_hash</code>模块的<code>hash</code>指令最后，添加参数<code>consistent</code>，这样Nginx就可以使用一致性哈希算法了。</p><p>举个例子(仍以请求中的参数username作为hash key)：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    <span class="attribute">hash</span> user_<span class="variable">$arg_username</span> consistent;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是Nginx中比较常见的负载均衡方法了，还有一些比如<code>最少连接算法</code>等，都是在此之上的一些应用。如果大家有什么疑问，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道，Nginx支持负载均衡，可以很方便的帮助我们进行水平扩容，然而它究竟是依据什么原则进行请求的分发，其中又有哪些负载均衡算法可供选择和配置，今天就让我们好好来了解一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>github博客Hexo引流到微信</title>
    <link href="http://yoursite.com/2019/09/26/github%E5%8D%9A%E5%AE%A2hexo%E5%BC%95%E6%B5%81%E5%88%B0%E5%BE%AE%E4%BF%A1/"/>
    <id>http://yoursite.com/2019/09/26/github博客hexo引流到微信/</id>
    <published>2019-09-26T05:31:59.000Z</published>
    <updated>2019-09-26T06:45:37.453Z</updated>
    
    <content type="html"><![CDATA[<p>相信有不少小伙伴都在github上创建了属于自己的博客，其中用<code>Hexo</code>的<code>Next</code>主题应该不少，那么，我们究竟该如何将博客的流量引流到微信呢？今天就来带你看一看。<br><a id="more"></a></p><h2 id="如何引流"><a href="#如何引流" class="headerlink" title="如何引流"></a>如何引流</h2><p>现在网上有一种套路，当你在看别人博客时，只能看一半，想继续看的话，需要扫码关注别人的公众号才能继续，这样的话，你的公众号粉丝自然就能蹭蹭上涨。</p><p>这里需要解决两个问题：</p><ol><li>文章看到一半就不允许继续观看</li><li>关注你的公众号后才能继续观看</li></ol><p>这里我是借助了<a href="https://openwrite.cn/" target="_blank" rel="noopener">OpenWrite</a>中的引流工具实现的。</p><h2 id="导流"><a href="#导流" class="headerlink" title="导流"></a>导流</h2><p>当你注册进入OpenWrite后，会有一个<code>博客导流公众号</code>功能，添加完相应的信息后，即可获得一段具有隐藏功能的<code>JS代码</code>：</p><p><img src="https://openwrite.cn/wp-content/uploads/2019/09/WeChat7c77e13e57068b5f402ad850e144e03d.png" alt=""></p><h2 id="如何设置文章看到一半"><a href="#如何设置文章看到一半" class="headerlink" title="如何设置文章看到一半"></a>如何设置文章看到一半</h2><p>这就需要我们在文章模块页面增加相应的隐藏功能，并且能够展示二维码并锁住页面。</p><h3 id="增加自定义swig文件"><a href="#增加自定义swig文件" class="headerlink" title="增加自定义swig文件"></a>增加自定义swig文件</h3><p>进入你的博客文件夹，在<code>themes\next\layout\_custom</code>文件夹中，新建一个<code>hide.swig</code>文件（这个文件夹专门用来存放自定义的一些代码），复制上文提到的JS代码，注意<code>id</code>的值，它默认用的是<code>container</code>，我设置成了<code>container-1</code>。</p><h3 id="修改文章模板文件"><a href="#修改文章模板文件" class="headerlink" title="修改文章模板文件"></a>修改文章模板文件</h3><p>进入你的博客文件夹，在<code>themes\next\layout</code>文件夹中，会有一个<code>_layout.swig</code>文件，这就是你的文章模板文件。其中有一段内容是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;main id=<span class="string">"main"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main-inner"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content-wrap"</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">"content"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">          &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p><code>id</code>为<code>content</code>的地方，就是你的文章内容，这时候你可以在外面再嵌套一层<code>div</code>，其<code>id</code>就是上面我设置的<code>container-1</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;main id=<span class="string">"main"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main-inner"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content-wrap"</span>&gt;</span><br><span class="line">      &lt;div id=<span class="string">"container-1"</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">"content"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">          &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>此时就可以发布你的博客，现在你的文章就会产生<code>阅读全文</code>的按钮了：</p><p><img src="https://i.loli.net/2019/09/25/YLjIcqtPlpvwCaZ.png" alt=""></p><p>按下这个按钮，就会弹出相应的二维码和你当初设置的关键字：</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092601.png" alt=""></p><h2 id="微信公众号自动回复设置"><a href="#微信公众号自动回复设置" class="headerlink" title="微信公众号自动回复设置"></a>微信公众号自动回复设置</h2><p>在微信公众号后台页面，选择<code>自动回复</code>-<code>关键词回复</code>，点击<code>添加回复</code>：</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092602.png" alt=""></p><p>填写<code>规则名称</code>、<code>关键词</code>(你当初在OpenWrite中设置的)，<code>回复内容</code>选择<code>文字</code>，填上<code>OpenWrite</code>中返回的那段文字。</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092603.png" alt=""></p><p>此时，当别人关注你的公众号并输入关键字后(比如我设置的关键字就是git)，就会显示回复了</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092604.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你的博客有一定的日活，那就千万不要错过这种微信涨粉、互相引流的机会。如果大家有什么疑问，欢迎在下方留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信有不少小伙伴都在github上创建了属于自己的博客，其中用&lt;code&gt;Hexo&lt;/code&gt;的&lt;code&gt;Next&lt;/code&gt;主题应该不少，那么，我们究竟该如何将博客的流量引流到微信呢？今天就来带你看一看。&lt;br&gt;
    
    </summary>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
      <category term="微信" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java中的interrupt</title>
    <link href="http://yoursite.com/2019/09/25/Java%E4%B8%AD%E7%9A%84interrupt/"/>
    <id>http://yoursite.com/2019/09/25/Java中的interrupt/</id>
    <published>2019-09-25T06:00:00.000Z</published>
    <updated>2019-09-25T07:25:57.555Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，Java中停止一个线程不能用<code>stop</code>，因为<code>stop</code>会瞬间强行停止一个线程，且该线程持有的锁并不能释放。大家多习惯于用<code>interrupt</code>，那么使用它又有什么需要注意的呢？<br><a id="more"></a></p><h2 id="interrupt相关的方法"><a href="#interrupt相关的方法" class="headerlink" title="interrupt相关的方法"></a>interrupt相关的方法</h2><p>Java中和interrupt相关的方法有三个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="boolean-isInterrupted"><a href="#boolean-isInterrupted" class="headerlink" title="boolean isInterrupted()"></a>boolean isInterrupted()</h3><p>每个线程都一个状态位用于标识当前线程对象是否是中断状态。<code>isInterrupted</code>主要用于判断当前线程对象的中断标志位是否被标记了，如果被标记了则返回true，表示当前已经被中断，否则返回false。我们也可以看看它的实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p>底层调用的native方法<code>isInterrupted</code>，传入一个boolean类型的参数，用于指定调用该方法之后是否需要清除该线程的中断标识位。从这里我们也可以看出来，调用<code>isInterrupted()</code>并不会清除线程的中断标识位。</p><h3 id="void-interrupt"><a href="#void-interrupt" class="headerlink" title="void interrupt()"></a>void interrupt()</h3><p><code>interrupt()</code>用于设置当前线程对象的中断标识位，其源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查当前线程是否有权限修改目标线程，如果没有，则会抛出异常SecurityException</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>blockerLock</code>和<code>blocker</code>都和阻塞IO时产生的中断相关，因此推测<code>interrupt()</code>需要当阻塞IO操作执行完之后，才可以执行。</p><p><code>interrupt()</code>其实只是改变了一个标志位，对于线程本身的状态并没有影响。</p><h3 id="boolean-interrupted"><a href="#boolean-interrupted" class="headerlink" title="boolean interrupted()"></a>boolean interrupted()</h3><p>该方法是一个静态的方法，用于返回当前线程是否被中断，其源码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：<code>该方法调用结束的时候会清空中断标识位</code>。</p><h2 id="线程的状态与中断的关系"><a href="#线程的状态与中断的关系" class="headerlink" title="线程的状态与中断的关系"></a>线程的状态与中断的关系</h2><p>我们知道，Java中的线程一共6种状态，分别是<code>NEW</code>，<code>RUNNABLE</code>，<code>BLOCKED</code>，<code>WAITING</code>，<code>TIMED_WAITING</code>，<code>TERMINATED</code>（Thread类中有一个State枚举类型列举了线程的所有状态）。下面我们就将把线程分别置于上述的不同种状态，然后看看中断操作对它们的影响。</p><h3 id="NEW和TERMINATED"><a href="#NEW和TERMINATED" class="headerlink" title="NEW和TERMINATED"></a>NEW和TERMINATED</h3><p><code>NEW</code>状态表示线程还未调用<code>start()</code>方法，<code>TERMINATED</code>状态表示线程已经运行终止。</p><p>这两个状态下调用中断方法来中断线程的时候，Java认为毫无意义，所以并不会设置线程的中断标识位。例如：</p><p><code>NEW</code>状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NEW</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p><code>TERMINATED</code>状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">    <span class="comment">// 开始线程</span></span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    thread.join();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TERMINATED</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>从上述的两个例子来看，处于<code>NEW</code>和<code>TERMINATED</code>状态的线程，对于中断是屏蔽的，也就是说中断操作对这两种状态下的线程是无效的。</p><h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h3><p>处于<code>RUNNABLE</code>状态的线程，当中断线程后，会修改其中断标志位，但并不会影响线程本身。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 什么都不做，就是空转</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure></p><p>中断标志位确实被改变了，但线程依旧继续运行。那我们调用<code>interrupt()</code>方法的意义在哪儿？</p><p>其实Java是将中断线程的权利交给了我们自己的程序，通过中断标志位，我们的程序可以通过<code>boolean isInterrupted()</code>方法来判断当前线程是否中断，从而决定之后的操作。</p><p>我们可以在此基础上，保证执行任务的原子性。例如修改<code>MyThread</code>类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">"exit MyThread"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line"></span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">exit MyThread</span><br><span class="line">TERMINATED</span><br></pre></td></tr></table></figure></p><h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h3><p>当线程处于<code>BLOCKED</code>状态，说明该线程由于竞争某个对象的锁失败而被挂在了该对象的阻塞队列上了。</p><p>那么此时发起中断操作不会对该线程产生任何影响，依然只是设置中断标志位。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 空转</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(thread1.getState());</span><br><span class="line">        System.out.println(thread2.getState());</span><br><span class="line"></span><br><span class="line">        System.out.println(thread2.isInterrupted());</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">        System.out.println(thread2.isInterrupted());</span><br><span class="line">        System.out.println(thread2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br><span class="line">BLOCKED</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">BLOCKED</span><br></pre></td></tr></table></figure></p><p>thread2处于<code>BLOCKED</code>状态，执行中断操作之后，该线程仍然处于<code>BLOCKED</code>状态，但是中断标志位却已被修改。</p><p>这种状态下的线程和处于<code>RUNNABLE</code>状态下的线程是类似的，给了我们程序更大的灵活性去判断和处理中断。</p><h3 id="WAITING-TIMED-WAITING"><a href="#WAITING-TIMED-WAITING" class="headerlink" title="WAITING/TIMED_WAITING"></a>WAITING/TIMED_WAITING</h3><p>这两种状态本质上是同一种状态，只不过<code>TIMED_WAITING</code>在等待一段时间后会自动释放自己，而<code>WAITING</code>则是无限期等待，需要其他线程调用类似<code>notify</code>方法释放自己。但是他们都是线程在运行的过程中由于缺少某些条件而被挂起在某个对象的等待队列上。</p><p>当这些线程遇到中断操作的时候，会抛出一个<code>InterruptedException</code>异常，并清空中断标志位。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"catch InterruptedException"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WAITING</span><br><span class="line">false</span><br><span class="line">catch InterruptedException</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>从运行结果看，当线程启动之后就被挂起到该线程对象的等待队列上，然后我们调用<code>interrupt()</code>方法对该线程进行中断，输出了我们在catch中的输出语句，显然是捕获了<code>InterruptedException</code>异常，接着就看到该线程的中断标志位被清空。</p><p>因此我们要么就在<code>catch</code>语句中结束线程，否则就在<code>catch</code>语句中加上<code>this.interrupt();</code>，再次设置标志位，这样也方便在之后的逻辑或者其他地方继续判断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们介绍了线程在不同状态下对于中断请求的反应：</p><ol><li><code>NEW</code>和<code>TERMINATED</code>对于中断操作几乎是屏蔽的。</li><li><code>RUNNABLE</code>和<code>BLOCKED</code>类似，对于中断操作只是设置中断标志位并没有强制终止线程，对于线程的终止权利依然在程序手中。</li><li><code>WAITING</code>和<code>TIMED_WAITING</code>状态下的线程对于中断操作是敏感的，他们会抛出异常并清空中断标志位。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道，Java中停止一个线程不能用&lt;code&gt;stop&lt;/code&gt;，因为&lt;code&gt;stop&lt;/code&gt;会瞬间强行停止一个线程，且该线程持有的锁并不能释放。大家多习惯于用&lt;code&gt;interrupt&lt;/code&gt;，那么使用它又有什么需要注意的呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="interrupt" scheme="http://yoursite.com/tags/interrupt/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java中的管程</title>
    <link href="http://yoursite.com/2019/06/29/Java%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/06/29/Java中的管程/</id>
    <published>2019-06-29T07:23:46.000Z</published>
    <updated>2019-06-29T09:00:35.927Z</updated>
    
    <content type="html"><![CDATA[<p>Java是利用<code>管程</code>解决并发编程问题的，那么究竟什么是<code>管程</code>？而它又是如何解决并发问题的呢？<br><a id="more"></a></p><h2 id="什么是管程"><a href="#什么是管程" class="headerlink" title="什么是管程"></a>什么是管程</h2><p>管程，英文名是 Monitor ，因此有的时候会被翻译为<code>监视器</code>。其实你也许很早就接触到这个概念了，比如 synchronized<br>关键字，很多文章就介绍过其原理是使用了<code>监视器</code>，只是你那个时候还并不知道<code>监视器</code>和<code>管程</code>，其实是一回事。</p><p>我们来看看维基百科上的概念：</p><blockquote><p>管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。</p></blockquote><p>感觉这句话听得有点迷糊，但下面这句话应该就很好理解了：</p><blockquote><p>管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。</p></blockquote><p>我的理解是：我们通过管程管理 Java 中的类，使得类是线程安全的。</p><p>这应该是<code>管程</code>最终要达到的效果，那么，它是怎么做到的呢？</p><h2 id="管程模型"><a href="#管程模型" class="headerlink" title="管程模型"></a>管程模型</h2><p>管程这个概念最早来源于操作系统，操作系统发展了那么多年，管程的实现也有多种方式，主流的有三种：<code>Hasen模型</code>、<code>Hoare模型</code>和<code>MESA模型</code>， Java 中借鉴的是<code>MESA模型</code>，让我们来重点看一下。</p><p>谈到<code>MESA模型</code>，就不得不提到并发主要解决2个核心问题：一个是<code>互斥</code>，即同一时刻只允许一个线程访问共享资源；另一个是<code>同步</code>，即多个线程之间如何通信、协作。</p><p>如何解决<code>互斥</code>呢？我们可以在操作共享变量之前，增加一个等待队列，每一个线程想要操作共享变量的话，都需要在等待队列中等待，直到管程选出一个线程操作共享变量。</p><p>那又是如何解决<code>同步</code>的呢？线程在操作共享变量时候，它不一定是直接执行，可能有一些自己的执行条件限制（比如取钱操作要求账户里一定要有钱，出队操作要求队列一定不能是空的），我们将这些限制称之为<code>条件变量</code>，每一个<code>条件变量</code>也有自己对应的<code>等待队列</code>，当线程发现自己的<code>条件变量</code>不满足时，就进入相应的<code>等待队列</code>中排队，直至<code>条件变量</code>满足，那么其<code>等待队列</code>中的线程也不会是立马执行，而是到最开始<code>共享变量</code>对应的<code>等待队列</code>中再次排队，重复之前的过程。</p><p>可以参考下面这幅图：</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019062901.png" alt=""></p><p>理论说了那么多，还是来看看用代码是如何实现的吧</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先可以自定一个支持并发的队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class MyQueen &#123;</span><br><span class="line"></span><br><span class="line">    // 共享变量（任何操作之前，都需要获得该锁才可以执行）</span><br><span class="line">    private final Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    // 条件变量：队列不满</span><br><span class="line">    private final Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    // 条件变量：队列不空</span><br><span class="line">    private final Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 存储队列的容器</span><br><span class="line">     */</span><br><span class="line">    private final LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 最大容量</span><br><span class="line">     */</span><br><span class="line">    private int capacity;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当前容器中存储的数量</span><br><span class="line">     */</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public MyQueen(int capacity) &#123;</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">        this.size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入队</span><br><span class="line">     */</span><br><span class="line">    public void enter(int value) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果队列已满，则需要等到队列不满</span><br><span class="line">            while (size &gt;= capacity) &#123;</span><br><span class="line">                notFull.await(1, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 入队</span><br><span class="line">            list.add(value);</span><br><span class="line">            size++;</span><br><span class="line">            System.out.println(value + &quot; has bean entered&quot;);</span><br><span class="line">            // 通知可以出队</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 出队</span><br><span class="line">     */</span><br><span class="line">    public int dequeue() &#123;</span><br><span class="line">        Integer result = null;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果队列已空，则需要等到队列不空</span><br><span class="line">            while (size &lt;= 0) &#123;</span><br><span class="line">                notEmpty.await(1, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 出队</span><br><span class="line">            result = list.removeFirst();</span><br><span class="line">            size--;</span><br><span class="line">            System.out.println(result + &quot; has bean dequeued&quot;);</span><br><span class="line">            // 通知可以入队</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyQueen myQueen = new MyQueen(3);</span><br><span class="line">        new Thread(new Pruducer(&quot;producer1&quot;, myQueen, 0, 2)).start();</span><br><span class="line">        new Thread(new Pruducer(&quot;producer2&quot;, myQueen, 2, 5)).start();</span><br><span class="line">        new Thread(new Consumer(&quot;consumer2&quot;, myQueen, 5)).start();</span><br><span class="line">        new Thread(new Consumer(&quot;consumer1&quot;, myQueen, 3)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义生产者和消费者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class Pruducer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private final MyQueen queen;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 该线程的名字</span><br><span class="line">     */</span><br><span class="line">    private final String name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开始的大小</span><br><span class="line">     */</span><br><span class="line">    private final int start;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 需要生产的资料个数</span><br><span class="line">     */</span><br><span class="line">    private final int size;</span><br><span class="line"></span><br><span class="line">    public Pruducer(String name, MyQueen queen, int start, int size) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.queen = queen;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 1; i &lt;= size; i++) &#123;</span><br><span class="line">            int now = start + i;</span><br><span class="line">//            System.out.println(name + &quot; produce : &quot; + now + &quot; start&quot;);</span><br><span class="line">            queen.enter(now);</span><br><span class="line">//            System.out.println(name + &quot; produce : &quot; + now + &quot; end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Consumer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private final MyQueen queen;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 该线程的名字</span><br><span class="line">     */</span><br><span class="line">    private final String name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 需要消费的资料个数</span><br><span class="line">     */</span><br><span class="line">    private final int size;</span><br><span class="line"></span><br><span class="line">    public Consumer(String name, MyQueen queen, int size) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.queen = queen;</span><br><span class="line">        this.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 1; i &lt;= size; i++) &#123;</span><br><span class="line">//            System.out.println(name + &quot; consume start&quot;);</span><br><span class="line">            int result = queen.dequeue();</span><br><span class="line">//            System.out.println(name + &quot; consume : &quot; + result + &quot; end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>做一个测试的main方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyQueen myQueen = new MyQueen(3);</span><br><span class="line">    new Thread(new Pruducer(&quot;producer1&quot;, myQueen, 0, 2)).start();</span><br><span class="line">    new Thread(new Pruducer(&quot;producer2&quot;, myQueen, 2, 5)).start();</span><br><span class="line">    new Thread(new Consumer(&quot;consumer1&quot;, myQueen, 3)).start();</span><br><span class="line">    new Thread(new Consumer(&quot;consumer2&quot;, myQueen, 5)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 has bean entered</span><br><span class="line">2 has bean entered</span><br><span class="line">3 has bean entered</span><br><span class="line">1 has bean dequeued</span><br><span class="line">2 has bean dequeued</span><br><span class="line">3 has bean dequeued</span><br><span class="line">4 has bean entered</span><br><span class="line">5 has bean entered</span><br><span class="line">6 has bean entered</span><br><span class="line">4 has bean dequeued</span><br><span class="line">5 has bean dequeued</span><br><span class="line">6 has bean dequeued</span><br><span class="line">7 has bean entered</span><br><span class="line">8 has bean entered</span><br><span class="line">9 has bean entered</span><br><span class="line">7 has bean dequeued</span><br><span class="line">8 has bean dequeued</span><br><span class="line">9 has bean dequeued</span><br></pre></td></tr></table></figure></p><p>虽然满足我想要的结果，但显示的内容有些奇怪，总是容器先被填满之后，然后容器被清空，感觉原因应该和<code>可重入锁</code>有关。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我对于管程的一些理解，如果大家有什么疑问，欢迎在下方留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java是利用&lt;code&gt;管程&lt;/code&gt;解决并发编程问题的，那么究竟什么是&lt;code&gt;管程&lt;/code&gt;？而它又是如何解决并发问题的呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="管程" scheme="http://yoursite.com/tags/%E7%AE%A1%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>nginx报错111: Connection refused</title>
    <link href="http://yoursite.com/2019/06/06/Nginx%E6%8A%A5%E9%94%99111-Connection-refused/"/>
    <id>http://yoursite.com/2019/06/06/Nginx报错111-Connection-refused/</id>
    <published>2019-06-06T04:22:41.000Z</published>
    <updated>2019-09-30T01:38:12.826Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了Nginx疯狂抛错，access.log一天一共5W多条，但error.log中有大概9K多条，基本都是<code>111: Connection refused</code>，这到底是为什么呢？<br><a id="more"></a></p><h2 id="从日志看起"><a href="#从日志看起" class="headerlink" title="从日志看起"></a>从日志看起</h2><p>我们还是先来看日志。我提取了一条error.log当中抛错的日志(稍微分一下行，否则实在太长，敏感信息稍微处理了一下):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019/06/06 10:09:45 [error] 28652#0: *883239 connect() failed (111: Connection refused) while connecting to upstream, </span><br><span class="line">client: 124.104.90.145, server: xxx.xxxxx.com, request: &quot;POST /test-service/upload?mcachenum=155978698 HTTP/1.1&quot;, </span><br><span class="line">upstream: &quot;http://[::1]:17000/test-service/upload?mcachenum=155978698&quot;, host: &quot;xxx.xxxxx.com&quot;, </span><br><span class="line">referrer: &quot;https://servicewechat.com/x98b46f69/2/page-frame.html&quot;</span><br></pre></td></tr></table></figure></p><p>看了一下前面的报错和后面的描述，第一眼看上去感觉都是正常。但再看之后发现，<code>upstream</code>中的host有些不一样。<code>[::1]</code>，这实际是一个IPv6的地址。</p><p>这时候你可以查看一下你的机器是否开启了IPv6的地址，linux的命令是：<code>ip address</code>，看看返回结果中是否出现了<code>inet6</code>，如果有，那么恭喜你，原因找到了。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决方法有两种，一个是禁用你机器的IPv6配置，另一个则是修改nginx.conf中的配置。</p><p>个人觉得后一个方法更加保险一些，因为这不涉及到你的机器配置，应该相对而言最少。</p><p>nginx.conf的修改，则是针对<code>server</code>模块中的<code>location</code>，修改<code>proxy_pass</code>中的host，我们在网上经常看到别人用的是：</p><p><code>proxy_pass http://localhost:18000/test-service/;</code></p><p>但为了强制指定IPv4的地址，需要变成：</p><p><code>proxy_pass http://127.0.0.1:18000/test-service/;</code></p><p>这样操作之后，再观察nginx的error.log，应该就不会再报upstream里含有IPv6地址的错误了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我这次错误的整个过程，虽然整个过程不长，但确实让我知道了，作为一个后端开发，我的知识面还是太窄了。而且Bing也是真的好用，最近无法翻墙了，暂时用Bing代替，感觉还是不错的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到了Nginx疯狂抛错，access.log一天一共5W多条，但error.log中有大概9K多条，基本都是&lt;code&gt;111: Connection refused&lt;/code&gt;，这到底是为什么呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
      <category term="[object Object]" scheme="http://yoursite.com/tags/object-Object/"/>
    
      <category term="upstream" scheme="http://yoursite.com/tags/upstream/"/>
    
      <category term="IPv6" scheme="http://yoursite.com/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>力扣-65不同路径</title>
    <link href="http://yoursite.com/2019/05/10/%E5%8A%9B%E6%89%A3-65%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/05/10/力扣-65不同路径/</id>
    <published>2019-05-10T11:10:11.000Z</published>
    <updated>2019-09-11T10:44:43.726Z</updated>
    
    <content type="html"><![CDATA[<p>最近在刷力扣上的题目，刷到了<a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">65不同路径</a>，当初上大学的时候，曾在hihocoder上刷到过这道题目，但是现在已经几乎全忘光了，大概的知识点是动态规划，如今就让我们一起来回顾一下。<br><a id="more"></a></p><h2 id="从题目说起"><a href="#从题目说起" class="headerlink" title="从题目说起"></a>从题目说起</h2><p>题目原文是：</p><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p></blockquote><blockquote><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p></blockquote><blockquote><p>问总共有多少条不同的路径？</p></blockquote><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/20190510.png" alt=""></p><blockquote><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p></blockquote><blockquote><p>说明：m 和 n 的值均不超过 100。</p></blockquote><blockquote><p>示例 1:</p></blockquote><blockquote><blockquote><p>输入: m = 3, n = 2</p></blockquote></blockquote><blockquote><blockquote><p>输出: 3</p></blockquote></blockquote><blockquote><blockquote><p>解释:</p></blockquote></blockquote><blockquote><blockquote><p>从左上角开始，总共有 3 条路径可以到达右下角。</p></blockquote></blockquote><blockquote><blockquote><ol><li>向右 -&gt; 向右 -&gt; 向下</li></ol></blockquote></blockquote><blockquote><blockquote><ol start="2"><li>向右 -&gt; 向下 -&gt; 向右</li></ol></blockquote></blockquote><blockquote><blockquote><ol start="3"><li>向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote></blockquote><blockquote><p>示例 2:</p></blockquote><blockquote><blockquote><p>输入: m = 7, n = 3</p></blockquote></blockquote><blockquote><blockquote><p>输出: 28</p></blockquote></blockquote><h2 id="正向思路"><a href="#正向思路" class="headerlink" title="正向思路"></a>正向思路</h2><p>我们先按照正常思路来想一下，当你处于起点时，你有两个选择，向右或者向下，除非你处于最下面一排或者最右边一列，那你只有一种选择（比如处于最下面一排，你只能往右），其他位置，你都有两种选择。</p><p>因此，我们就根据这个思路，可以写出代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        // 特殊情况：起点即终点</span><br><span class="line">        if (m == 1 &amp;&amp; n == 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当前处于(1,1)，终点为(m,n)</span><br><span class="line">        return walk(1, 1, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int walk(int x, int y, int m, int n)&#123;</span><br><span class="line">        // 已经处于终点</span><br><span class="line">        if (x &gt;= m &amp;&amp; y &gt;= n) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 处于最下面一排或者最右边一列</span><br><span class="line">        if (x &gt;= m || y &gt;= n) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 往下走，有多少种走法</span><br><span class="line">        int down = walk(x, y + 1, m, n);</span><br><span class="line">        // 往右走，有多少种走法</span><br><span class="line">        int right = walk(x + 1, y, m, n);</span><br><span class="line">        // 从当前(x,y)出发，走到(m,n)，共有多少种走法</span><br><span class="line">        return down + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们考虑一下，这种写法，有没有可以优化的地方。</p><p>你们应该一眼就发现，<code>walk</code>方法的第一个判断<code>if (x &gt;= m &amp;&amp; y &gt;= n)</code>，永远都不可能为<code>true</code>，因为下一个判断<code>if (x &gt;= m || y &gt;= n)</code>就已经是临界点情况，直接就已经有返回值，根本不可能达到<code>x &gt;= m &amp;&amp; y &gt;= n</code>的情况。因此，该判断可以删除。</p><p>假设我们从(1,1)的位置出发，终点是(3,3)，那么到达(2,2)这个中间点的话有几种走法呢？两种，先到(1,2)再到(2,2)，或者，先到(2,1)再到(2,2)。</p><p>因此，如果根据我们上面的写法，从(2,2)到终点(3,3)，我们会算两次，虽然这样的思路本身是正确，但这样的情况应该是可以优化的。因为从(1,1)到(3,3)，一共只有6种路径，但已经有2条是重复的路径了，那么随着<code>m</code>与<code>n</code>越来越大，中间点会越来越多，那么重复的路径也会越来越多。</p><p>这就是<code>前面的选择</code>对于<code>后面的选择</code>会有影响，即使<code>后面的选择</code>相同，但由于<code>前面的选择</code>不同，从而也被认为是不同的选择。</p><p>很明显，<code>后面的选择</code>更加唯一，如果我们先在后面做出选择，那么就可以减少重复计算的次数。因此，我们可以试试反向思路。</p><h2 id="反向思路"><a href="#反向思路" class="headerlink" title="反向思路"></a>反向思路</h2><p>如果我们不是从起点出发，而是从终点倒退到起点开始算的话。假设终点是(3,3)，它只能由(2,3)和(3,2)直接到达，(2,3)也只能由(2,2)和(1,3)直接到达，(1,3)只能由(1,2)直接到达，(1,2)只能由(1,1)直接到达，因此(1,3)只能由(1,1)直达。</p><p>我们可以得出规律：除了最左边一列和最上面一排的点，只能由起点(1,1)直达以外，其他的点(x,y)都是由(x-1,y)和(x,y-1)两个点直接到达的。</p><p>因此，根据这个思路，我们可以写出代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] result = new int[m][n];</span><br><span class="line">        int j;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (i == 0 || j == 0) &#123;</span><br><span class="line">                    // 最上面一排的点和最左边一列的点，只能由(1,1)到达</span><br><span class="line">                    result[i][j] = 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 其他的点都可以由左边的点和上面的点到达</span><br><span class="line">                    result[i][j] = result[i - 1][j] + result[i][j - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return result[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实这样的想法就已经是<code>动态规划</code>的范畴了，我们看看维基上的定义</p><blockquote><p>动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p></blockquote><p>一开始我感觉很像<code>分治法</code>，因为都需要将一个大问题分解为子问题，但<code>分治法</code>最终会将子问题合并，但<code>动态规划</code>却不用。</p><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>我们考虑一下，这种写法，有没有可以优化的地方。</p><p>首先是空间上的优化，我们一定要用二维数组吗？可以用一维数组代替吗？</p><p>答案是肯定的，因为每个点的计算只和左边与上边相邻的点有关，因此，不需要更加久远的点。</p><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><p>假如只用一维数组，那么只需要存储上一排的结果，如果计算到下一排的时候，则依次替换，代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] dp = new int[m];</span><br><span class="line">        int j;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if(j == 0) &#123;</span><br><span class="line">                    dp[j] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 其他的点都可以由左边的点和上面的点到达</span><br><span class="line">                    dp[j] += dp[j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[m-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的优化，差不多就结束了。那我们是否可以从思路上进行优化呢？</p><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>因为我们只有向右或向下两种选择，而我们一共要走的路径其实是<code>(m-n-2)</code>，其中有<code>(m-1)</code>的路径是向右，<code>(n-1)</code>的路径是向下，其实可以转变为：</p><blockquote><p>从<code>(m-n-2)</code>中挑出<code>(m-1)</code>，即组合数<code>C((m-n-2), (m-1))</code>的值</p></blockquote><p>那么我们可以写出代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        // 用double，因为计算出的数值会很大</span><br><span class="line">        double num = 1, denom = 1;</span><br><span class="line">        // 找出更小的数，这样可以减少计算次数和计算出的数值</span><br><span class="line">        int small = m &gt; n ? n : m;</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt;= small - 1; ++i) &#123;</span><br><span class="line">            num *= m + n - 1 - i;</span><br><span class="line">            denom *= i;</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">         return (int)(num / denom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##总结</p><p>以上就是我做这道题的一些思路和想法了，虽然题目本身不难，但可以讨论的点还是很多的，如果大家有什么疑问，欢迎在下方留言。</p><p>有兴趣的话可以关注我的公众号，说不定会有意外的惊喜。</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在刷力扣上的题目，刷到了&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;65不同路径&lt;/a&gt;，当初上大学的时候，曾在hihocoder上刷到过这道题目，但是现在已经几乎全忘光了，大概的知识点是动态规划，如今就让我们一起来回顾一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="组合数" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JWT与Session的比较</title>
    <link href="http://yoursite.com/2019/04/24/JWT%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/24/JWT的管理/</id>
    <published>2019-04-24T08:02:37.000Z</published>
    <updated>2019-04-24T11:24:02.723Z</updated>
    
    <content type="html"><![CDATA[<p>如今，越来越多的项目开始采用<code>JWT</code>作为认证授权机制，那么它和之前的<code>Session</code>究竟有什么区别呢？今天就让我们来了解一下。<br><a id="more"></a></p><h2 id="JWT是什么"><a href="#JWT是什么" class="headerlink" title="JWT是什么"></a><code>JWT</code>是什么</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑和自包含的方式，用于在各方之间作为JSON对象安全地传输信息。作为标准，它没有提供技术实现，但是大部分的语言平台都有按照它规定的内容提供了自己的技术实现，所以实际在用的时候，只要根据自己当前项目的技术平台，到官网上选用合适的实现库即可。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>使用JWT来传输数据，实际上传输的是一个字符串，这个字符串就是所谓的json web token字符串。所以广义上，JWT是一个标准的名称；狭义上，JWT指的就是用来传递的那个token字符串。这个串有两个特点：</p><ol><li>紧凑：指的是这个串很小，能通过url 参数，http 请求提交的数据以及http header的方式来传递；</li><li>自包含：这个串可以包含很多信息，比如用户的id、角色等，别人拿到这个串，就能拿到这些关键的业务信息，从而避免再通过数据库查询等方式才能得到它们。</li></ol><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019042401.png" alt="JWT结构"></p><p>它由三部分组成：header（头部）、payload（载荷）、signature（签名），以<code>.</code>进行分割。（这个字符串本来是只有一行的，此处分成3行，只是为了区分其结构）</p><ol><li><code>header</code>用来声明类型（typ）和算法（alg）。</li><li><code>payload</code>一般存放一些不敏感的信息，比如用户名、权限、角色等。</li><li><code>signature</code>则是将<code>header</code>和<code>payload</code>对应的json结构进行base64url编码之后得到的两个串用英文句点号拼接起来，然后根据<code>header</code>里面alg指定的签名算法生成出来的。</li></ol><h2 id="和Session的区别"><a href="#和Session的区别" class="headerlink" title="和Session的区别"></a>和<code>Session</code>的区别</h2><p>为什么我们要把<code>JWT</code>和<code>Session</code>做对比呢？因为我们主要在每一次请求的认证时会用<code>JWT</code>，在此之前我们都是用<code>Session</code>的。那这两者的区别在哪儿呢？</p><h3 id="本身的含义"><a href="#本身的含义" class="headerlink" title="本身的含义"></a>本身的含义</h3><p>看了前面的介绍，我们发现<code>JWT</code>这个字符串其实本身就包含了关于用户的信息，比如用户名、权限、角色等。</p><p><code>Session</code>传递的sessionId虽然是一个更简单的字符串，但它本身并没有任何含义。</p><p>所以一般说来<code>JWT</code>的字符串要比sessionId长，如果你在<code>JWT</code>中存储的信息越长，那么<code>JWT</code>本身也会越长。</p><p>而<code>Cookie</code>的存储容量是有限制的（通常为4KB），所以大家在使用的时候需要注意。</p><h3 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h3><p><code>JWT</code>的header和payload其实是有json转变过来的，而<code>signature</code>其实就是一个加密后的字符串，因此解析起来较为简单，不需要其他辅助的内容。</p><p>sessionId是服务器存储的用户对象的标识，理论上需要一个额外的map才能找出当前用户的信息。</p><h3 id="管理方法"><a href="#管理方法" class="headerlink" title="管理方法"></a>管理方法</h3><p><code>JWT</code>理论上用于无状态的请求，因此其用户管理也只是依赖本身而已。我们一般是在它的<code>payload</code>中加入过期时间，在不增加额外管理的情况下，它只有自动过期的方式。</p><p><code>Session</code>因为它本就是存储在服务器端的，因此管理方案就有很多，而且大多都很成熟。</p><h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p><code>JWT</code>本身就是基于json的，因此它是比较容易跨平台的，可以从官网下载不同平台的包，解析即可。</p><p>session的跨平台可能就不那么好做了，需要考虑的地方在于用户信息存储的格式，ProtoBuf、json、xml等，管理的话可能就需要专门的统一登录平台，这个就不展开了。</p><h3 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h3><p>无状态<code>JWT</code>一旦被生成，就不会再和服务端有任何瓜葛。一旦服务端中的相关数据更新，无状态<code>JWT</code>中存储的数据由于得不到更新，就变成了过期的数据。</p><p>session就不一样了，sessionId本身就没有太多含义，只需修改服务端中存储的数据即可。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a><code>JWT</code></h3><p><code>JWT</code>的最佳用途是<code>一次性授权Token</code>，这种场景下的Token的特性如下：</p><ul><li>有效期短</li><li>只希望被使用一次</li></ul><p>真实场景的例子——文件托管服务，由两部分组成：</p><ul><li>Web 应用：这是一个可以被用户登录并维持状态的应用，用户在应用中挑选想要下载的文件。</li><li>文件下载服务：无状态下载服务，只允许通过密钥下载。</li></ul><p>如何把<code>JWT</code>用在这个场景中呢？</p><ol><li>用户登录到 Web 应用中，挑选好想要下载的文件，点击下载。</li><li><p>认证服务颁发包含下载信息的、具有较短过期时间的JWT。JWT中包含的信息可以是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;file&quot;: &quot;/books/我这一辈子.pdf&quot;,</span><br><span class="line">    &quot;exp&quot;: 1500719759621</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 JWT 从文件下载服务下载文件。</p></li></ol><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a><code>Session</code></h3><p><code>Session</code>比较适用于Web应用的会话管理，其特点一般是：</p><ul><li>权限多，如果用<code>JWT</code>则其长度会很长，很有可能突破Cookie的存储限制。</li><li>基本信息容易变动。如果是一般的后台管理系统，肯定会涉及到人员的变化，那么其权限也会相应变化，如果使用<code>JWT</code>，那就需要服务器端进行主动失效，这样就将原本无状态的<code>JWT</code>变成有状态，改变了其本意。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们使用<code>JWT</code>，并不是说看到它新就用，而应该考虑其适用场景，如果需要进行管理，可以考虑使用<code>Session</code>，毕竟其方案更加成熟。如果大家有什么新发现想和作者探讨的，欢迎在下方留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如今，越来越多的项目开始采用&lt;code&gt;JWT&lt;/code&gt;作为认证授权机制，那么它和之前的&lt;code&gt;Session&lt;/code&gt;究竟有什么区别呢？今天就让我们来了解一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="JWT" scheme="http://yoursite.com/tags/JWT/"/>
    
      <category term="Session" scheme="http://yoursite.com/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>TCP连接及其优化</title>
    <link href="http://yoursite.com/2019/04/18/TCP%E8%BF%9E%E6%8E%A5%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/18/TCP连接及其优化/</id>
    <published>2019-04-18T10:37:33.000Z</published>
    <updated>2019-04-19T02:30:50.512Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个后端程序员，网络连接这块是一个绕不过的砍，当你在做服务器优化的时候，网络优化也是其中一环，那么作为网络连接中最基础的部分-<code>TCP连接</code>你了解吗？今天我们来仔细看看这个部分。<br><a id="more"></a></p><h2 id="TCP建立连接-三次握手"><a href="#TCP建立连接-三次握手" class="headerlink" title="TCP建立连接-三次握手"></a>TCP建立连接-三次握手</h2><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019041801.jpg?raw=true" alt="三次握手"></p><ol><li>客户端和服务器还未建立连接，但服务器一般处于<code>listen</code>状态</li><li>客户端主动建立连接，向服务器发送SYN报文，客户端变为<code>SYN_SENT</code>状态</li><li>服务器收到客户端发送的报文，也回了一个SYN报文，包含了一个ack。此时，服务器变为<code>SYN_RCVD</code>状态</li><li>客户端收到了服务器发送的SYN报文，确认了ack，它将向服务器发送一个ACK报文。此时，客户端变为<code>ESTABLISHED</code></li><li>服务器收到客户端的ACK报文，确认了ack。此时，服务器也变为<code>ESTABLISHED</code></li><li>服务器和客户端可以正常通信了</li></ol><p>其中步骤2~4就是三次握手，那么为什么需要三次握手呢？为什么不是一次或者两次握手呢？</p><p>首先，我们需要知道，只有当服务器和客户端都能确保自己能够发消息和接收消息，这次网络通信才算成功的。</p><p>步骤2的作用是让服务器知道了自己是可以接收消息的。</p><p>步骤3的作用是让客户端知道自己发送消息和接收消息的功能是OK的，发送消息的能力是通过服务器返回的<code>ack=x+1</code>确认的，因为这个值基于当初客户端发送的消息<code>seq=x</code>。接收消息的能力是因为收到了服务器的返回。</p><p>步骤4的作用是让服务器端知道自己发送消息的能力是OK的（和步骤3类似）。</p><h3 id="linux查看"><a href="#linux查看" class="headerlink" title="linux查看"></a>linux查看</h3><p>linux服务器可以利用<code>netstat -anp | grep tcp</code>命令，查看服务器上各个端口和应用的连接状态。</p><p>你还可以通过修改linux的配置文件<code>/etc/sysctl.conf</code>，调整各个状态的数量</p><h4 id="SYN-SENT状态相关"><a href="#SYN-SENT状态相关" class="headerlink" title="SYN_SENT状态相关"></a><code>SYN_SENT</code>状态相关</h4><ul><li><p>主动建立连接时，发SYN（步骤2）的重试次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nct.ipv4.tcp_syn_rctries = 6</span><br></pre></td></tr></table></figure></li><li><p>建立连接时的本地端口可用范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_local_port_range = 32768 60999</span><br></pre></td></tr></table></figure></li></ul><h4 id="SYN-RCVD状态相关"><a href="#SYN-RCVD状态相关" class="headerlink" title="SYN_RCVD状态相关"></a><code>SYN_RCVD</code>状态相关</h4><ul><li><p><code>SYN_RCVD</code>状态连接的最大个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_max_syn_backlog</span><br></pre></td></tr></table></figure></li><li><p>被动建立连接时，发SYN/ACK（步骤3）重试次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_synack_retries</span><br></pre></td></tr></table></figure></li></ul><p>说完了TCP建立连接，接下来，我们再来看看TCP正常断开连接的过程</p><h2 id="TCP断开连接-四次挥手"><a href="#TCP断开连接-四次挥手" class="headerlink" title="TCP断开连接-四次挥手"></a>TCP断开连接-四次挥手</h2><h3 id="详解-1"><a href="#详解-1" class="headerlink" title="详解"></a>详解</h3><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019041802.jpg?raw=true" alt="四次挥手"></p><ol><li>客户端与服务器端正常传输数据</li><li>客户端主动断开连接，向服务器端发送FIN报文，客户端变为<code>FIN_WAIT1</code>状态</li><li>服务器收到客户端的FIN后，向客户端发送ACK报文，服务器变为<code>CLOSE_WAIT</code>状态</li><li>客户端收到服务器的ACK报文后，客户端变为<code>FIN_WAIT2</code>状态</li><li>服务器向客户端发送FIN报文，服务器变为<code>LAST_ACK</code>状态</li><li>客户端收到服务器发送的FIN报文后，向服务器发送ACK报文，客户端变为<code>TIME_WAIT</code>状态</li><li>服务器收到客户端的ACK报文后，服务器变为<code>CLOSED</code>状态</li><li>客户端经过2MSL(max segment lifetime，报文最大生存时间)时间后，也变为<code>CLOSED</code>状态</li></ol><p>其中，步骤2、3、5、6即为4次挥手。</p><h3 id="TIME-WAIT状态及其优化"><a href="#TIME-WAIT状态及其优化" class="headerlink" title="TIME_WAIT状态及其优化"></a><code>TIME_WAIT</code>状态及其优化</h3><p>看完之后，大家想必会有一个疑问，为什么<code>TIME_WAIT</code>状态需要保持2MSL？因为这可以保证至少一次报文的往返时间内，端口是不可复用的。</p><p>假设<code>TIME_WAIT</code>状态的持续时间很短，我们来模拟下面这种场景：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019041901.png?raw=true" alt=""></p><ul><li>客户端向服务器端发送了三条报文，其中第3条报文卡在网络中，服务器只收到了前两条，向客户单发送ACK=2，客户端重新发送第三条报文。</li><li>服务器主动发送FIN报文，客户端收到后发送FIN、ACK，服务器端收到后发送ACK并进入<code>TIME_WAIT</code>状态（假设这个状态很短）。</li><li>现在服务器又再次和客户端建立连接，三次握手之后开始发送正常数据，结果之前卡住的第三条报文，现在终于发送到服务器，但服务器也不知道该如何处理这条报文。</li></ul><p>因此这也是<code>TIME_WAIT</code>状态需要保持2MSL的原因，如果这么长时间也没有收到报文，即使有正确的报文从客户端发出，也已经过期了，因此不会影响到之后的通信。</p><p>但这同样也会带来一个问题，<code>TIME_WAIT</code>状态保持的时间较长，假设服务器端有大量<code>TIME_WAIT</code>状态的TCP连接，就相当于白白浪费掉大量的服务器资源(端口)。此时，我们可以通过修改以下配置进行服务器调优：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br></pre></td></tr></table></figure></p><ul><li>开启后，作为客户端时新连接可以使用仍然处于<code>TIME_WAIT</code>状态的端口</li><li>由于timestamp的存在，操作系统可以拒绝迟到的报文（例如上面说的第三条报文），可以利用以下配置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps = 1</span><br></pre></td></tr></table></figure><h3 id="其他状态的优化"><a href="#其他状态的优化" class="headerlink" title="其他状态的优化"></a>其他状态的优化</h3><h4 id="CLOSE-WAIT状态"><a href="#CLOSE-WAIT状态" class="headerlink" title="CLOSE_WAIT状态"></a><code>CLOSE_WAIT</code>状态</h4><p>如果服务器端有大量<code>CLOSE_WAIT</code>状态的连接，很有可能是应用进程出现bug，没有及时关闭连接。</p><h4 id="FIN-WAIT1状态"><a href="#FIN-WAIT1状态" class="headerlink" title="FIN_WAIT1状态"></a><code>FIN_WAIT1</code>状态</h4><p>调整发送FIN报文的重试次数，0相当于8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_orphan_retries = 0</span><br></pre></td></tr></table></figure></p><h4 id="FIN-WAIT2状态"><a href="#FIN-WAIT2状态" class="headerlink" title="FIN_WAIT2状态"></a><code>FIN_WAIT2</code>状态</h4><p>调整保持在<code>FIN_WAIT2</code>状态的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_fin_timeout = 60</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到这里，想必你应该对TCP连接有了一个大致的了解。现在服务器大多都用了nginx做了负载均衡，因此，我们可能需要在此基础上了解一些nginx相关的配置原理，这样应该会对我们的服务器性能调优会有更大的帮助。有兴趣的同学不妨可以去了解一下，如果有什么新发现想和作者探讨的，欢迎在下方留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个后端程序员，网络连接这块是一个绕不过的砍，当你在做服务器优化的时候，网络优化也是其中一环，那么作为网络连接中最基础的部分-&lt;code&gt;TCP连接&lt;/code&gt;你了解吗？今天我们来仔细看看这个部分。&lt;br&gt;
    
    </summary>
    
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Java中容器的遍历</title>
    <link href="http://yoursite.com/2019/04/17/Java%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/04/17/Java中容器的遍历/</id>
    <published>2019-04-17T10:44:42.000Z</published>
    <updated>2019-04-18T02:05:53.515Z</updated>
    
    <content type="html"><![CDATA[<p>当我们用增强for循环遍历非并发容器（HashMap、ArrayList等），如果修改其结构，会抛出异常<code>ConcurrentModificationException</code>，因此在阿里巴巴的Java规范中有说到：<code>不要在foreach循环里进行元素的remove/add操作，remove元素请使用Iterator方式。</code>，但是不是真的就不可以在增强for循环中修改结构吗？其原理又是什么呢？<br><a id="more"></a></p><h2 id="ConcurrentModificationException的含义"><a href="#ConcurrentModificationException的含义" class="headerlink" title="ConcurrentModificationException的含义"></a>ConcurrentModificationException的含义</h2><p><code>ConcurrentModificationException</code>可以将其通俗的翻译为<code>并发修改异常</code>，那么关注点就在<code>并发</code>和<code>修改</code>了。也许有些人会说，我只是在单线程中修改了，并没有并发操作，但系统也抛了这样的这样的错误，这是为什么呢？别急，我们看看它的源码解释：</p><blockquote><p>This exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible.</p></blockquote><p>这个异常就是应用程序在做一些系统不允许的操作时抛出的。记住，只要是系统不允许的操作，就一定会抛错的。</p><p>后面有一个值得注意的地方</p><blockquote><p>Note that fail-fast behavior cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast operations throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: ConcurrentModificationException should be used only to detect bugs.</p></blockquote><p><code>fail-fast</code>（快速失败）并不能一定被保证，所以<code>fail-fast</code>操作会尽最大努力抛出该异常。既然是尽最大努力，因此无论是不是并发操作，只要是修改了，就一定会报错。</p><p>既然如此，我们来看看for循环中遍历修改容器结构，系统是如何知道的。</p><h2 id="增加for循环的原理"><a href="#增加for循环的原理" class="headerlink" title="增加for循环的原理"></a>增加for循环的原理</h2><p>我们来看看增强for循环遍历修改HashMap的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(10);</span><br><span class="line">// 添加</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  hashMap.put(&quot;key&quot; + i, &quot;value&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">// 遍历修改</span><br><span class="line">for (Entry&lt;String, String&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">  String key = entry.getKey();</span><br><span class="line">  hashMap.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候，你如果运行的话，就会抛出<code>ConcurrentModificationException</code>，这个时候我们需要具体调试一下，发现遍历第一次并删除时没有报错，但第二次遍历，在for循环的括号执行完后，就抛出了异常，这又是为什么呢？</p><p>让我们反编译一下class文件，看看究竟增强for循环做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = new HashMap(10);</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">  hashMap.put(&quot;key&quot; + i, &quot;value&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator var5 = hashMap.entrySet().iterator();</span><br><span class="line">while(var5.hasNext()) &#123;</span><br><span class="line">  Entry&lt;String, String&gt; entry = (Entry)var5.next();</span><br><span class="line">  String key = (String)entry.getKey();</span><br><span class="line">  hashMap.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们发现，虽然写法上是增强for循环，但实际还是使用的<code>while</code>结合<code>iterator</code>进行遍历，现在我们贴上这个代码进行调试。</p><p>发现在第二次<code>var5.next()</code>处抛异常，接下来我们看看<code>next</code>方法究竟做了什么？</p><p>在<code>HashMap</code>的源码中显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final class EntryIterator extends HashIterator</span><br><span class="line">    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">    public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; nextNode() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] t;</span><br><span class="line">    Node&lt;K,V&gt; e = next;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123;</span><br><span class="line">        do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class="line">    &#125;</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们注意到，<code>nextNode()</code>方法的第一个判断就决定了是否抛出<code>ConcurrentModificationException</code>，那么<code>modCount</code>和<code>expectedModCount</code>究竟是什么呢？</p><h2 id="modCount和expectedModCount"><a href="#modCount和expectedModCount" class="headerlink" title="modCount和expectedModCount"></a>modCount和expectedModCount</h2><p>我们来看看<code>modCount</code>和<code>expectedModCount</code>的关系，当我们调用<code>Iterator var5 = hashMap.entrySet().iterator();</code>时，源代码做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    Node&lt;K,V&gt;[] t = table;</span><br><span class="line">    current = next = null;</span><br><span class="line">    index = 0;</span><br><span class="line">    if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry</span><br><span class="line">        do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在一开始，就让<code>expectedModCount</code>等于<code>modCount</code>，而当我们调用<code>hashMap.remove(key);</code>时，实际上修改了<code>modCount</code>的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        else if ((e = p.next) != null) &#123;</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">            else if (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            else</span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>modCount</code>增大1，那么，当我们下一次调用<code>var5.next()</code>时，自然就发现<code>modCount</code>和<code>expectedModCount</code>不等了。</p><h2 id="修改结构的正确姿势"><a href="#修改结构的正确姿势" class="headerlink" title="修改结构的正确姿势"></a>修改结构的正确姿势</h2><p>使用<code>增强for循环</code>，本质还是在使用<code>iterator</code>，那为什么大家都在推介使用<code>iterator.remove()</code>呢？让我们看看源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final void remove() &#123;</span><br><span class="line">    Node&lt;K,V&gt; p = current;</span><br><span class="line">    if (p == null)</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    current = null;</span><br><span class="line">    K key = p.key;</span><br><span class="line">    removeNode(hash(key), key, null, false, false);</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们发现，这个remove方法虽然也调用了<code>removeNode</code>，但它在最后一步再次将<code>modCount</code>的值赋给<code>expectedModCount</code>，因此保证了下一次调用<code>next()</code>方法是不抛错。</p><p>所以，我们要么就直接显示地使用<code>iterator</code>，用它的<code>remove</code>方法移除对象。如果你实在想用<code>增强for循环</code>遍历删除，那么也只能在删除一个后，立刻退出循环。但无论用哪种方法，当多个线程同时修改时，都会有出错的可能性，因为你即时保证单个线程内的<code>modCount</code>和<code>expectedModCount</code>，但这个操作并不能保证原子性。</p><p>因此，如果在多线程环境下，我更推介使用<code>ConcurrentHashMap</code>，因为它没有<code>modCount</code>和<code>expectedModCount</code>的概念，因此，即时你是使用<code>增强for循环</code>遍历删除，也不会出现问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们用增强for循环遍历非并发容器（HashMap、ArrayList等），如果修改其结构，会抛出异常&lt;code&gt;ConcurrentModificationException&lt;/code&gt;，因此在阿里巴巴的Java规范中有说到：&lt;code&gt;不要在foreach循环里进行元素的remove/add操作，remove元素请使用Iterator方式。&lt;/code&gt;，但是不是真的就不可以在增强for循环中修改结构吗？其原理又是什么呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>DDL-事务的一种实现</title>
    <link href="http://yoursite.com/2019/03/09/DDL-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/09/DDL-事务的一种实现/</id>
    <published>2019-03-09T06:07:18.000Z</published>
    <updated>2019-04-17T10:41:34.799Z</updated>
    
    <content type="html"><![CDATA[<p>上次曾和大家说过<a href="https://death00.github.io/2018/10/31/DDL-%E8%84%8F%E6%95%B0%E6%8D%AE%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0/#more" target="_blank" rel="noopener">DDL-脏数据层的实现</a>，当时的我以为使用它的最大好处就是减少IO操作。但最近在项目中使用时，发现它也可以作为事务的一种临时实现。<br><a id="more"></a></p><p>大家知道，在Mongodb4.0之前是不支持事务的。因此，如果你的MongoDB使用的是低于4.0的版本，那么你一般都是在业务层去弥补，而这个DDL也可以做这样的事。</p><p>DDL中，业务场景一般是一个请求过来，直接修改缓存中的数据，我们默认这一步是成功的。后台会有一个专门的线程去定期扫描所有的脏数据，如果脏数据有<code>脏字段</code>，那么就将脏数据入库，入库成功自然便是皆大欢喜了，但如果不成功呢？</p><p>记得当时用MySql数据库，项目用的Spring boot + MyBatis，利用<code>@Transactional</code>注解，将几个数据库操作放在一个方法，这样即便出错，也可以自动回退。</p><p>但现在我们用的是MongoDB，而且我现在的版本是3.2（坑爹的阿里云服务）。数据库本身就不支持事务，这样我的DDL在将脏数据刷入数据库时，如果抛错，那么我的缓存里依旧是正确的数据，我只需要继续记录这些没有成功刷入数据库的脏数据字段，那么缓存里的数据，就依旧是刷入数据库之前的状态。而当后续请求进来后，其访问到的，也还是缓存里的正确数据。你只需要在抛错处设置报警，这样就可以即时知道问题，此时只需要专心修改这些问题，这样脏数据就会在线程下一次运行中，将数据刷入数据库中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次曾和大家说过&lt;a href=&quot;https://death00.github.io/2018/10/31/DDL-%E8%84%8F%E6%95%B0%E6%8D%AE%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DDL-脏数据层的实现&lt;/a&gt;，当时的我以为使用它的最大好处就是减少IO操作。但最近在项目中使用时，发现它也可以作为事务的一种临时实现。&lt;br&gt;
    
    </summary>
    
      <category term="DDL" scheme="http://yoursite.com/categories/DDL/"/>
    
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor原理探讨</title>
    <link href="http://yoursite.com/2019/02/14/Disruptor%E5%8E%9F%E7%90%86%E6%8E%A2%E8%AE%A8/"/>
    <id>http://yoursite.com/2019/02/14/Disruptor原理探讨/</id>
    <published>2019-02-14T05:23:55.000Z</published>
    <updated>2019-09-25T07:25:30.898Z</updated>
    
    <content type="html"><![CDATA[<p>之前谈到了在我的项目里用到了Disruptor，因为对它了解不足的原因，才会引发之前的问题，因此，今天特意来探讨其原理。<br><a id="more"></a></p><h2 id="为什么采用Disruptor"><a href="#为什么采用Disruptor" class="headerlink" title="为什么采用Disruptor"></a>为什么采用Disruptor</h2><p>先介绍一下我的这个服务。这个服务主要是作为游戏服务器的游戏逻辑部分，包括帧同步逻辑及其他在游戏过程中玩家产生的一些业务逻辑。</p><p>从用户量来说，现在最高峰大概有300人同时在线，游戏服务器设置1秒有30帧的数据量，因此，1秒内服务器接收到的请求量为<code>30 * 300 = 9000</code>。</p><p>虽然QPS并不是很高，但对于多人对抗竞技类游戏而言，低延迟十分重要，每一次客户端向服务器端的响应时间需要低于<code>1/30</code>秒（因为1秒需要发送30次）。针对这种情况，我需要的存储消息的容器应该具备快速生产、快速消费的特性。</p><p>那为什么当初要选择使用Disruptor作为存储客户端发来消息的容器，为什么不直接使用Java本身自带的那些队列结构呢？</p><p>让我们看看Java里常用的线程安全的内置队列：</p><table><thead><tr><th>类</th><th>是否有界</th><th>是否加锁</th><th>底层数据结构</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>有界</td><td>加锁</td><td>数组</td></tr><tr><td>LinkedBlockingQueue</td><td>有界（2^31-1）</td><td>加锁</td><td>链表</td></tr><tr><td>ConcurrentLinkedQueue</td><td>无界</td><td>无锁</td><td>链表</td></tr><tr><td>LinkedTransferQueue</td><td>无界</td><td>无锁</td><td>链表</td></tr><tr><td>PriorityBlockingQueue</td><td>无界</td><td>加锁</td><td>堆</td></tr><tr><td>DelayQueue</td><td>无界</td><td>加锁</td><td>堆</td></tr></tbody></table><p>一般来说我们并不会考虑堆，因为堆在实现带有优先级的队列更好。</p><p>从性能上来说，无锁时的QPS一般来说优于加锁，而<code>ConcurrentLinkedQueue</code>的无锁其实是通过原子变量进行<code>compare and swap</code>（以下简称为<code>CAS</code>，由CPU保证原子性）这种不加锁的方式来实现的。</p><p>但无锁的结构都是无界的，为了系统的稳定，我们需要防止生产者速度过快导致内存溢出，我们需要使队列有界；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap（因为使用这两种结构，数据在内存中存储的地址连续）。</p><p>这样筛选下来，<code>ArrayBlockingQueue</code>可能相对而言更加合适，但它依旧存在性能问题——加锁、伪共享。</p><p>加锁上面也提到了，更好的方式是使用<code>CAS</code>，那<code>伪共享</code>又是什么呢？</p><h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><h4 id="什么是共享"><a href="#什么是共享" class="headerlink" title="什么是共享"></a>什么是共享</h4><p>下图是计算的基本结构。L1、L2、L3分别表示一级缓存、二级缓存、三级缓存，越靠近CPU的缓存，速度越快，容量也越小。所以L1缓存很小但很快，并且紧靠着在使用它的CPU内核；L2大一些，也慢一些，并且仍然只能被一个单独的CPU核使用；L3更大、更慢，并且被单个插槽上的所有CPU核共享；最后是主存，由全部插槽上的所有CPU核共享。如图：</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019021401.png?raw=true" alt=""></p><p>当CPU执行运算的时候，它先去L1查找所需的数据、再去L2、然后是L3，如果最后这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要尽量确保数据在L1缓存中。</p><p>另外，线程之间共享一份数据的时候，需要一个线程把数据写回主存，而另一个线程访问主存中相应的数据。</p><h4 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h4><p>Cache是由很多个cache line组成的。每个cache line通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。</p><p>CPU每次从主存中拉取数据时，会把相邻的数据也存入同一个cache line。</p><p>在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。事实上，你可以非常快速的遍历在连续内存块中分配的任意数据结构。</p><p>下面的例子是测试利用cache line的特性和不利用cache line的特性的效果对比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 缓存行</span><br><span class="line"> * Cache是由很多个cache line组成的。每个cache line通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。</span><br><span class="line"> *</span><br><span class="line"> * CPU每次从主存中拉取数据时，会把相邻的数据也存入同一个cache line。</span><br><span class="line"> *</span><br><span class="line"> * 在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。事实上，你可以非常快速的遍历在连续内存块中分配的任意数据结构。</span><br><span class="line"> */</span><br><span class="line">public class CacheLineEffect &#123;</span><br><span class="line">  //考虑一般缓存行大小是64字节，一个 long 类型占8字节</span><br><span class="line">  static  long[][] arr;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    arr = new long[1024 * 1024][];</span><br><span class="line">    for (int i = 0; i &lt; 1024 * 1024; i++) &#123;</span><br><span class="line">      arr[i] = new long[8];</span><br><span class="line">      for (int j = 0; j &lt; 8; j++) &#123;</span><br><span class="line">        arr[i][j] = 0L;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    long sum = 0L;</span><br><span class="line">    long marked = System.currentTimeMillis();</span><br><span class="line">    for (int i = 0; i &lt; 1024 * 1024; i+=1) &#123;</span><br><span class="line">      // 此时的8个数据其实已经直接在拿第1次的时候就全部拿下来了</span><br><span class="line">      for(int j =0; j&lt; 8;j++)&#123;</span><br><span class="line">        sum = arr[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Loop times:&quot; + (System.currentTimeMillis() - marked) + &quot;ms&quot;);</span><br><span class="line"></span><br><span class="line">    marked = System.currentTimeMillis();</span><br><span class="line">    for (int i = 0; i &lt; 8; i+=1) &#123;</span><br><span class="line">      // 此时拿的数据其实同一列上的数据，从内存地址上来说并不连续</span><br><span class="line">      for(int j =0; j&lt; 1024 * 1024;j++)&#123;</span><br><span class="line">        sum = arr[j][i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Loop times:&quot; + (System.currentTimeMillis() - marked) + &quot;ms&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loop times:16ms</span><br><span class="line">Loop times:72ms</span><br></pre></td></tr></table></figure></p><p>速度差异还是比较明显的。</p><h4 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h4><p>ArrayBlockingQueue有三个成员变量： - takeIndex：需要被取走的元素下标 - putIndex：可被元素插入的位置的下标 - count：队列中元素的数量</p><p>这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019021402.png?raw=true" alt=""></p><p>如上图所示，当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。</p><p>这种无法充分使用缓存行特性的现象，称为伪共享。</p><p>对于伪共享，一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 伪共享</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 针对处在同一个缓存行内的数据，假设线程1修改了其中的一个数据a后，线程2想要读取数据a，</span></span><br><span class="line"><span class="comment"> * 因为a已经被修改了，因此缓存行失效，需要从主内存中重新读取。</span></span><br><span class="line"><span class="comment"> * 这种无法充分使用缓存行特性的现象，称为伪共享。</span></span><br><span class="line"><span class="comment"> * 当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">100L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ValueNoPadding[] longsNoPadding;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ValuePadding[] longsPadding;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> padding;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex, <span class="keyword">boolean</span> padding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    <span class="keyword">this</span>.padding = padding;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">      System.gc();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">      runTestNoPadding(i);</span><br><span class="line">      System.out.println(<span class="string">"NoPadding Thread num "</span>+i+<span class="string">" duration = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">      System.gc();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">      runTestPadding(i);</span><br><span class="line">      System.out.println(<span class="string">"Padding Thread num "</span>+i+<span class="string">" duration = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTestPadding</span><span class="params">(<span class="keyword">int</span> NUM_THREADS)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line">    longsPadding = <span class="keyword">new</span> ValuePadding[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longsPadding.length; i++) &#123;</span><br><span class="line">      longsPadding[i] = <span class="keyword">new</span> ValuePadding();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">      threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i, <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTestNoPadding</span><span class="params">(<span class="keyword">int</span> NUM_THREADS)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line">    longsNoPadding = <span class="keyword">new</span> ValueNoPadding[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longsNoPadding.length; i++) &#123;</span><br><span class="line">      longsNoPadding[i] = <span class="keyword">new</span> ValueNoPadding();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">      threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (padding) &#123;</span><br><span class="line">        longsPadding[arrayIndex].value = <span class="number">0L</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        longsNoPadding[arrayIndex].value = <span class="number">0L</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValuePadding</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p15;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueNoPadding</span> </span>&#123;</span><br><span class="line">    <span class="comment">// protected long p1, p2, p3, p4, p5, p6, p7;</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// protected long p9, p10, p11, p12, p13, p14, p15;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NoPadding Thread num 1 duration = 394</span><br><span class="line">NoPadding Thread num 2 duration = 1594</span><br><span class="line">NoPadding Thread num 3 duration = 1702</span><br><span class="line">NoPadding Thread num 4 duration = 1580</span><br><span class="line">NoPadding Thread num 5 duration = 3217</span><br><span class="line">NoPadding Thread num 6 duration = 3539</span><br><span class="line">NoPadding Thread num 7 duration = 3269</span><br><span class="line">NoPadding Thread num 8 duration = 3317</span><br><span class="line">NoPadding Thread num 9 duration = 2800</span><br><span class="line">Padding Thread num 1 duration = 373</span><br><span class="line">Padding Thread num 2 duration = 432</span><br><span class="line">Padding Thread num 3 duration = 453</span><br><span class="line">Padding Thread num 4 duration = 490</span><br><span class="line">Padding Thread num 5 duration = 533</span><br><span class="line">Padding Thread num 6 duration = 565</span><br><span class="line">Padding Thread num 7 duration = 622</span><br><span class="line">Padding Thread num 8 duration = 685</span><br><span class="line">Padding Thread num 9 duration = 810</span><br></pre></td></tr></table></figure></p><p>从这儿可以看出，使用了共享机制比没有使用共享机制，速度快了4倍左右。（在jdk1.8中，有专门的注解@Contended来避免伪共享，更优雅地解决问题，有兴趣地朋友可以取了解一下。）</p><p>因此，虽然ArrayBlockingQueue相对于其他队列结构而言更适合我的服务，但依旧有着性能上的缺陷，因此我选择了Disruptor。</p><h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><p>Disruptor通过环形数组结构来解决队列速度慢的问题，那具体针对生产者和消费者，它是如何保证数据读写一致性的呢？</p><h4 id="一个生产者写数据"><a href="#一个生产者写数据" class="headerlink" title="一个生产者写数据"></a>一个生产者写数据</h4><p>生产者单线程写数据的流程比较简单： 1. 申请写入m个元素； 2. 若是有m个元素可以写入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素； 3. 若是返回的正确，则生产者开始写入元素。</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019021403.png?raw=true" alt=""></p><h4 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h4><p>多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过CAS很容易达到。只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去即可。</p><p>但是会遇到一个新问题：如何防止读取的时候，读到还未写的元素。Disruptor在多个生产者的情况下，引入了一个与Ring Buffer大小相同的buffer：available Buffer。当某个位置写入成功的时候，便把availble Buffer相应的位置置位，标记为写入成功。读取的时候，会遍历available Buffer，来判断元素是否已经就绪。</p><p>下面分读数据和写数据两种情况介绍。</p><h5 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h5><p>生产者多线程写入的情况会复杂很多： 1. 申请读取到序号n； 2. 若writer cursor &gt;= n，这时仍然无法确定连续可读的最大下标。从reader cursor开始读取available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置； 3. 消费者读取元素。</p><p>如下图所示，读线程读到下标为2的元素，三个线程Writer1/Writer2/Writer3正在向RingBuffer相应位置写数据，写线程被分配到的最大元素下标是11。</p><p>读线程申请读取到下标从3到11的元素，判断writer cursor&gt;=11。然后开始读取availableBuffer，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。</p><p>然后，消费者读取下标从3到6共计4个元素。</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019021404.png?raw=true" alt=""></p><h5 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h5><p>多个生产者写入的时候： 1. 申请写入m个元素； 2. 若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间； 3. 生产者写入元素，写入元素的同时设置available Buffer里面相应的位置，以标记自己哪些位置是已经写入成功的。</p><p>如下图所示，Writer1和Writer2两个线程写入数组，都申请可写的数组空间。Writer1被分配了下标3到下表5的空间，Writer2被分配了下标6到下标9的空间。</p><p>Writer1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019021405.png?raw=true" alt=""></p><h3 id="消费者的等待策略"><a href="#消费者的等待策略" class="headerlink" title="消费者的等待策略"></a>消费者的等待策略</h3><table><thead><tr><th>名称</th><th>措施</th><th>适用场景</th></tr></thead><tbody><tr><td>BlockingWaitStrategy</td><td>加锁</td><td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td></tr><tr><td>BusySpinWaitStrategy</td><td>自旋</td><td>通过不断重试，减少切换线程导致的系统调用，而降低延迟。推荐在线程绑定到固定的CPU的场景下使用</td></tr><tr><td>PhasedBackoffWaitStrategy</td><td>自旋 + yield + 自定义策略</td><td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td></tr><tr><td>SleepingWaitStrategy</td><td>自旋 + yield + sleep</td><td>性能和CPU资源之间有很好的折中。延迟不均匀</td></tr><tr><td>TimeoutBlockingWaitStrategy</td><td>加锁，有超时限制</td><td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td></tr><tr><td>YieldingWaitStrategy</td><td>自旋 + yield + 自旋</td><td>性能和CPU资源之间有很好的折中。延迟比较均匀</td></tr></tbody></table><p>从这儿可以看出，我需要的就是低延迟，因此就采用了<code>BusySpinWaitStrategy</code>，它虽然占用的资源多，但延迟低，非常符合我这个服务的要求。后来测试了一下其他的策略，发现都会有一些卡顿，毕竟不是一直在运行，接受到的客户端的消息就会有延迟产生。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Disruptor的高性能一方面是在于它没有用很重的锁，仅仅通过CPU的<code>CAS</code>就保证了操作的原子性；另一方面是在于它的数据结构RingBuffer（也包括Available）和Cursor的设计巧妙；当然还有它的等待策略、线程池等等。</p><p>如果你有什么意见或者建议，欢迎在下方评论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前谈到了在我的项目里用到了Disruptor，因为对它了解不足的原因，才会引发之前的问题，因此，今天特意来探讨其原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Disruptor" scheme="http://yoursite.com/tags/Disruptor/"/>
    
      <category term="缓存行" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98%E8%A1%8C/"/>
    
      <category term="RingBuffer" scheme="http://yoursite.com/tags/RingBuffer/"/>
    
  </entry>
  
  <entry>
    <title>线上Java服务使用Disruptor导致CPU占用超过100%的问题排查</title>
    <link href="http://yoursite.com/2019/02/13/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8BDisruptor%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/13/游戏服务器之Disruptor的使用/</id>
    <published>2019-02-13T09:27:55.000Z</published>
    <updated>2019-02-14T05:19:03.214Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一下部署游戏后台的服务器状况，发现我的一个Java程序其占用的CPU时长超过100%，排查后发现竟是Disruptor引起的，让我们来看看究竟为什么Disruptor会有这样的表现。<br><a id="more"></a></p><h2 id="发现占用CPU时间超过100-的进程"><a href="#发现占用CPU时间超过100-的进程" class="headerlink" title="发现占用CPU时间超过100%的进程"></a>发现占用CPU时间超过100%的进程</h2><p>首先是在服务器上用top命令查看服务器状态，发现有一个应用程序占用的CPU时长超过100%，如图：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019021301.png?raw=true" alt=""></p><p>我根据进程号查了一下，发现是我的一个Java游戏后台服务，有一个CPU几乎被占满，因此继续排查究竟是什么代码导致了这种情况。</p><p>用<code>top -Hp 27538</code>将这个进程的所有线程显示出来，按照CPU占用时间排序，看到了这个结果：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019021302.png?raw=true" alt=""></p><p>27658线程占用了近乎所有的CPU时间，而且一直都是，因此查看这个进程的详细信息。</p><p>用<code>jstack pid &gt; pid.log</code>命令将该进程的进程快照输出到一个文件中，下载下来。</p><p>将27658转换为16进制0x6c0a后在线程快照中查询(因为线程快照中线程ID都是16进制存放，所以需要转换)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;disruptor-0&quot; #27 prio=5 os_prio=0 tid=0x00007fa100c58000 nid=0x6c0a runnable [0x00007fa0ae080000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at com.lmax.disruptor.BusySpinWaitStrategy.waitFor(BusySpinWaitStrategy.java:39)</span><br><span class="line">    at com.lmax.disruptor.ProcessingSequenceBarrier.waitFor(ProcessingSequenceBarrier.java:56)</span><br><span class="line">    at com.lmax.disruptor.BatchEventProcessor.processEvents(BatchEventProcessor.java:159)</span><br><span class="line">    at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:125)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure></p><p>这是Disruptor的一个堆栈，为了更直观地查看线程的状态信息，可以将快照上传到专门的<a href="http://fastthread.io/" target="_blank" rel="noopener">分析平台上</a>。</p><p>（博主本人对于进程快照分析也是处于新手阶段，如果大家有什么建议或者意见，欢迎在下方留言。）</p><h2 id="分析Disruptor为何会占用整个CPU"><a href="#分析Disruptor为何会占用整个CPU" class="headerlink" title="分析Disruptor为何会占用整个CPU"></a>分析Disruptor为何会占用整个CPU</h2><p>根据上面快照的分析，实际是Disruptor的等待策略相关的线程所导致的，查看<code>BusySpinWaitStrategy</code>类，发现有相关说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* This strategy will use CPU resource to avoid syscalls which can introduce latency jitter.  It is best</span><br><span class="line">* used when threads can be bound to specific CPU cores.</span><br></pre></td></tr></table></figure></p><p>现在终于知道了，原来是因为这个策略就是让线程绑定了一个CPU核心，自然其CPU占用时间就超过100%了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这一次问题的排查，不仅了解了linux系统中进程、线程的关系，也开始着手java服务的线上排查，顺便也回顾了一下之前有过接触的Disruptor。如果大家有什么建议或者意见，欢迎在下方留言</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了一下部署游戏后台的服务器状况，发现我的一个Java程序其占用的CPU时长超过100%，排查后发现竟是Disruptor引起的，让我们来看看究竟为什么Disruptor会有这样的表现。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Disruptor" scheme="http://yoursite.com/tags/Disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Java服务器获取客户端的真实IP</title>
    <link href="http://yoursite.com/2018/11/12/Java%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%9C%9F%E5%AE%9EIP/"/>
    <id>http://yoursite.com/2018/11/12/Java服务器获取客户端的真实IP/</id>
    <published>2018-11-12T02:20:41.000Z</published>
    <updated>2018-11-12T03:16:26.676Z</updated>
    
    <content type="html"><![CDATA[<p>在进行一些小游戏开发时，我们经常比较关注的一个功能便是分享。针对分享，我们希望能根据各个城市或者地区，能有不同的分享文案，辨识地区的功能如果由服务器来完成的话，我们就需要知道客户端的真实IP。今天我们就来看看服务器是如何获取到客户端的真实IP的。<br><a id="more"></a></p><h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>首先，一个请求肯定是可以分为请求头和请求体的，而我们客户端的IP地址信息一般都是存储在请求头里的。如果你的服务器有用Nginx做负载均衡的话，你需要在你的location里面配置<code>X-Real-IP</code>和<code>X-Forwarded-For</code>请求头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /your-service/ &#123;</span><br><span class="line">        proxy_set_header        X-Real-IP       $remote_addr;</span><br><span class="line">        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http://localhost:60000/your-service/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="X-Real-IP"><a href="#X-Real-IP" class="headerlink" title="X-Real-IP"></a>X-Real-IP</h3><p>在《实战nginx》中，有这么一句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">经过反向代理后，由于在客户端和web服务器之间增加了中间层，因此web服务器无法直接拿到客户端的ip，通过$remote_addr变量拿到的将是反向代理服务器的ip地址。</span><br></pre></td></tr></table></figure></p><p>这句话的意思是说，当你使用了nginx反向服务器后，在web端使用<code>request.getRemoteAddr()</code>（本质上就是获取<code>$remote_addr</code>），取得的是nginx的地址，即<code>$remote_addr</code>变量中封装的是nginx的地址，当然是没法获得用户的真实ip的。但是，nginx是可以获得用户的真实ip的，也就是说nginx使用<code>$remote_addr</code>变量时获得的是用户的真实ip，如果我们想要在web端获得用户的真实ip，就必须在nginx里作一个赋值操作，即我在上面的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header        X-Real-IP       $remote_addr;</span><br></pre></td></tr></table></figure></p><h3 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h3><p><code>X-Forwarded-For</code>变量，这是一个squid开发的，用于识别通过HTTP代理或负载平衡器原始IP一个连接到Web服务器的客户机地址的非rfc标准，如果有做<code>X-Forwarded-For</code>设置的话,每次经过proxy转发都会有记录,格式就是<code>client1,proxy1,proxy2</code>以逗号隔开各个地址，由于它是非rfc标准，所以默认是没有的，需要强制添加。在默认情况下经过proxy转发的请求，在后端看来远程地址都是proxy端的ip 。也就是说在默认情况下我们使用<code>request.getAttribute(&quot;X-Forwarded-For&quot;)</code>获取不到用户的ip，如果我们想要通过这个变量获得用户的ip，我们需要自己在nginx添加配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br></pre></td></tr></table></figure></p><p>意思是增加一个<code>$proxy_add_x_forwarded_for</code>到<code>X-Forwarded-For</code>里去，注意是增加，而不是覆盖，当然由于默认的<code>X-Forwarded-For</code>值是空的，所以我们总感觉<code>X-Forwarded-For</code>的值就等于<code>$proxy_add_x_forwarded_for</code>的值，实际上当你搭建两台nginx在不同的ip上，并且都使用了这段配置，那你会发现在web服务器端通过<code>request.getAttribute(&quot;X-Forwarded-For&quot;)</code>获得的将会是客户端ip和第一台nginx的ip。</p><p>那么<code>$proxy_add_x_forwarded_for</code>又是什么？</p><p><code>$proxy_add_x_forwarded_for</code>变量包含客户端请求头中的<code>X-Forwarded-For</code>与<code>$remote_addr</code>两部分，他们之间用逗号分开。</p><p>举个例子，有一个web应用，在它之前通过了两个nginx转发，<code>www.linuxidc.com</code>即用户访问该web通过两台nginx。</p><p>在第一台nginx中,使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header            X-Forwarded-For $proxy_add_x_forwarded_for;</span><br></pre></td></tr></table></figure><p>现在的<code>$proxy_add_x_forwarded_for</code>变量的<code>X-Forwarded-For</code>部分是空的，所以只有<code>$remote_addr</code>，而<code>$remote_addr</code>的值是用户的ip，于是赋值以后，<code>X-Forwarded-For</code>变量的值就是用户的真实的ip地址了。</p><p>到了第二台nginx，使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header            X-Forwarded-For $proxy_add_x_forwarded_for;</span><br></pre></td></tr></table></figure></p><p>现在的<code>$proxy_add_x_forwarded_for</code>变量，<code>X-Forwarded-For</code>部分包含的是用户的真实ip，<code>$remote_addr</code>部分的值是上一台nginx的ip地址，于是通过这个赋值以后现在的<code>X-Forwarded-For</code>的值就变成了“用户的真实ip，第一台nginx的ip”，这样就清楚了吧。</p><h2 id="服务器获取真实IP"><a href="#服务器获取真实IP" class="headerlink" title="服务器获取真实IP"></a>服务器获取真实IP</h2><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpAddress</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">  String Xip = request.getHeader(<span class="string">"X-Real-IP"</span>);</span><br><span class="line">  String XFor = request.getHeader(<span class="string">"X-Forwarded-For"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!Strings.isNullOrEmpty(XFor) &amp;&amp; !<span class="string">"unKnown"</span>.equalsIgnoreCase(XFor)) &#123;</span><br><span class="line">    <span class="comment">//多次反向代理后会有多个ip值，第一个ip才是真实ip</span></span><br><span class="line">    <span class="keyword">int</span> index = XFor.indexOf(<span class="string">","</span>);</span><br><span class="line">    <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> XFor.substring(<span class="number">0</span>, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> XFor;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  XFor = Xip;</span><br><span class="line">  <span class="keyword">if</span> (!Strings.isNullOrEmpty(XFor) &amp;&amp; !<span class="string">"unKnown"</span>.equalsIgnoreCase(XFor)) &#123;</span><br><span class="line">    <span class="keyword">return</span> XFor;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Strings.nullToEmpty(XFor).trim().isEmpty() || <span class="string">"unknown"</span>.equalsIgnoreCase(XFor)) &#123;</span><br><span class="line">    XFor = request.getHeader(<span class="string">"Proxy-Client-IP"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Strings.nullToEmpty(XFor).trim().isEmpty() || <span class="string">"unknown"</span>.equalsIgnoreCase(XFor)) &#123;</span><br><span class="line">    XFor = request.getHeader(<span class="string">"WL-Proxy-Client-IP"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Strings.nullToEmpty(XFor).trim().isEmpty() || <span class="string">"unknown"</span>.equalsIgnoreCase(XFor)) &#123;</span><br><span class="line">    XFor = request.getHeader(<span class="string">"HTTP_CLIENT_IP"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Strings.nullToEmpty(XFor).trim().isEmpty() || <span class="string">"unknown"</span>.equalsIgnoreCase(XFor)) &#123;</span><br><span class="line">    XFor = request.getHeader(<span class="string">"HTTP_X_FORWARDED_FOR"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Strings.nullToEmpty(XFor).trim().isEmpty() || <span class="string">"unknown"</span>.equalsIgnoreCase(XFor)) &#123;</span><br><span class="line">    XFor = request.getRemoteAddr();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> XFor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看各个请求头的含义</p><h3 id="X-Real-IP-1"><a href="#X-Real-IP-1" class="headerlink" title="X-Real-IP"></a>X-Real-IP</h3><p>nginx代理一般会加上此请求头。</p><h3 id="X-FORWARDED-FOR"><a href="#X-FORWARDED-FOR" class="headerlink" title="X-FORWARDED-FOR"></a>X-FORWARDED-FOR</h3><p>这是一个<code>Squid</code>开发的字段，只有在通过了HTTP代理或者负载均衡服务器时才会添加该项。</p><h3 id="Proxy-Client-IP-和-WL-Proxy-Client-IP"><a href="#Proxy-Client-IP-和-WL-Proxy-Client-IP" class="headerlink" title="Proxy-Client-IP 和 WL-Proxy-Client-IP"></a>Proxy-Client-IP 和 WL-Proxy-Client-IP</h3><p>这个一般是经过apache http服务器的请求才会有，用apache http做代理时一般会加上<code>Proxy-Client-IP</code>请求头，而<code>WL-Proxy-Client-IP</code>是它的weblogic插件加上的头。</p><h3 id="HTTP-CLIENT-IP"><a href="#HTTP-CLIENT-IP" class="headerlink" title="HTTP_CLIENT_IP"></a>HTTP_CLIENT_IP</h3><p>有些代理服务器会加上此请求头。在网上搜了一下，有一个说法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这是普通的 http header，伪造起来很容易，不要轻易信任用户输入。 </span><br><span class="line"></span><br><span class="line">curl -H &apos;client-ip: 8.8.8.8&apos; lidian.club/phpinfo.php | grep _SERVER </span><br><span class="line">你就能看到 _SERVER[&quot;HTTP_CLIENT_IP&quot;] 了。 </span><br><span class="line"></span><br><span class="line">client-ip 和 client-host 是在 NAPT 还没普及的年代，企业内网假设的 http 透明代理，传给服务器的 header，只有极少数厂家用过，从来不是标准，也从来没成为过事实标准。 </span><br><span class="line">（大家最熟悉的事实标准就是 x-forwarded-for） </span><br><span class="line"></span><br><span class="line">后来出现的 web proxy 也没见用过这个 header。 </span><br><span class="line"></span><br><span class="line">TCP/IP Illustrated Vol 3 没有讲过这个 header，网上的传言不可信。 </span><br><span class="line">可考的最早痕迹出现在2005年，日本一部 Perl/CGI 秘籍（9784798010779，270页）通过 client-ip 与 via 两个 header 屏蔽代理用户访问。</span><br></pre></td></tr></table></figure></p><h3 id="HTTP-X-FORWARDED-FOR"><a href="#HTTP-X-FORWARDED-FOR" class="headerlink" title="HTTP_X_FORWARDED_FOR"></a>HTTP_X_FORWARDED_FOR</h3><p>简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理(比如APACHE代理)或者负载均衡服务器时才会添加该项。它不是RFC中定义的标准请求头信息，在squid缓存代理服务器开发文档中可以找到该项的详细介绍。如果有该条信息, 说明您使用了代理服务器，地址就是后面的数值。可以伪造。标准格式如下：X-Forwarded-For: client1, proxy1, proxy2</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我在处理客户端真实IP的方法，如果你有什么意见或者建议，可以在下方留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行一些小游戏开发时，我们经常比较关注的一个功能便是分享。针对分享，我们希望能根据各个城市或者地区，能有不同的分享文案，辨识地区的功能如果由服务器来完成的话，我们就需要知道客户端的真实IP。今天我们就来看看服务器是如何获取到客户端的真实IP的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>java中List的sort源码解读</title>
    <link href="http://yoursite.com/2018/11/02/java%E4%B8%ADList%E7%9A%84sort%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/11/02/java中List的sort源码解读/</id>
    <published>2018-11-02T01:36:03.000Z</published>
    <updated>2018-11-10T07:22:14.432Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一些排序相关的文章，因此比较好奇，Java中的排序是如何做的。本片文章介绍的是JDK1.8，List中的sort方法。<br><a id="more"></a></p><p>先来看看List中的sort是怎么写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先，你需要传入一个比较器作为参数，这个好理解，毕竟你肯定要定一个比较标准。然后就是将list转换成一个数组，再对这个数组进行排序，排序完之后，再利用iterator重新改变list。</p><p>接着，我们再来看看Arrays.sort：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LegacyMergeSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> userRequested =</span><br><span class="line">        java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> sun.security.action.GetBooleanAction(</span><br><span class="line">                <span class="string">"java.util.Arrays.useLegacyMergeSort"</span>)).booleanValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样可以看出，其实排序的核心就是TimSort，LegacyMergeSort大致意思是表明如果版本很旧的话，就用这个，新版本是不会采用这种排序方式的。</p><p>我们再来看看TimSort的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_MERGE = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator&lt;? <span class="keyword">super</span> T&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">                     T[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> c != <span class="keyword">null</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">    <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If array is small, do a "mini-TimSort" with no merges</span></span><br><span class="line">    <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">        <span class="comment">// 获得最长的递增序列</span></span><br><span class="line">        <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">        binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * March over the array once, left to right, finding natural runs,</span></span><br><span class="line"><span class="comment">     * extending short natural runs to minRun elements, and merging runs</span></span><br><span class="line"><span class="comment">     * to maintain stack invariant.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TimSort&lt;T&gt; ts = <span class="keyword">new</span> TimSort&lt;&gt;(a, c, work, workBase, workLen);</span><br><span class="line">    <span class="keyword">int</span> minRun = minRunLength(nRemaining);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Identify next run</span></span><br><span class="line">        <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If run is short, extend to min(minRun, nRemaining)</span></span><br><span class="line">        <span class="keyword">if</span> (runLen &lt; minRun) &#123;</span><br><span class="line">            <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">            binarySort(a, lo, lo + force, lo + runLen, c);</span><br><span class="line">            runLen = force;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Push run onto pending-run stack, and maybe merge</span></span><br><span class="line">        ts.pushRun(lo, runLen);</span><br><span class="line">        ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Advance to find next run</span></span><br><span class="line">        lo += runLen;</span><br><span class="line">        nRemaining -= runLen;</span><br><span class="line">    &#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge all remaining runs to complete sort</span></span><br><span class="line">    <span class="keyword">assert</span> lo == hi;</span><br><span class="line">    ts.mergeForceCollapse();</span><br><span class="line">    <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果小于2个，代表不再不需要排序；如果小于32个，则采用优化的二分排序。怎么优化的呢？首先获得最长的递增序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">    <span class="keyword">int</span> runHi = lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (runHi == hi)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find end of run, and reverse range if descending</span></span><br><span class="line">    <span class="keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="number">0</span>) &#123; <span class="comment">// Descending</span></span><br><span class="line">        <span class="comment">// 一开始是递减序列，就找出最长递减序列的最后一个下标</span></span><br><span class="line">        <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">            runHi++;</span><br><span class="line">        <span class="comment">// 逆转前面的递减序列</span></span><br><span class="line">        reverseRange(a, lo, runHi);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// Ascending</span></span><br><span class="line">        <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">            runHi++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> runHi - lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着进行二分排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> start,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> lo &lt;= start &amp;&amp; start &lt;= hi;</span><br><span class="line">    <span class="keyword">if</span> (start == lo)</span><br><span class="line">        start++;</span><br><span class="line">    <span class="keyword">for</span> ( ; start &lt; hi; start++) &#123;</span><br><span class="line">        T pivot = a[start];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set left (and right) to the index where a[start] (pivot) belongs</span></span><br><span class="line">        <span class="keyword">int</span> left = lo;</span><br><span class="line">        <span class="keyword">int</span> right = start;</span><br><span class="line">        <span class="keyword">assert</span> left &lt;= right;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invariants:</span></span><br><span class="line"><span class="comment">         *   pivot &gt;= all in [lo, left).</span></span><br><span class="line"><span class="comment">         *   pivot &lt;  all in [right, start).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// start位置是递增序列后的第一个数的位置</span></span><br><span class="line">        <span class="comment">// 从前面的递增序列中找出start位置的数应该处于的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; 无符号右移</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (c.compare(pivot, a[mid]) &lt; <span class="number">0</span>)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> left == right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The invariants still hold: pivot &gt;= all in [lo, left) and</span></span><br><span class="line"><span class="comment">         * pivot &lt; all in [left, start), so pivot belongs at left.  Note</span></span><br><span class="line"><span class="comment">         * that if there are elements equal to pivot, left points to the</span></span><br><span class="line"><span class="comment">         * first slot after them -- that's why this sort is stable.</span></span><br><span class="line"><span class="comment">         * Slide elements over to make room for pivot.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> n = start - left;  <span class="comment">// The number of elements to move</span></span><br><span class="line">        <span class="comment">// Switch is just an optimization for arraycopy in default case</span></span><br><span class="line">        <span class="comment">// 比pivot大的数往后移动一位</span></span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:  a[left + <span class="number">2</span>] = a[left + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:  a[left + <span class="number">1</span>] = a[left];</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: System.arraycopy(a, left, a, left + <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = pivot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，待排序数量小于32个的讲完了，现在来说说大于等于32个情况。首先，获得一个叫<code>minRun</code>的东西，这是个啥含义呢：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> minRun = minRunLength(nRemaining);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minRunLength</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> n &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;      <span class="comment">// Becomes 1 if any 1 bits are shifted off</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt;= MIN_MERGE) &#123;</span><br><span class="line">        <span class="comment">// 这里我没搞懂的是为什么不直接将(n &amp; 1)赋值给r，而要做一次逻辑或。</span></span><br><span class="line">        r |= (n &amp; <span class="number">1</span>);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>各种位运算符，MIN_MERGE默认为32，如果n小于此值，那么返回n本身。否则会将n不断地右移，直到小于MIN_MERGE，同时记录一个r值，r代表最后一次移位n时，n最低位是0还是1。<br>其实看注释比较容易理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Returns the minimum acceptable run length for an array of the specified length. Natural runs shorter than this will be extended with binarySort.</span><br><span class="line">Roughly speaking, the computation is: If n &lt; MIN_MERGE, return n (it&apos;s too small to bother with fancy stuff).</span><br><span class="line">Else if n is an exact power of 2, return MIN_MERGE/2.</span><br><span class="line">Else return an int k, MIN_MERGE/2 &lt;= k &lt;= MIN_MERGE, such that n/k is close to, but strictly less than, an exact power of 2. For the rationale, see listsort.txt.</span><br></pre></td></tr></table></figure><p>返回结果其实就是用于接下来的合并排序中。</p><p>接下来就是一个while循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// Identify next run</span></span><br><span class="line">    <span class="comment">// 获得一个最长递增序列</span></span><br><span class="line">    <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If run is short, extend to min(minRun, nRemaining)</span></span><br><span class="line">    <span class="comment">// 如果最长递增序列</span></span><br><span class="line">    <span class="keyword">if</span> (runLen &lt; minRun) &#123;</span><br><span class="line">        <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">        binarySort(a, lo, lo + force, lo + runLen, c);</span><br><span class="line">        runLen = force;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push run onto pending-run stack, and maybe merge</span></span><br><span class="line">    <span class="comment">// lo——runLen为将要被归并的范围</span></span><br><span class="line">    ts.pushRun(lo, runLen);</span><br><span class="line">    <span class="comment">// 归并</span></span><br><span class="line">    ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advance to find next run</span></span><br><span class="line">    lo += runLen;</span><br><span class="line">    nRemaining -= runLen;</span><br><span class="line">&#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>这样，假设你的每次归并排序的两个序列为r1和r2，r1肯定是有序的，r2也已经被排成递增序列了，因此这样的归并排序就比较特殊了。</p><p>为什么要用归并排序呢，因为归并排序的时间复杂度永远为O(nlogn)，空间复杂度为O(n)，以空间换取时间。</p><p>好了，以上就是针对Java中的排序做的一次总结，但具体的归并代码还没有分析，其实我自己也没有完全研究透，为什么<code>minRun</code>的取值是这样的，这也和TimSort中的stackLen有关，有兴趣的小伙伴可以在下方留言，我们可以一起探讨。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了一些排序相关的文章，因此比较好奇，Java中的排序是如何做的。本片文章介绍的是JDK1.8，List中的sort方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>DDL-脏数据层的实现</title>
    <link href="http://yoursite.com/2018/10/31/DDL-%E8%84%8F%E6%95%B0%E6%8D%AE%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/10/31/DDL-脏数据层的实现/</id>
    <published>2018-10-31T10:10:46.000Z</published>
    <updated>2019-02-20T06:33:16.830Z</updated>
    
    <content type="html"><![CDATA[<p>在我们的项目中，经常会有一些数据会涉及到频繁更改。如果每次都从数据库中读取再修改，这样不仅浪费时间，而且还更加危险。那此时我们究竟该如何解决这个问题呢？此时，DDL(脏数据层)就出现了。<br><a id="more"></a></p><p>首先说一下为什么操作不能保证原子性就会危险，因为这时就很有可能出现同时修改的情况，最终的结果极有可能并不是你所希望的（除非这些操作都是幂等性，但这种情况应该比较少）。如果是利用数据库中的锁，一来我在项目中用的比较少，二来也增加了维护难度。当然，有人说可以利用CAS，那针对一些复杂的情况（比如类里面属性的修改会有一些相关性，你的一次更改需要涉及几个属性等），可能你还是需要单独设计一套系统，而且还会有经典的ABA问题。如果你是利用CAS解决的，希望能够在下方评论区告知，就当互相学习。</p><p>那现在来说说DDL层具体是什么。<strong>DDL全称是Dirty Data Layer，即脏数据层。</strong>针对那些在系统运行经常会更改的domain类，我们将其再做一次封装，组成一个类似map的形式。单独由一组线程来管理这些map，每当有数据改动时，我们就往这个map中添加内容，而我们的线程则定期向数据库中写入内容。这样做的好处，首先是让你的每一次操作都没有IO的参与，提高了相应速度，而且定时提交意味着你可以把原本的几次提交变成为1次，减少了和数据库的交互。当然，缺点也是存在的，如果你的系统是分布式，那么你的这个DDL层的实现可能就没有那么方便，因为这些数据你可能需要存储在类似Redis这种共享缓存中，因此每次的拿和取就需要封装一下（这个应该算是小问题，因为原本就算你用的是本地缓存，所有操作依旧是需要封装的，只不过你的IO消耗由原本的数据库变成了共享缓存）。接下来，我就针对本地缓存的情况来具体实现一个DDL。</p><h2 id="定义操作"><a href="#定义操作" class="headerlink" title="定义操作"></a>定义操作</h2><p>这是我定义出的一些操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDirtyEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//region manage content</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取entity的内容。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取entity的内容。 获取的内容是复制的对象，属性值是调用该方法时的属性值。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">copyContent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region persisting flag</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否正在进行持久化</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isPersisting</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置正在持久化标志</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setPersistingFlag</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清除正在持久化标志</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearPersistingFlag</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region persist state</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置为脏数据状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setDirtyState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清除脏数据状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearDirtyState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前持久化状态。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> PersistState</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">PersistState <span class="title">currentPersistState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region get/set field</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取属性值。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">getField</span><span class="params">(String fieldName)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置属性值。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setField</span><span class="params">(String fieldName, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置多个属性的值。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setFields</span><span class="params">(List&lt;EntityField&gt; fields)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 增加int类型属性的值。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addInt</span><span class="params">(String fieldName, <span class="keyword">int</span> delta)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 增加long类型属性的值。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addLong</span><span class="params">(String fieldName, <span class="keyword">long</span> delta)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region manage dirty field</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 标记脏数据字段</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addDirtyField</span><span class="params">(String fieldName)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取修改过的属性。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">List&lt;EntityField&gt; <span class="title">getAndClearDirtyFields</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region wrapper implement</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回id的属性名。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getIdFieldName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回id</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回DATA的class</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Class <span class="title">getDataClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>DDL解决的是数据频繁更改的问题，其实这里的更改说的并不准确，并不仅仅只是update，还有insert。用过mongodb的应该清楚有一种叫upsert的操作，就是找到就修改，找不到就添加。我们这里就需要将我们的数据分成两类：<strong>Detachable(可拆分的)、Nondetachable(不可拆分的)</strong>。</p><p><code>可拆分的，就意味着你针对这个数据的修改最小可以精确到其中的一个属性，项目中大多数都属于这种情况。</code></p><p><code>不可拆分的，即每次都是以一个整体添加，比如一次交易，每次添加都是一个整体，不可能说你先提交买方，再提交卖方，后面还会修改买方。这种类型大多都是一条记录，整体存入数据库。</code></p><p>因此，我们来定义一下这两种结构：<br>可拆分的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Strings;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.beans.BeanCopier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.beans.BeanMap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DetachableDirtyEntityAdapter</span> <span class="keyword">implements</span> <span class="title">IDirtyEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DetachableDirtyEntityAdapter.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据属性的map引用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> BeanMap beanMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanCopier beanCopier;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DetachableDirtyEntityAdapter</span><span class="params">(Object content, BeanCopier beanCopier)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(content);</span><br><span class="line">    Preconditions.checkNotNull(beanCopier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.content = newEmptyContentInstance();</span><br><span class="line">    <span class="keyword">this</span>.beanCopier = beanCopier;</span><br><span class="line">    <span class="keyword">this</span>.beanCopier.copy(content, <span class="keyword">this</span>.content, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.beanMap = BeanMap.create(<span class="keyword">this</span>.content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//region manage content</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据的内容。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Object content;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">newEmptyContentInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class cls = getDataClass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cls.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">"initiate &#123;&#125; failed: &#123;&#125;"</span>, cls.getSimpleName(), e.getMessage());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">copyContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object copy = newEmptyContentInstance();</span><br><span class="line">    beanCopier.copy(<span class="keyword">this</span>.content, copy, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region persisting flag</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> persisting = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPersisting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> persisting;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersistingFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.persisting = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearPersistingFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.persisting = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region persist state</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDirtyState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearDirtyState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> PersistState <span class="title">currentPersistState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dirtySize = dirtyFieldNames.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dirtySize == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> PersistState.PERSISTED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> PersistState.DIRTY;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region get/set field</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">getField</span><span class="params">(String fieldName)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(!Strings.isNullOrEmpty(fieldName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanMap.get(fieldName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setField</span><span class="params">(String fieldName, Object value)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(!Strings.isNullOrEmpty(fieldName));</span><br><span class="line"></span><br><span class="line">    beanMap.put(fieldName, value);</span><br><span class="line">    dirtyFieldNames.add(fieldName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setFields</span><span class="params">(List&lt;EntityField&gt; fields)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(fields);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EntityField f : fields) &#123;</span><br><span class="line">      beanMap.put(f.getName(), f.getValue());</span><br><span class="line">      dirtyFieldNames.add(f.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addInt</span><span class="params">(String fieldName, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(!Strings.isNullOrEmpty(fieldName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> origin = (<span class="keyword">int</span>) beanMap.get(fieldName);</span><br><span class="line">    beanMap.put(fieldName, origin + delta);</span><br><span class="line">    dirtyFieldNames.add(fieldName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addLong</span><span class="params">(String fieldName, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(!Strings.isNullOrEmpty(fieldName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> origin = (<span class="keyword">long</span>) beanMap.get(fieldName);</span><br><span class="line">    beanMap.put(fieldName, origin + delta);</span><br><span class="line">    dirtyFieldNames.add(fieldName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region manage dirty fields</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前entity的包含脏数据的属性名列表。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;String&gt; dirtyFieldNames = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDirtyField</span><span class="params">(String fieldName)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(!Strings.isNullOrEmpty(fieldName));</span><br><span class="line">    dirtyFieldNames.add(fieldName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;EntityField&gt; <span class="title">getAndClearDirtyFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;EntityField&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String f : dirtyFieldNames) &#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> EntityField(f, beanMap.get(f)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空dirtyFieldNames, 记录上一次持久化的事件</span></span><br><span class="line">    dirtyFieldNames.clear();</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不可拆分的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Strings;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.beans.BeanCopier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.beans.BeanMap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NonDetachableDirtyEntityAdapter</span> <span class="keyword">implements</span> <span class="title">IDirtyEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(NonDetachableDirtyEntityAdapter.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据属性的map引用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> BeanMap beanMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanCopier beanCopier;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NonDetachableDirtyEntityAdapter</span><span class="params">(Object content, BeanCopier beanCopier)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(content);</span><br><span class="line">    Preconditions.checkNotNull(beanCopier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.content = newEmptyContentInstance();</span><br><span class="line">    <span class="keyword">this</span>.beanCopier = beanCopier;</span><br><span class="line">    <span class="keyword">this</span>.beanCopier.copy(content, <span class="keyword">this</span>.content, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.beanMap = BeanMap.create(<span class="keyword">this</span>.content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//region manage content</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据的内容。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Object content;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">newEmptyContentInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class cls = getDataClass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cls.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">"initiate &#123;&#125; failed: &#123;&#125;"</span>, cls.getSimpleName(), e.getMessage());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">copyContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object copy = newEmptyContentInstance();</span><br><span class="line">    beanCopier.copy(<span class="keyword">this</span>.content, copy, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region persisting flag</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> persisting = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPersisting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> persisting;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersistingFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.persisting = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearPersistingFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.persisting = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region persist state</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> PersistState persistState = PersistState.DIRTY;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDirtyState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    persistState = PersistState.DIRTY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearDirtyState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    persistState = PersistState.PERSISTED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PersistState <span class="title">currentPersistState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> persistState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region get/set field</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">getField</span><span class="params">(String fieldName)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(!Strings.isNullOrEmpty(fieldName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanMap.get(fieldName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setField</span><span class="params">(String fieldName, Object value)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(!Strings.isNullOrEmpty(fieldName));</span><br><span class="line"></span><br><span class="line">    beanMap.put(fieldName, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setFields</span><span class="params">(List&lt;EntityField&gt; fields)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(fields);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EntityField f : fields) &#123;</span><br><span class="line">      beanMap.put(f.getName(), f.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addInt</span><span class="params">(String fieldName, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(!Strings.isNullOrEmpty(fieldName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> origin = (<span class="keyword">int</span>) beanMap.get(fieldName);</span><br><span class="line">    beanMap.put(fieldName, origin + delta);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addLong</span><span class="params">(String fieldName, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(!Strings.isNullOrEmpty(fieldName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> origin = (<span class="keyword">long</span>) beanMap.get(fieldName);</span><br><span class="line">    beanMap.put(fieldName, origin + delta);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//region manage dirty fields</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDirtyField</span><span class="params">(String fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;EntityField&gt; <span class="title">getAndClearDirtyFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//endregion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两种类型最大的不同在于真正往数据库中存储时，前者是可以单独字段存储，后者是整体存储，因此最后和DirtyField相关的操作便需要注意，NondetachableDirtyEntityAdapter不需要记录DirtyFields。</p><p>针对原本类中属性的复制和存储，我这儿用的是spring提供的BeanCopier，如果你有什么更高效的工具，欢迎在下方留言。（我一直在找一种深度克隆高效的组件，试过kryo，但只有在实现序列化接口的前提下，其效率才能和正常的set/get大概相差10倍，如果有好的组件，希望一并告知）。</p><p>以上就是DDL的准备工作，其实后面的工作就是将具体的类做一个封装，再封装针对该类的所有操作，然后另写一个线程组执行往数据库的写入操作。这个工作其实针对各个项目都有其特殊的地方，LZ在这儿就不具体展示了，有兴趣的话大家可以在下方留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们的项目中，经常会有一些数据会涉及到频繁更改。如果每次都从数据库中读取再修改，这样不仅浪费时间，而且还更加危险。那此时我们究竟该如何解决这个问题呢？此时，DDL(脏数据层)就出现了。&lt;br&gt;
    
    </summary>
    
      <category term="DDL" scheme="http://yoursite.com/categories/DDL/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>log4j日志不输出的问题</title>
    <link href="http://yoursite.com/2018/10/24/log4j%E6%97%A5%E5%BF%97%E4%B8%8D%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/10/24/log4j日志不输出的问题/</id>
    <published>2018-10-24T09:03:10.000Z</published>
    <updated>2018-10-25T00:56:03.550Z</updated>
    
    <content type="html"><![CDATA[<p>今天服务器上报错，想先去看一下日志进行排查，结果发现日志很久都没有输出过了。从上午排查到下午，刚刚解决，因此记录一下，但现在也只是知其然，并不知其所以然，所以如果大家有什么想法请在下方评论。<br><a id="more"></a></p><p>先说一下环境，服务器是linux，项目是运行在tomcat下的Spring项目，日志用的是log4j。</p><p>首先，从10月13号开始便没有新的日志文件了。假设日志名为log.txt（如果你设置了DailyRollingFileAppender，那么你当天的日志文件就是log.txt），先备份该文件到其他目录下，然后删除该文件，重新启动tomcat。这是为了确认你的log4j配置是否有问题，因为这是最容易出错的地方。很遗憾，我不是这里出的问题，因为项目重启后，日志文件又重新生成了，但很奇怪的是，<strong>日志文件是空的</strong>，其大小为0.</p><p>感觉自己碰上了很神奇的问题，因此我在自己的本地进行调试，启动项目后发现，正常的项目启动日志是有的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15:13:48:0253  INFO [RMI TCP Connection(3)-127.0.0.1] -Root WebApplicationContext: initialization completed in 18479 ms</span><br></pre></td></tr></table></figure></p><p>但我自己的一些日志输出是不显示的，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(MyDomain.class);</span><br><span class="line">log.info(<span class="string">"show info log"</span>);</span><br></pre></td></tr></table></figure></p><p><code>show info log</code>这句话就不打印，现在证明，我的日志配置没有问题，服务器也找到了我的日志文件，但应该是我自己的Logger是不对应正确的日志输出的，因为我的console(控制台)有显示。</p><p>接下来，我就是开始看源码了。先是<code>LoggerFactory.getLogger(Class&lt;?&gt; clazz)</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    Logger logger = getLogger(clazz.getName());</span><br><span class="line">    <span class="keyword">if</span> (DETECT_LOGGER_NAME_MISMATCH) &#123;</span><br><span class="line">        Class&lt;?&gt; autoComputedCallingClass = Util.getCallingClass();</span><br><span class="line">        <span class="keyword">if</span> (autoComputedCallingClass != <span class="keyword">null</span> &amp;&amp; nonMatchingClasses(clazz, autoComputedCallingClass)) &#123;</span><br><span class="line">            Util.report(String.format(<span class="string">"Detected logger name mismatch. Given name: \"%s\"; computed name: \"%s\"."</span>, logger.getName(),</span><br><span class="line">                            autoComputedCallingClass.getName()));</span><br><span class="line">            Util.report(<span class="string">"See "</span> + LOGGER_NAME_MISMATCH_URL + <span class="string">" for an explanation"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好吧，没什么用，看不出我的<code>logger</code>变成了，继续看<code>getLogger(String name)</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ILoggerFactory iLoggerFactory = getILoggerFactory();</span><br><span class="line">    <span class="keyword">return</span> iLoggerFactory.getLogger(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时我在<code>return iLoggerFactory.getLogger(name);</code>这行打了断点，我看到了这样的东西：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/menu.saveimg.savepath20181024172508.jpg?raw=true" alt="iLoggerFactory是logback中的实现"></p><p>为什么我的iLoggerFactory是用的logback中的实现？其实也是怪我自己大意，我其实依赖了一个基于Spring Boot的项目(虽然我只是用了里面的一些domain类，但因为设计不当，还没有把这些domain类单独提成一个_项目)，而Spring Boot中一般默认就依赖的logback。通过gradle查看项目的依赖树，也证实了我的这一猜想(./gradlew 子项目名称:dependencies):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|    +--- org.springframework.boot:spring-boot-starter-web:2.0.2.RELEASE</span><br><span class="line">|    |    +--- org.springframework.boot:spring-boot-starter:2.0.2.RELEASE</span><br><span class="line">|    |    |    +--- org.springframework.boot:spring-boot:2.0.2.RELEASE</span><br><span class="line">|    |    |    |    +--- org.springframework:spring-core:5.0.6.RELEASE (*)</span><br><span class="line">|    |    |    |    \--- org.springframework:spring-context:5.0.6.RELEASE (*)</span><br><span class="line">|    |    |    +--- org.springframework.boot:spring-boot-autoconfigure:2.0.2.RELEASE</span><br><span class="line">|    |    |    |    \--- org.springframework.boot:spring-boot:2.0.2.RELEASE (*)</span><br><span class="line">|    |    |    +--- org.springframework.boot:spring-boot-starter-logging:2.0.2.RELEASE</span><br><span class="line">|    |    |    |    +--- ch.qos.logback:logback-classic:1.2.3</span><br><span class="line">|    |    |    |    |    +--- ch.qos.logback:logback-core:1.2.3</span><br><span class="line">|    |    |    |    |    \--- org.slf4j:slf4j-api:1.7.25</span><br></pre></td></tr></table></figure></p><p>接下来就好办了，你排除掉<code>ch.qos.logback</code>的依赖就可以了，在你的<code>build.gradle</code>中增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    compile.exclude group: &apos;ch.qos.logback&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候你再重新调试一下看看：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/menu.saveimg.savepath20181024182956.jpg?raw=true" alt="iLoggerFactory是log4j中的实现"></p><p>完美，现在是log4j中的实现，得到了我想要的操作。当然了，既然我知道之前项目中的slf4j是logback实现了，那么我自然也可以换成logback的配置，但这就需要我将项目换成用Spring Boot启动，这个改动有点大，如果以后有必要的话，我再将这个exclude删除，换成Spring Boot的形式。</p><p>这次Spring Boot帮我们默认启用的是logback，那么有没有什么简单方法可以知道呢？如果你的项目出现了以下的日志输出，说明你的项目当前有不止一个SLF4J的实现组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/project.war/WEB-INF/lib/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/project.war/WEB-INF/lib/slf4j-log4j12-1.7.21.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder]</span><br></pre></td></tr></table></figure></p><p>因为在<code>org.slf4j.LoggerFactory</code>的<code>bind</code>方法中有关于这方面的输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// skip check under android, see also</span></span><br><span class="line">        <span class="comment">// http://jira.qos.ch/browse/SLF4J-328</span></span><br><span class="line">        <span class="keyword">if</span> (!isAndroid()) &#123;</span><br><span class="line">            <span class="comment">// 查找你的当前项目有几个slf4j的实现</span></span><br><span class="line">            staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();</span><br><span class="line">            <span class="comment">// 如果多余一个就打印</span></span><br><span class="line">            reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the next line does the binding</span></span><br><span class="line">        <span class="comment">// 这个是具体选了哪一个实现（重点关注）</span></span><br><span class="line">        StaticLoggerBinder.getSingleton();</span><br><span class="line">        INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</span><br><span class="line">        reportActualBinding(staticLoggerBinderPathSet);</span><br><span class="line">        fixSubstituteLoggers();</span><br><span class="line">        replayEvents();</span><br><span class="line">        <span class="comment">// release all resources in SUBST_FACTORY</span></span><br><span class="line">        SUBST_FACTORY.clear();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</span><br><span class="line">        String msg = ncde.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123;</span><br><span class="line">            INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;</span><br><span class="line">            Util.report(<span class="string">"Failed to load class \"org.slf4j.impl.StaticLoggerBinder\"."</span>);</span><br><span class="line">            Util.report(<span class="string">"Defaulting to no-operation (NOP) logger implementation"</span>);</span><br><span class="line">            Util.report(<span class="string">"See "</span> + NO_STATICLOGGERBINDER_URL + <span class="string">" for further details."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            failedBinding(ncde);</span><br><span class="line">            <span class="keyword">throw</span> ncde;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.NoSuchMethodError nsme) &#123;</span><br><span class="line">        String msg = nsme.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.contains(<span class="string">"org.slf4j.impl.StaticLoggerBinder.getSingleton()"</span>)) &#123;</span><br><span class="line">            INITIALIZATION_STATE = FAILED_INITIALIZATION;</span><br><span class="line">            Util.report(<span class="string">"slf4j-api 1.6.x (or later) is incompatible with this binding."</span>);</span><br><span class="line">            Util.report(<span class="string">"Your binding is version 1.5.5 or earlier."</span>);</span><br><span class="line">            Util.report(<span class="string">"Upgrade your binding to version 1.6.x."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> nsme;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        failedBinding(e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected initialization failure"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>特别要注意的是<code>StaticLoggerBinder.getSingleton();</code>这行代码，<code>StaticLoggerBinder</code>在<strong>logback-classic</strong>和<strong>slf4j-log4j12</strong>这两个jar包各有一个，因此，Spring boot是自动选择<strong>logback-classic</strong>（虽然我在本地运行的时候还是默认进入的<strong>slf4j-log4j12</strong>，但是会提醒我<code>Source code does not match the bytecode</code>，因此我判断依旧进的是<strong>logback-classic</strong>），所以只要把logback给exclude掉，就解决了这个问题。</p><p>现在看问题，更加关注源代码，因为这可以让我们更加快速定位问题，并且也能据此大致猜出其解决方案。希望大家能一起看看源代码，如果你有什么发现，可以在下方留言，我将和你一起讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天服务器上报错，想先去看一下日志进行排查，结果发现日志很久都没有输出过了。从上午排查到下午，刚刚解决，因此记录一下，但现在也只是知其然，并不知其所以然，所以如果大家有什么想法请在下方评论。&lt;br&gt;
    
    </summary>
    
    
      <category term="log4j" scheme="http://yoursite.com/tags/log4j/"/>
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
      <category term="logback" scheme="http://yoursite.com/tags/logback/"/>
    
  </entry>
  
  <entry>
    <title>Netty 心跳相关(1)</title>
    <link href="http://yoursite.com/2018/10/23/Netty-%E5%BF%83%E8%B7%B3%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2018/10/23/Netty-心跳相关/</id>
    <published>2018-10-23T07:49:14.000Z</published>
    <updated>2018-10-23T11:44:39.473Z</updated>
    
    <content type="html"><![CDATA[<p>无论是B/S还是C/S架构，如果你用的是长连接，那么心跳是必不可少的。Netty提供了对心跳机制的天然支持，今天结合例子特地学习了一下。<br><a id="more"></a></p><p>首先，我们来设想一下何时需要发送心跳。假设你做的是一款棋牌类小游戏，那么当玩家登陆游戏后肯定是先进入大厅，再选择一张合适的桌子正式开始游戏。此时玩家的客户端与服务器建立的这一次session（会话）应该是长久保持着，如果服务器端保存着大量的session，那么整个服务器就会越来越卡，最终整个服务都会挂掉。</p><p>为了预防这种情况，我们需要清理掉一些已经不用的或者理论上不会再用的session，比如：在手机上，如果我们在游戏中，突然接到一个电话或者退回桌面，这个时候我们的游戏客户端理论上就不会再主动向我们发送任何消息。这时候，心跳就派上用场了。</p><p><strong>心跳，是为了证明自己还活着。</strong>因此，这里的心跳，说白了就是客户端向服务器端发送一次请求，服务器端相应，这样客户端就知道了服务器端是alive(活着的)；服务器端向客户端发送一次心跳，客户端相应，这样服务器端就知道了客户端是alive。</p><p>知道了心跳的大致概念，那现在我们就需要知道Netty中是如何实现心跳，这就引出了两个类：<strong>IdleStateHandler</strong>、<strong>ChannelInboundHandlerAdapter</strong></p><h2 id="IdleStateHandler"><a href="#IdleStateHandler" class="headerlink" title="IdleStateHandler"></a>IdleStateHandler</h2><h3 id="大致作用"><a href="#大致作用" class="headerlink" title="大致作用"></a>大致作用</h3><blockquote><p>当连接的空闲时间（无论是读或者是写）太长时，都会触发IdleStateEvent事件。你可以写一个类继承ChannelInboundHandlerAdapter，重写userEventTriggered方法，来处理这类空闲事件。</p></blockquote><p>知道了其大致作用，那么接下来就看看我们到底该如何使用了。</p><p>IdleStateHandler有3个构造方法，主要针对这4个属性，分别是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> observeOutput;<span class="comment">// 是否考虑出站时较慢的情况。默认值是false（一般不考虑）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> readerIdleTimeNanos; <span class="comment">// 读事件空闲时间，0 代表禁用事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> writerIdleTimeNanos;<span class="comment">// 写事件空闲时间，0 代表禁用事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> allIdleTimeNanos; <span class="comment">//读或写空闲时间，0 代表禁用事件</span></span><br></pre></td></tr></table></figure></p><p>上面的三个时间，默认是秒，你也可以在构造的时候指定。</p><p>当你在pipeline中加入了该handler之后：</p><pre><code>pipeline.addLast(new IdleStateHandler(30, 90, 0)); // 这个代表只考虑读空闲30秒或写空闲90秒的情况</code></pre><p>则会先调用<code>handlerAdded</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isRegistered()) &#123;</span><br><span class="line">        <span class="comment">// channelActive() event has been fired already, which means this.channelActive() will</span></span><br><span class="line">        <span class="comment">// not be invoked. We have to initialize here instead.</span></span><br><span class="line">        initialize(ctx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// channelActive() event has not been fired yet.  this.channelActive() will be invoked</span></span><br><span class="line">        <span class="comment">// and initialization will occur there.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果channel正常，则调用<code>initialize</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span> state; <span class="comment">// 0 - none, 1 - initialized, 2 - destroyed</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Avoid the case where destroy() is called before scheduling timeouts.</span></span><br><span class="line">    <span class="comment">// See: https://github.com/netty/netty/issues/143</span></span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 避免重复添加</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 如果处于destoryed状态，则不需要添加</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state = <span class="number">1</span>;</span><br><span class="line">    initOutputChanged(ctx);</span><br><span class="line"></span><br><span class="line">    lastReadTime = lastWriteTime = ticksInNanos();  <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="comment">// 添加相应的定时调度任务</span></span><br><span class="line">    <span class="keyword">if</span> (readerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// readerIdleTimeNanos时间后，执行ReaderIdleTimeoutTask里面的方法</span></span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">new</span> ReaderIdleTimeoutTask(ctx),</span><br><span class="line">                readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        writerIdleTimeout = schedule(ctx, <span class="keyword">new</span> WriterIdleTimeoutTask(ctx),</span><br><span class="line">                writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        allIdleTimeout = schedule(ctx, <span class="keyword">new</span> AllIdleTimeoutTask(ctx),</span><br><span class="line">                allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ReaderIdleTimeoutTask、WriterIdleTimeoutTask、AllIdleTimeoutTask</code>均继承自类<code>AbstractIdleTask</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractIdleTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandlerContext ctx;</span><br><span class="line"></span><br><span class="line">    AbstractIdleTask(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ctx.channel().isOpen()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        run(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类需要实现的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以<code>ReaderIdleTimeoutTask</code>为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderIdleTimeoutTask</span> <span class="keyword">extends</span> <span class="title">AbstractIdleTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ReaderIdleTimeoutTask(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        <span class="keyword">super</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nextDelay = readerIdleTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (!reading) &#123; <span class="comment">// 如果不在读(channelRead时会被置为true，cahnnelReadComplete时会被置为false)</span></span><br><span class="line">            nextDelay -= ticksInNanos() - lastReadTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) &#123; <span class="comment">// 说明读空闲时间达到或超过预设时间</span></span><br><span class="line">            <span class="comment">// Reader is idle - set a new timeout and notify the callback.</span></span><br><span class="line">            readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">            <span class="comment">// firstReaderIdleEvent，是否是第一次读空闲事件(该标志位会在下一次channelRead触发时改成true，所以应该理解在一次读取完成后，这个读空闲事件是不是第一次)</span></span><br><span class="line">            <span class="keyword">boolean</span> first = firstReaderIdleEvent;</span><br><span class="line">            firstReaderIdleEvent = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 生成一个IdleStateEvent对象</span></span><br><span class="line">                IdleStateEvent event = newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line">                <span class="comment">// 找到下一个ChannelInboundHandler类（或其子类）的handler，触发其userEventTrigger(可以参考AbstractChannelHandlerContext的fireUserEventTriggered方法)</span></span><br><span class="line">                channelIdle(ctx, event);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                ctx.fireExceptionCaught(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 要么正在读，要么读空闲时间小于预设时间</span></span><br><span class="line">            <span class="comment">// Read occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class="line">            readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>schedule</code>方法可以理解为将定时调度事件放进一个队列当中（我是在<code>AbstractScheduledEventExecutor</code>里找到的<code>scheduledTaskQueue().add(task);</code>，但这里面的代码我还没看明白，有兴趣的你可以自己研究，研究完后如果有空可在下方评论）。<br><code>channelIdle(ctx, event)</code>方法时找到下一个ChannelInboundHandler类（或其子类）的handler，因此你写的继承自ChannelInboundHandler的handler，一定要添加在<code>IdleStateHandler</code>的后面，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">90</span>, <span class="number">0</span>));</span><br><span class="line">pipeline.addLast(heartbeatHandler);</span><br></pre></td></tr></table></figure></p><h2 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h2><p>它就很简单了，因为上面说了，channelIdle会调用ChannelInboundHandler的userEventTrigger，所以你只要自己写一个类继承ChannelInboundHandler，并重写它的userEventTrigger方法。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Sharable是因为我的每一个pipeline中用的都是同样的handler</span></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyHeartbeatHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> IHeartbeatFactory factory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NettyHeartbeatHandler</span><span class="params">(IHeartbeatFactory factory)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(factory);</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(evt <span class="keyword">instanceof</span> IdleStateEvent)) &#123;</span><br><span class="line">      <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123; <span class="comment">// 如果是读空闲，则关闭当前会话</span></span><br><span class="line">      ctx.close(); <span class="comment">// 此时会触发下一个ChannelOutboundHandler的close方法，你可以在自己写的handler中进行断线操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123; </span><br><span class="line">      <span class="comment">// 如果是写空闲，则向客户端发送心跳请求包，如果客户端不返回心跳相应包，则说明客户端断线，下一次就将触发读空闲事件。这也是为了向客户端证明服务器端alive</span></span><br><span class="line">      ctx.writeAndFlush(</span><br><span class="line">          <span class="keyword">new</span> BinaryWebSocketFrame(</span><br><span class="line">              Unpooled.copiedBuffer(factory.getHeartbeatRequest().toByteArray())</span><br><span class="line">          )</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，以上就是关于用Netty实现心跳的简单介绍。其中带大家重点看了服务器端应该在什么情况下发起一次心跳请求，应该是长久没有收到消息时（可能是有业务含义的消息或者是一个心跳包）。如果大家有什么想法可以在下方评论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是B/S还是C/S架构，如果你用的是长连接，那么心跳是必不可少的。Netty提供了对心跳机制的天然支持，今天结合例子特地学习了一下。&lt;br&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>gitalk Error: Validation Failed</title>
    <link href="http://yoursite.com/2018/09/30/gitalk%20Error%20Validation%20Failed/"/>
    <id>http://yoursite.com/2018/09/30/gitalk Error Validation Failed/</id>
    <published>2018-09-30T05:46:03.000Z</published>
    <updated>2018-09-30T06:46:43.228Z</updated>
    
    <content type="html"><![CDATA[<p>我现在博客的评论系统用的是gitalk，网上教程有很多，我参考的是这份<a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">教程</a>。</p><p>当我按照网上的说法搭好后，确实是可以利用issue进行评论了，但我在新发表文章时，竟然报错了：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/menu.saveimg.savepath20180930134404.jpg?raw=true" alt="Error: Validation Failed"></p><p>当时我心里一凉，难道和gitment一样，gitalk也凉了？后来上网查了一下，发现是github现在要求issue的label name不能超过50。<br>（奥，现在我才知道，原来gitalk应该是利用label进行筛选，取得当前评论所属的issus。但后来看了一下gitalk的源代码和github关于issue的api，issue的查找应该和你的number有关，而gitalk是当你没有number时就用id代替，看的有点晕。PS：本人在前端方面纯属小白）<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/menu.saveimg.savepath20180930140300.jpg?raw=true" alt="label name长度不能超过50"></p><p>好了，那就想想有什么办法可以保证名字的长度可以不超过50吧。没错，就是md5,加密过后都是32位长度，且唯一。当然了，这个也是在gitalk的<a href="https://github.com/gitalk/gitalk/issues/102" target="_blank" rel="noopener">issue</a>里查到的，接下来就来看看具体应该怎么做吧。</p><h2 id="找到js版的md5算法"><a href="#找到js版的md5算法" class="headerlink" title="找到js版的md5算法"></a>找到js版的md5算法</h2><p>首推的自然是别人已经造好的成熟的轮子，<strong><a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">JavaScript-MD5</a></strong>这个应该是可以的，亲测有效。</p><p>你只要在你的主题(比如我的就是next)下的<code>source\js\src</code>目录中创放入md5.js.min文件即可。</p><h2 id="修改gitalk-swig文件"><a href="#修改gitalk-swig文件" class="headerlink" title="修改gitalk.swig文件"></a>修改gitalk.swig文件</h2><p>原本你的文件内容应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: location.pathname,</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>现在改成即可(修改了第4行和第12行)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;/js/src/md5.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: md5(location.pathname),</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>然后重新发布就ok了，gitalk又可以正确创建issue了，你又可以继续评论了。</p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><p>因为gitalk关联issue是通过number，你没有number的时候，它会直接利用你的id，而id的这个生成条件又被你修改了，因此你之前评论是无法和你的文章关联上了。<br>如果对js稍微感兴趣的话，应该可以顺着这个思路往下能解决。博主有空也会试试，就当研究研究js，大家要是有成功的案例，可以在通过评论告知，毕竟这也是造福大家。<br>附上<a href="https://github.com/gitalk/gitalk/blob/master/dist/gitalk.js" target="_blank" rel="noopener">gitalk源码地址</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我现在博客的评论系统用的是gitalk，网上教程有很多，我参考的是这份&lt;a href=&quot;https://asdfv1929.github.io/2018/01/20/gitalk/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;教程&lt;/a&gt;。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="解决问题" scheme="http://yoursite.com/categories/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="gitalk" scheme="http://yoursite.com/tags/gitalk/"/>
    
      <category term="Error" scheme="http://yoursite.com/tags/Error/"/>
    
      <category term="Validation Failed" scheme="http://yoursite.com/tags/Validation-Failed/"/>
    
  </entry>
  
</feed>
