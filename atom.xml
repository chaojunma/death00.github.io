<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>健程之道</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.death00.top/"/>
  <updated>2020-02-01T06:01:46.571Z</updated>
  <id>https://www.death00.top/</id>
  
  <author>
    <name>健健</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>力扣394——字符串解码</title>
    <link href="https://www.death00.top/2020/02/01/%E5%8A%9B%E6%89%A3394%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>https://www.death00.top/2020/02/01/力扣394——字符串解码/</id>
    <published>2020-02-01T02:00:00.000Z</published>
    <updated>2020-02-01T06:01:46.571Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要涉及的是对递归和栈的理解。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>这道题目，简单来看就是根据数字和内容，进行不断重复输出，最终得出结果。因此，递归也是最容易让人想到的。</p><p>数字代表内容需要重复的次数，<code>[</code>代表一次新的递归开始，<code>]</code>代表本次递归的结束，有点类似括号匹配这种问题。只是需要记录中间结果，以及最开始的<code>s</code>进过一次递归遍历后的下标位置。</p><p>基于上面的讲解，我们也就能够写出代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder resultSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(s, <span class="number">0</span>, resultSb);</span><br><span class="line">        <span class="keyword">return</span> resultSb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> index, StringBuilder resultSb)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要重复的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s.charAt(index);</span><br><span class="line">            <span class="comment">// 如果是数字，则先累计进count中</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="string">'0'</span> &amp;&amp; temp &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                count = count * <span class="number">10</span> + temp - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到'['，则开始新一轮的递归</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">'['</span>) &#123;</span><br><span class="line">                StringBuilder tempResult = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                index = dfs(s, index + <span class="number">1</span>, tempResult);</span><br><span class="line">                <span class="comment">// 重复</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    resultSb.append(tempResult);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// count进行重置</span></span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到']'，结束递归</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">']'</span>) &#123;</span><br><span class="line">                            <span class="comment">// 返回新的下标</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到字母</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resultSb.append(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h3 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h3><p>既然有递归的写法，那么自然有不递归的写法，这就需要借助栈了。大家可以类比成计算一段普通的数学表达式，里面有括号、数字、符号运算等，所以需要两个栈，分别存储数字和运算符。</p><p>这道题目自然也是需要两个栈的，一个用来存储重复的次数，一个用来存储中间的字符串结果。判断出栈、入栈的依据，依据是<code>[]</code>，<code>[</code>代表数字和字符串都压入相应的栈，<code>]</code>代表需要将数字和字符串都需要从栈首压出，进行计算。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放次数的栈</span></span><br><span class="line">        Stack&lt;Integer&gt; countStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存放字符串的栈</span></span><br><span class="line">        Stack&lt;StringBuilder&gt; sbStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 临时存储字符串的内容</span></span><br><span class="line">        StringBuilder tempSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 临时存储数字的内容</span></span><br><span class="line">        <span class="keyword">int</span> tempCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> temp : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 如果是数字，则先累计进tempCount中</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="string">'0'</span> &amp;&amp; temp &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                tempCount = tempCount * <span class="number">10</span> + temp - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到'['，将之前的数字和字符串放进countStack中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">'['</span>) &#123;</span><br><span class="line">                countStack.push(tempCount);</span><br><span class="line">                tempCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                sbStack.push(tempSb);</span><br><span class="line">                tempSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到']'，从countStack拿出数字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="comment">// 重复</span></span><br><span class="line">                StringBuilder tempResult = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">int</span> count = countStack.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">                    tempResult.append(tempSb);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 拿出sbStack第一个</span></span><br><span class="line">                StringBuilder sb = sbStack.pop();</span><br><span class="line">                tempSb = sb.append(tempResult);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到字母</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tempSb.append(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tempSb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要涉及的是对递归和栈的理解，有点类似数学表达式的计算，只是做一下类比即可。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要涉及的是对递归和栈的理解。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="递归" scheme="https://www.death00.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://www.death00.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>力扣347——前 K 个高频元素</title>
    <link href="https://www.death00.top/2020/01/31/%E5%8A%9B%E6%89%A3347%E2%80%94%E2%80%94%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>https://www.death00.top/2020/01/31/力扣347——前 K 个高频元素/</id>
    <published>2020-01-31T02:00:00.000Z</published>
    <updated>2020-01-31T13:50:54.159Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要涉及的是对数据结构里哈希表、小顶堆的理解，优化时可以参考一些排序方法。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li></ul><p>原题url：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="正常思路"><a href="#正常思路" class="headerlink" title="正常思路"></a>正常思路</h3><p>为了解决这道题，我们首先需要知道每个元素出现的次数。最方便的话，可以使用哈希表，因为这就是一个<code>数字——出现次数</code>的映射关系。此处的时间复杂度为<code>O(n)</code></p><p>其次，因为需要查找频率前 k 高的元素，所以我们肯定是需要排序的，时间复杂度为<code>O(n log n)</code>的排序方法有许多，快速排序、堆排序等，我是用的堆排序，使用<code>小顶堆</code>，这样在每次入堆的时候，检查一下堆的个数是否超过 k，如果超过，则移除堆顶的元素(也就是次数最少的元素)。</p><p>这样堆里剩余的元素也就是最终的结果了，接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建hashMap，记录每个元素出现的个数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            countMap.put(num, countMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用PriorityQueue构建小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; countMap.get(n1) - countMap.get(n2));</span><br><span class="line">        Set&lt;Integer&gt; keySet = countMap.keySet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : keySet) &#123;</span><br><span class="line">            heap.add(key);</span><br><span class="line">            <span class="comment">// 如果个数大于k，则移除次数最少的数</span></span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = heap.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            result.add(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h3 id="桶排序优化"><a href="#桶排序优化" class="headerlink" title="桶排序优化"></a>桶排序优化</h3><p>针对排序，我想到了一个优化，利用桶排序，其时间复杂度为<code>O(n)</code>，主要是浪费空间，因为需要申请额外的数组，下标代表出现的次数，元素我用的是 LinkedList，这样可以存储多个。那么这个在进行输出时，只要从后往前进行遍历，当结果的数量达到 k 时，就可以停止了。</p><p>接下来我们看看代码 ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建hashMap，记录每个元素出现的个数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录最多的次数</span></span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = countMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">                maxCount = count;</span><br><span class="line">            &#125;</span><br><span class="line">            countMap.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 桶排序，构建数组，下标为重复的次数</span></span><br><span class="line">        LinkedList[] array = <span class="keyword">new</span> LinkedList[maxCount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : countMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> count = entry.getValue();</span><br><span class="line">            LinkedList&lt;Integer&gt; list = array[count];</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                array[count] = list;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒着遍历数组，直到找到K个元素</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; result.size() &lt; k; i--) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = array[i];</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.addAll(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要涉及的是对数据结构的理解，优化时可以参考一些特殊的排序方法。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要涉及的是对数据结构里哈希表、小顶堆的理解，优化时可以参考一些排序方法。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣337——打家劫舍 III</title>
    <link href="https://www.death00.top/2020/01/25/%E5%8A%9B%E6%89%A3337%E2%80%94%E2%80%94%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/"/>
    <id>https://www.death00.top/2020/01/25/力扣337——打家劫舍 III/</id>
    <published>2020-01-25T02:00:00.000Z</published>
    <updated>2020-01-25T02:08:23.994Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇也是基于”打家劫舍”的扩展，需要针对特殊情况特殊考虑，当然其本质还是动态规划，优化时需要考虑数据结构。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>先给出树节点的结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="简单思路"><a href="#简单思路" class="headerlink" title="简单思路"></a>简单思路</h3><p>这道题简单来说，就是如果存在<code>父节点、子节点、孙子节点</code>三层的话，要么偷<code>父节点 + 孙子节点</code>，要么只偷<code>子节点</code>。</p><p>顺着这个思路，我们只要找出每个节点所能偷到的最大值，自然也就能找出从 root 节点开始偷的最大值了。</p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;TreeNode, Integer&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否已经计算过</span></span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 策略1：抢当前节点和孙子节点</span></span><br><span class="line">        <span class="keyword">int</span> sum1 = root.val + </span><br><span class="line">            <span class="comment">// 左子节点的子节点们</span></span><br><span class="line">            (root.left == <span class="keyword">null</span> ? <span class="number">0</span> : (rob(root.left.left) + rob(root.left.right))) +</span><br><span class="line">            <span class="comment">// 右子节点的子节点们</span></span><br><span class="line">            (root.right == <span class="keyword">null</span> ? <span class="number">0</span> : (rob(root.right.left) + rob(root.right.right)));</span><br><span class="line">        <span class="comment">// 策略2：只抢子节点</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = rob(root.left) + rob(root.right);</span><br><span class="line">        <span class="comment">// 找出更大的值</span></span><br><span class="line">        <span class="keyword">int</span> sum = Math.max(sum1, sum2);</span><br><span class="line">        <span class="comment">// 并记录</span></span><br><span class="line">        cache.put(root, sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>5 ms</code>，只战胜了<code>52.00%</code>的 java 提交记录，因此还是有值得优化的地方。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面的解法，如果说有什么值得优化的地方，就是在于我们在动态规划时，不仅考虑了子节点，甚至也考虑到了孙子节点，因此当 子节点 变成 父节点 之后，孙子节点 也变成了 子节点。</p><p>也就是说，一开始的<code>孙子节点</code>被计算了两遍。虽然我们借用了一个 map 来记录了中间结果，但我们需要注意，这种情况依旧会被计算，只是代价被转移到了针对 map 的操作，这也是需要消耗时间的。</p><p>那么现在的优化，就转变成针对中间状态的记录上了。</p><p>其实我们针对每个节点的状态，只需要记录两种情况：抢或者不抢。而且这个状态只会被父节点用到，并不需要永久保留。因此我们考虑用一个长度为 2 的数组进行记录，这样就会快捷很多。</p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// index为0，代表不抢当前节点的最大值</span></span><br><span class="line">        <span class="comment">// index为1，代表抢当前节点，不抢子节点的最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] res = dp(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dp(TreeNode cur) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] left = dp(cur.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = dp(cur.right);</span><br><span class="line">        <span class="comment">// 抢当前节点，子节点都不抢</span></span><br><span class="line">        <span class="keyword">int</span> rob = cur.val + left[<span class="number">0</span>] +right[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 不抢当前节点，获取左右子节点各自的最大值</span></span><br><span class="line">        <span class="keyword">int</span> notRob = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 返回结果 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;notRob, rob&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，时间消耗只有<code>1 ms</code>，确实快了很多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要还是利用动态规划，只是需要大家进行思路转化，优化时需要考虑的更多是对数据结构的理解。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇也是基于”打家劫舍”的扩展，需要针对特殊情况特殊考虑，当然其本质还是动态规划，优化时需要考虑数据结构。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣213——打家劫舍 II</title>
    <link href="https://www.death00.top/2020/01/24/%E5%8A%9B%E6%89%A3213%E2%80%94%E2%80%94%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II/"/>
    <id>https://www.death00.top/2020/01/24/力扣213——打家劫舍 II/</id>
    <published>2020-01-24T02:00:00.000Z</published>
    <updated>2020-01-25T02:08:38.998Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇是上一篇的扩展，需要针对特殊情况特殊考虑，当然其本质还是动态规划。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-ii/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题的变化是，同样是一个数组，但是首尾相连了，也就是成了一个环，那么原本递推的方式也就行不通了，因为任何一个节点其实地位都相等了，也就找不到最初的状态，无法进行递推了。</p><p>但我们可以将现在的问题转化成我们已经解决的问题，仔细想想。所谓的首尾相连，针对状态进行划分，可以有三种情况：</p><ol><li>首尾节点都不选择</li><li>只选择首节点，不选择尾结点</li><li>只选择尾结点，不选择首节点</li></ol><p>因为我们最终是要求出最大值，那么只需要考虑后面两种情况，而这样的话，又可以转化成了原本的线性数组了。</p><p>接下来让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为收尾相连，无法按照最初的动态规划来做，因为没有一个可以开始的点。</span></span><br><span class="line">        <span class="comment">// 那么就将未知问题转化为已知问题，针对首尾两个节点，可以有三种情况：</span></span><br><span class="line">        <span class="comment">// 1、首尾节点都不选择</span></span><br><span class="line">        <span class="comment">// 2、只选择首节点，不选择尾结点</span></span><br><span class="line">        <span class="comment">// 3、只选择尾结点，不选择首节点</span></span><br><span class="line">        <span class="comment">// 因为是要取最大值，且是非负整数数据，所以只考虑后两种情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(</span><br><span class="line">            <span class="comment">// 只选择首节点，不选择尾结点</span></span><br><span class="line">            calMax(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>),</span><br><span class="line">            <span class="comment">// 只选择尾结点，不选择首节点</span></span><br><span class="line">            calMax(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calMax</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储当前位置，下一个位置，和再下一个位置的结果</span></span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next_1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 动态规划，利用中间结果，寻找最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">            current = Math.max(</span><br><span class="line">                <span class="comment">// 当前不偷</span></span><br><span class="line">                next_1,</span><br><span class="line">                <span class="comment">// 当前偷</span></span><br><span class="line">                nums[i] + next_2</span><br><span class="line">            );</span><br><span class="line">            next_2 = next_1;</span><br><span class="line">            next_1 = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要还是利用动态规划，只是需要大家进行思路转化，将未知转化为 已知，从而解决问题。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇是上一篇的扩展，需要针对特殊情况特殊考虑，当然其本质还是动态规划。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣198——打家劫舍</title>
    <link href="https://www.death00.top/2020/01/20/%E5%8A%9B%E6%89%A3198%E2%80%94%E2%80%94%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>https://www.death00.top/2020/01/20/力扣198——打家劫舍/</id>
    <published>2020-01-20T02:00:00.000Z</published>
    <updated>2020-01-20T13:18:09.007Z</updated>
    
    <content type="html"><![CDATA[<p>这次准备连讲三道题，这道题就是最基础的，利用动态规划可以解决。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="动态规划-自顶向下"><a href="#动态规划-自顶向下" class="headerlink" title="动态规划-自顶向下"></a>动态规划-自顶向下</h3><p><code>动态规划</code>大家应该很容易就想到，如果偷了当前的金钱，下一家就不能偷，如果不偷当前的金钱，可以考虑下一家。比如：</p><p>小偷到了第3家，他有两个选择：不偷第3家之后去第4家、偷完第3家之后去第5家。这时他需要比较的是：</p><ul><li>从第4家开始能偷到的最多金钱</li><li>第3家的金钱加上从第5家开始能偷到的最多金钱<br>上面两者谁更多，就选择怎么做。</li></ul><p>那主要目的就是要求出从当前到结尾可以偷到的最大值，为了不重复计算，可以利用一个数组记录中间结果。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储中间结果</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(result, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 动态规划，利用中间结果，寻找最大值</span></span><br><span class="line">        dp(<span class="number">0</span>, nums, result);</span><br><span class="line">        <span class="keyword">return</span> result[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result[start] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result[start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result[start] = Math.max(</span><br><span class="line">            <span class="comment">// 选择偷当前的家</span></span><br><span class="line">            nums[start] + dp(start + <span class="number">2</span>, nums, result),</span><br><span class="line">            <span class="comment">// 选择不偷当前的家</span></span><br><span class="line">            dp(start + <span class="number">1</span>, nums, result)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h3 id="动态规划-自底向上"><a href="#动态规划-自底向上" class="headerlink" title="动态规划-自底向上"></a>动态规划-自底向上</h3><p>上面的写法其实是从头向尾考虑，写法上是递归。那么如果想不用递归呢？毕竟递归也是有缺陷的，如果次数过多，总调用栈就会很长。那我们来改造一下。</p><p>如果我们是从尾向头考虑呢？也就是从最后一家开始，选择偷或者不偷，最终到第一家。思想上还是很好理解的，和上面差不多，让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储中间结果</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 动态规划，利用中间结果，寻找最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = Math.max(</span><br><span class="line">                <span class="comment">// 当前不偷</span></span><br><span class="line">                result[i + <span class="number">1</span>],</span><br><span class="line">                <span class="comment">// 当前偷</span></span><br><span class="line">                nums[i] + result[i + <span class="number">2</span>]</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交也是OK的。</p><h3 id="空间上的优化"><a href="#空间上的优化" class="headerlink" title="空间上的优化"></a>空间上的优化</h3><p>我们仔细观察一下上面的写法，其实每次你利用到的中间状态只有两个，下一个位置和再下一个位置。那么此时我们也可以用三个变量来存储就够了，两个存储之后的值，还有一个存储当前的值。</p><p>让我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储当前位置，下一个位置，和再下一个位置的结果</span></span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next_1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 动态规划，利用中间结果，寻找最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            current = Math.max(</span><br><span class="line">                <span class="comment">// 当前不偷</span></span><br><span class="line">                next_1,</span><br><span class="line">                <span class="comment">// 当前偷</span></span><br><span class="line">                nums[i] + next_2</span><br><span class="line">            );</span><br><span class="line">            next_2 = next_1;</span><br><span class="line">            next_1 = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要利用动态规划就可以解决，可以改写递归，优化空间复杂度。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次准备连讲三道题，这道题就是最基础的，利用动态规划可以解决。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣322——零钱兑换</title>
    <link href="https://www.death00.top/2020/01/16/%E5%8A%9B%E6%89%A3322%E2%80%94%E2%80%94%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>https://www.death00.top/2020/01/16/力扣322——零钱兑换/</id>
    <published>2020-01-16T02:00:00.000Z</published>
    <updated>2020-01-16T13:40:49.092Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要涉及动态规划，利用这个，就能很好解决这个问题。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>你可以认为每种硬币的数量是无限的。</p><p>原题url：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="求出所有可能"><a href="#求出所有可能" class="headerlink" title="求出所有可能"></a>求出所有可能</h3><p>我们可以从小到大，求出由当前硬币，组成所有金额的最小数，这样最终就是最大金额所能组成的最小硬币数量。</p><p>这种方法核心思想就是记录所有中间状态的结果，如果在实际使用中，你的传入参数<code>amount</code>是不断变化的，那么用这种方法会比较方法，因为之前的结果可以被重复利用，这样也是一种优势。</p><p>现在我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排序，升序</span></span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来记录中间结果，各种金额所需要的硬币数量</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历所有可能的金额</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> currentAmount = <span class="number">1</span>; currentAmount &lt;= amount; currentAmount++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minNum = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 遍历所有硬币</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前金额已经比硬币的值小</span></span><br><span class="line">                <span class="keyword">int</span> remainAmount = currentAmount - coins[j];</span><br><span class="line">                <span class="keyword">if</span> (remainAmount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// remainAmount无法由硬币组成</span></span><br><span class="line">                <span class="keyword">if</span> (result[remainAmount] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取更小的值</span></span><br><span class="line">                minNum = Math.min(minNum, result[remainAmount] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result[currentAmount] = minNum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : result[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>12 ms</code>，内存消耗：<code>36 MB</code>，只超过了<code>83.24%</code>的 java 提交，看来还有优化的空间。</p><h3 id="动态规划优化"><a href="#动态规划优化" class="headerlink" title="动态规划优化"></a>动态规划优化</h3><p>倒不是说动态规划就一定比上面的方法更加优秀，只是也是一种思想，可以利用 dfs(深度优先搜索) 或者 bfs(广度优先搜索)，我下面这种写法是 dfs，因为是一路进行到底之后，再去考虑其他情况的。(补充一点，如果使用 bfs 的话，可以借助队列来实现非递归的形式。)</p><p>所谓的优化，就是从硬币的使用上来说，从面值大的开始，并且从可以使用数量最大的开始。与此同时，我们也记录了最小使用数量，如果用当前面值最大的硬币并且使用最多时，依旧大于最小值，那么就不用继续查找了。</p><p>以上的优化，其实是和题目相关联，虽然不能用在其他的题目上，但也可以作为一种思想，值得我们借鉴和学习。</p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minCount = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="comment">// 从大往小找</span></span><br><span class="line">        helper(coins, coins.length - <span class="number">1</span>, <span class="number">0</span>, amount);</span><br><span class="line">        <span class="keyword">return</span> minCount == Integer.MAX_VALUE ? -<span class="number">1</span> : minCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> coinIndex, <span class="keyword">int</span> curCount, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coinIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果能整除，直接取完</span></span><br><span class="line">        <span class="keyword">if</span> (amount % coins[coinIndex] == <span class="number">0</span>) &#123;</span><br><span class="line">            minCount = Math.min(minCount, curCount + amount / coins[coinIndex]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数量上也是从大往小找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = amount / coins[coinIndex]; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 因为接下来至少还会用1个币</span></span><br><span class="line">            <span class="keyword">if</span> (curCount + i + <span class="number">1</span> &gt;= minCount) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            helper(coins, coinIndex - <span class="number">1</span>, curCount + i, amount - i * coins[coinIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>2 ms</code>，内存消耗：<code>34.7 MB</code>，超过了<code>100.00%</code>的 java 提交，有种又快又好的感觉。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要利用动态规划就可以解决，优化的时候需要注意边界条件，从大到小取值，在时间复杂度上能更加优化。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要涉及动态规划，利用这个，就能很好解决这个问题。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣309——最佳买卖股票时机含冷冻期</title>
    <link href="https://www.death00.top/2020/01/14/%E5%8A%9B%E6%89%A3309%E2%80%94%E2%80%94%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
    <id>https://www.death00.top/2020/01/14/力扣309——最佳买卖股票时机含冷冻期/</id>
    <published>2020-01-14T02:00:00.000Z</published>
    <updated>2020-01-14T14:02:58.306Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要涉及状态转移方程，想清楚所有状态后，就可以轻松解决。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>一开始我就是想着一共有几种状态，这几种状态分别可以转换为哪些状态：</p><ol><li>当前是”持股状态”，可以选择继续不交易，保持”持股状态”，或者选择卖掉之后变成”冷冻状态”；</li><li>当前是”冷冻状态”，只能选择继续不交易，变成”不持股状态”；</li><li>当前是”不持股状态”，可以选择继续不交易，保持”不持股状态”，或者选择买股票之后变成”持股状态”；</li></ol><p>我增加了最后终止条件：如果是最后一天，并且手上持有股票的话，必须卖出，这样可以保证最终利益最大。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        recursiveBuy(-<span class="number">1</span>, <span class="keyword">false</span>, <span class="number">0</span>, <span class="number">0</span>, prices);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursiveBuy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> prePrice,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> cooldown,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> profit,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果到了最后一天，并且手上持有股票的话，必须卖掉</span></span><br><span class="line">        <span class="keyword">if</span> (index == prices.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prePrice &gt;= <span class="number">0</span> &amp;&amp; !cooldown) &#123;</span><br><span class="line">                profit = profit + prices[index];</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, profit);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前持有股票</span></span><br><span class="line">        <span class="keyword">if</span> (prePrice &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时可以选择不交易，或者卖掉</span></span><br><span class="line">            <span class="comment">// 不交易</span></span><br><span class="line">            recursiveBuy(prePrice, cooldown, profit, index + <span class="number">1</span>, prices);</span><br><span class="line">            <span class="comment">// 卖掉</span></span><br><span class="line">            recursiveBuy(-<span class="number">1</span>, <span class="keyword">true</span>, profit + prices[index], index + <span class="number">1</span>, prices);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前不持有股票，可以被动不交易、主动不交易、买</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果处于冷冻期，只能被动不交易</span></span><br><span class="line">        <span class="keyword">if</span> (cooldown) &#123;</span><br><span class="line">            recursiveBuy(prePrice, <span class="keyword">false</span>, profit, index + <span class="number">1</span>, prices);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不交易</span></span><br><span class="line">        recursiveBuy(prePrice, cooldown, profit, index + <span class="number">1</span>, prices);</span><br><span class="line">        <span class="comment">// 买</span></span><br><span class="line">        recursiveBuy(prices[index], cooldown, profit - prices[index], index + <span class="number">1</span>, prices);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>报了<code>超出时间限制</code>，好的，我们想想怎么优化。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>上面<code>暴力解法</code>之所以会超时，因为重复计算了。我一开始的想法是想着记录中间结果，但越想越复杂，忍不住看了别人的思路，真的是让我豁然开朗。那就是<code>状态转移方程</code>。</p><p>之前我上面提到的是所有状态可以变成哪些状态，但其实有些地方想的是不清楚的。我们用<code>箭头</code>连接两个状态，<code>箭头开始</code>的那端表示前一天的状态，<code>箭头终止</code>的那端表示当天的状态，那么其内容为：</p><p><img src="https://pic.leetcode-cn.com/6dba5214e21684d0383521aaf820b66191106473b9e8a07faaa394e5136b5f47-image.png" alt=""></p><p>因为买和卖只是两个操作，我们认为只能在每一天的0点执行，当天的状态就由0点之后的状态来表示。</p><ul><li>“冷冻期”状态只能是昨天刚买了股票，也就是”不持股”状态转移过来。</li><li>“不持股”状态可以由自己，或者昨天是”持股”状态，今天卖掉，转移过来。</li><li>“持股”状态可以由自己，或者昨天是”冷冻期”状态，今天买了，转移过来。</li></ul><p>你可能会问，如果这样表示状态转移方程的话，那么第一天可以买入股票就没法解释了。那简单，为了配合这种特殊情况，我们再记录一个更早一天的不持股状态，这样就可以满足了。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为每次只涉及到前一天的三个状态值，因此只要三个数字记录即可</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 其状态转移方程为：</span></span><br><span class="line"><span class="comment">         * "冷冻期"只能由"不持股"转换而来。</span></span><br><span class="line"><span class="comment">         * "持股"可以由"持股"和"冷冻期"转换而来。</span></span><br><span class="line"><span class="comment">         * "不持股"可以由"不持股"和"持股"转换而来。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">// 定义初始情况</span></span><br><span class="line">         <span class="comment">// 不持股</span></span><br><span class="line">         <span class="keyword">int</span> noStock = <span class="number">0</span>;</span><br><span class="line">         <span class="comment">// 持股</span></span><br><span class="line">         <span class="keyword">int</span> hasStock = -prices[<span class="number">0</span>];</span><br><span class="line">         <span class="comment">// 冷冻期</span></span><br><span class="line">         <span class="keyword">int</span> cooldown = <span class="number">0</span>;</span><br><span class="line">         <span class="comment">// 上一次的不持股</span></span><br><span class="line">         <span class="keyword">int</span> beforeNoStock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">                     <span class="comment">// "不持股"可以由"不持股"和"持股"转换而来。</span></span><br><span class="line">             noStock = Math.max(beforeNoStock, hasStock + prices[i]);</span><br><span class="line">                         <span class="comment">// "持股"可以由"持股"和"冷冻期"转换而来。</span></span><br><span class="line">             hasStock = Math.max(hasStock, cooldown - prices[i]);</span><br><span class="line">                         <span class="comment">// "冷冻期"只能由"不持股"转换而来。</span></span><br><span class="line">             cooldown = beforeNoStock;</span><br><span class="line">                         <span class="comment">// 更新一下"上一次的不持股"状态</span></span><br><span class="line">             beforeNoStock = noStock;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> Math.max(noStock, cooldown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h3 id="状态转移方程继续优化"><a href="#状态转移方程继续优化" class="headerlink" title="状态转移方程继续优化"></a>状态转移方程继续优化</h3><p>其实从上面的分析，你隐约可以察觉到，”冷冻期”就是一种特殊的”不持股”状态。根据上面的结论，当你想买股票时，要求的是必须连续两天”不持股”，这点你想通了吗？可能也正因为这一点，我们在上面的代码中才需要记录”上一次的不持股”状态。</p><p>既然这样，我们干脆就简化为<code>持股</code>状态和<code>不持股</code>状态两种，其状态转移方程可以描述为：</p><ul><li><code>持股</code>状态可以由自己，或者连续两天为<code>不持股</code>状态，今天买了股票，转移而来。</li><li><code>不持股</code>状态可以由自己，或者前一天为<code>持股</code>状态，今天卖了股票，转移而来。</li></ul><p>因为我们记录的是每一天状态所对应的收入，那么所谓的<code>连续两天为不持股状态</code>，就是相当于从两天前收入不变。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这次只有两个状态，但需要记录两天前的不持股收入</span></span><br><span class="line">        <span class="comment">// 定义初始情况</span></span><br><span class="line">        <span class="comment">// 不持股</span></span><br><span class="line">        <span class="keyword">int</span> noStock = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 持股</span></span><br><span class="line">        <span class="keyword">int</span> hasStock = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 上一次的不持股</span></span><br><span class="line">        <span class="keyword">int</span> beforeNoStock = <span class="number">0</span>, temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">                    <span class="comment">// 记录一下"两天前的不持股"收入</span></span><br><span class="line">                    temp = noStock;</span><br><span class="line">            <span class="comment">// "不持股"可以由"不持股"和"持股"转换而来。</span></span><br><span class="line">            noStock = Math.max(noStock, hasStock + prices[i]);</span><br><span class="line">            <span class="comment">// "持股"可以由"持股"和"冷冻期"转换而来。</span></span><br><span class="line">            hasStock = Math.max(hasStock, beforeNoStock - prices[i]);</span><br><span class="line">            <span class="comment">// 更新一下"上一次的不持股"状态</span></span><br><span class="line">            beforeNoStock = temp;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 最大值一定是最后一天不持股的情况</span></span><br><span class="line">        <span class="keyword">return</span> noStock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。状态转移应该还是很经典的方法，主要在于是否可以想出所有状态及其转化关系。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要涉及状态转移方程，想清楚所有状态后，就可以轻松解决。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="状态转移方程" scheme="https://www.death00.top/tags/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣300——最长上升子序列</title>
    <link href="https://www.death00.top/2020/01/13/%E5%8A%9B%E6%89%A3300%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://www.death00.top/2020/01/13/力扣300——最长上升子序列/</id>
    <published>2020-01-13T02:00:00.000Z</published>
    <updated>2020-01-13T14:01:21.692Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要涉及动态规划，优化时可以考虑贪心算法和二分查找。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure></p><p>说明:</p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 O(n2) 。</li></ul><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>这也是最基础的想法，利用递归，从每一个数开始，一个一个寻找，只要比选中的标准大，那么就以新的数为起点，继续找。全部找完后，找出最长的序列即可。</p><p>也看一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归查询</span></span><br><span class="line">        <span class="keyword">return</span> recursiveSearch(nums, Integer.MIN_VALUE, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursiveSearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> standard, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果包含当前index的数字，其递增长度</span></span><br><span class="line">        <span class="keyword">int</span> tokenLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; standard) &#123;</span><br><span class="line">            tokenLength = <span class="number">1</span> + recursiveSearch(nums, nums[index], index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不包含当前index的数字，其递增长度</span></span><br><span class="line">        <span class="keyword">int</span> notTokenLength = recursiveSearch(nums, standard, index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回较大的那个值</span></span><br><span class="line">        <span class="keyword">return</span> tokenLength &gt; notTokenLength ? tokenLength : notTokenLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交之后报<code>超出时间限制</code>，这个也是预料到的，那么我们优化一下。</p><h3 id="记录中间结果"><a href="#记录中间结果" class="headerlink" title="记录中间结果"></a>记录中间结果</h3><p>仔细分析一下上面的暴力解法，假设 nums 是：<code>[10,9,2,5,3,7,101,18]</code>，那么从 7 到 101 这个查找，在2、5、3的时候，都曾经查找过一遍。</p><p>那么针对这种重复查找的情况，我们可以用一个二维数组，记录一下中间结果，这样就可以达到优化的效果。比如用<code>int[][] result</code>标记为记录中间结果的数组，那么<code>result[i][j]</code>就代表着从 nums[i - 1] 开始，无论包含还是不包含 nums[j] 的最大递增序列长度。这样就能保证不再出现重复计算的情况了。</p><p>让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录已经计算过的结果</span></span><br><span class="line">        <span class="keyword">int</span> result[][] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>][nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                result[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归查询</span></span><br><span class="line">        <span class="keyword">return</span> recursiveSearch(nums, -<span class="number">1</span>, <span class="number">0</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursiveSearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> preIndex, <span class="keyword">int</span> index, <span class="keyword">int</span>[][] result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经赋值，说明计算过，因此直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (result[preIndex + <span class="number">1</span>][index] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result[preIndex + <span class="number">1</span>][index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果包含当前index的数字，其递增序列最大长度</span></span><br><span class="line">        <span class="keyword">int</span> tokenLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (preIndex &lt; <span class="number">0</span> || nums[index] &gt; nums[preIndex]) &#123;</span><br><span class="line">            tokenLength = <span class="number">1</span> + recursiveSearch(nums, index, index + <span class="number">1</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不包含当前index的数字，其递增序列最大长度</span></span><br><span class="line">        <span class="keyword">int</span> notTokenLength = recursiveSearch(nums, preIndex, index + <span class="number">1</span>, result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回较大的那个值</span></span><br><span class="line">        result[preIndex + <span class="number">1</span>][index] = tokenLength &gt; notTokenLength ? tokenLength : notTokenLength;</span><br><span class="line">        <span class="keyword">return</span> result[preIndex + <span class="number">1</span>][index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>提交OK，但是结果感人，几乎是最慢的了，无论时间还是空间上，都只打败了`5%`左右的用户，那就继续优化。### 动态规划</code></pre><p>假设我知道了从 nums[0] 到 nums[i] 的最大递增序列长度，那么针对 nums[i + 1]，我只要去跟前面的所有数比较一下，找出前面所有数中比 nums[i + 1] 小的数字中最大的递增子序列，再加1就是 nums[i + 1] 对应的最大递增子序列。</p><p>这样我只要再记录一个最大值，就可以求出整个数组的最大递增序列了。</p><p>让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划，之前几个数字中，有几个比当前数小的，不断更新</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储中间结果</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 最大值，因为数组中至少有一个，所以最小是1</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前下标i的最大递增序列长度</span></span><br><span class="line">            <span class="keyword">int</span> currentMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果nums[i]比nums[j]大，那么nums[i]可以加在nums[j]后面，继续构成一个递增序列</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    currentMax = Math.max(currentMax, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加上当前的数</span></span><br><span class="line">            dp[i] = currentMax + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            max = Math.max(dp[i], max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>9 ms</code>，只战胜了<code>75.15%</code>的 java 提交，看来还是可以继续优化的。</p><h3 id="贪心算法-二分查找"><a href="#贪心算法-二分查找" class="headerlink" title="贪心算法 + 二分查找"></a>贪心算法 + 二分查找</h3><p>贪心算法意味着不需要是最完美的结果，只要针对当前是有效的，就可以了。</p><p>我们之前在构造递增序列的时候，其实是在不断根据之前的值进行更新的，并且十分准确。但其实并不需要如此，只要保证序列中每个数都相对较小，就可以得出最终的最大长度。</p><p>还是以<code>[10,9,2,5,3,7,101,18,4,8,6,12]</code>举例：</p><ol><li>从10到2，都是无法构成的，因为每一个都比之前的小。</li><li>当以最小的2作为起点后，<code>2,5</code>、<code>2,3</code>都是可以作为递增序列，但明显感觉<code>2,3</code>更合适，因为3更小。</li><li>因为7大于3，因此递增序列增长为<code>2,3,7</code>。</li><li>因为101也大于7，因此递增序列增长为<code>2,3,7,101</code>。</li><li>因为18小于101，但是大于7，因此我们可以用18替换101，因为18更小，序列更新为<code>2,3,7,18</code></li><li>此时遇到4，4大于3但是小于7，我们可以用它替换7，虽然此时新的序列<code>2,3,4,18</code>并不是真正的结果，但首先长度上没有问题，其次如果出现新的可以排在最后的数，一定是大于4的，因为要先大于现在的最大值18。序列更新为<code>2,3,4,18</code>。</li><li>同理，8大于4小于18，替换18，此时新的序列<code>2,3,4,8</code>，这样是不是大家开始懂得了这个规律。</li><li>遇到6之后，更新为<code>2,3,4,6</code>。</li><li>遇到12后，更新为<code>2,3,4,6,12</code>。</li></ol><p>这样也就求出了最终的结果。</p><p>结合一下题目<code>说明</code>里提到的<code>O(nlogn)</code>，那么就可以想到二分查找，运用到这里也就是找到当前数合适的位置。</p><p>接下来让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贪心 + 二分查找</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个空数组，用来存储最长递增序列</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        result[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 空数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> resultLength = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="comment">// 如果num比当前最大数大，则直接加在末尾</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; result[resultLength - <span class="number">1</span>]) &#123;</span><br><span class="line">                result[resultLength] = num;</span><br><span class="line">                resultLength++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果和最大数相等，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (num == result[resultLength - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// num比最大值小，则找出其应该存在的位置</span></span><br><span class="line">            <span class="keyword">int</span> shouldIndex = Arrays.binarySearch(result, <span class="number">0</span>, resultLength, num);</span><br><span class="line">            <span class="keyword">if</span> (shouldIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                shouldIndex = -(shouldIndex + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新，此时虽然得出的result不一定是真正最后的结果，但首先其resultLength不会变，之后就算resultLength变大，也是相对正确的结果</span></span><br><span class="line">            <span class="comment">// 这里的更新，只是为了让result数组中每个位置上的数，是一个相对小的数字</span></span><br><span class="line">            result[shouldIndex] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>2 ms</code>，差不多了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目用动态规划其实就已经能解决了，但为了优化，还需要用到贪心算法和二分查找。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要涉及动态规划，优化时可以考虑贪心算法和二分查找。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心算法" scheme="https://www.death00.top/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.death00.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>力扣287——寻找重复数</title>
    <link href="https://www.death00.top/2020/01/12/%E5%8A%9B%E6%89%A3287%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <id>https://www.death00.top/2020/01/12/力扣287——寻找重复数/</id>
    <published>2020-01-12T02:00:00.000Z</published>
    <updated>2020-01-12T09:50:43.776Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是找规律，基于之前142题环形链表II的规律，就能解决了。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ul><p>原题url：<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="普通思路"><a href="#普通思路" class="headerlink" title="普通思路"></a>普通思路</h3><p>针对说明里的前两条，其实就分别对应了解题的两种思路：</p><ol><li>先原地排序，再遍历寻找。</li><li>使用集合记录已经出现过的数字。</li></ol><p>当然了，既然已经在说明里被禁止了， 那么就应该想想别的思路了。</p><p>我还想到了利用 bitMap 的思路，相当于用一个数字的二进制，各个位上是否为1来表示该数字是否出现过。但考虑到 java 里 int 的最大值是 (2^31 - 1)，long 的最大值也不过是(2^63 - 1)，那都是要求 n 不能大于100的。因此，这种思路也是暂时不可取的。</p><h3 id="抽象为环形链表II"><a href="#抽象为环形链表II" class="headerlink" title="抽象为环形链表II"></a>抽象为环形链表II</h3><p>如果将数组的下标和值抽象成链表的话，出现重复数字也就意味着出现链表中有环，那么这道题就是之前做到的<code>力扣142——环形链表II</code>一模一样了。</p><p>我们举例说明一下，假设数组是[1, 5, 7, 3, 2, 4, 6, 7]，那么将其转化成的链表就是：<code>0 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 6 -&gt; 7 ....</code>无限循环。</p><p>那我们就可以借助快慢指针：</p><ol><li>快指针一次走两步，慢指针一次走一步，直到他们相遇；</li><li>快指针再次从起点出发，但此时两个指针都是一次走一步；</li><li>当他们再次相遇后，相遇点就是重复的整数。</li></ol><p>接下来让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参考环形链表II，利用快慢指针</span></span><br><span class="line">        <span class="comment">// 快指针一次走两步，慢指针一次走一步，当他们相遇后</span></span><br><span class="line">        <span class="comment">// 快指针再次从起点出发，但此时两个指针都是一次走一步</span></span><br><span class="line">        <span class="comment">// 当他们再次相遇后，相遇点就是重复的整数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，时间复杂度为：O(n)，空间复杂度是：O(1)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目主要还是在于寻找其中的规律，转化为环形链表来思考。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是找规律，基于之前142题环形链表II的规律，就能解决了。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣279——完全平方数</title>
    <link href="https://www.death00.top/2020/01/11/%E5%8A%9B%E6%89%A3279%E2%80%94%E2%80%94%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>https://www.death00.top/2020/01/11/力扣279——完全平方数/</id>
    <published>2020-01-11T02:00:00.000Z</published>
    <updated>2020-01-11T12:30:30.362Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要利用广度优先搜索进行动态规划，就可以解决了，也可以推导出关系解决。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 = 4 + 9.</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="动态规划-广度优先搜索"><a href="#动态规划-广度优先搜索" class="headerlink" title="动态规划 + 广度优先搜索"></a>动态规划 + 广度优先搜索</h3><p>因为累加的都是完全平方数，这样的组合会有很多种，比如12，可以<code>9 + 1 + 1 + 1</code>或者<code>4 + 4 + 4.</code>，甚至可以12个1相加。那么我们进行在进行动态规划的时候，肯定不是算出所有可能，所以就不是使用深度优先搜索了，因为要求个数最少，那么就自然想到广度优先搜索了。优化的话，自然就是先算最大的数，也就是离 n 最近的且比它小的平方数了。</p><p>编码的时候需要注意，一般我们使用队列实现广度优先搜索，因为它是先进先出。</p><p>其次，我们需要考虑顺序问题，我们让大的平方数尽量靠前出现，比如上面<code>12 = 9 + 1 + 1 + 1</code>，按照广度优先搜索也会出现<code>12 = 1 + 1 + 1 + 9</code>或者<code>12 = 1 + 9 + 1 + 1</code>等等，后面出现的这些情况理论上都可以直接排除掉，我们可以认为后面那些情况都是第一轮是<code>1</code>之后剩余值为<code>11</code>的衍生，那么都可以合并掉。因此我们又增加一个优化条件：如果曾经出现过的剩余值再次出现，可以不用再次考虑，因为一定会在最开始出现的情况中被考虑到。</p><p>接下来我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用队列实现广度优先搜索，进行查询。</span></span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(n, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 利用队列进行广度优先搜索</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="comment">// 存储已经出现过的剩余值</span></span><br><span class="line">        <span class="keyword">boolean</span> record[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> val, level;</span><br><span class="line">        <span class="keyword">int</span> i, result;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 移除头节点</span></span><br><span class="line">            TreeNode node = queue.remove();</span><br><span class="line">            val = node.val;</span><br><span class="line">            level = node.level;</span><br><span class="line">                        <span class="comment">// 从最大的平方数开始</span></span><br><span class="line">            <span class="keyword">for</span> (i = (<span class="keyword">int</span>) Math.sqrt(val); i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">                result = val - i * i;</span><br><span class="line">                <span class="comment">// 剩余值为0，说明可以直接在这一层结束</span></span><br><span class="line">                <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// result如果之前没有出现过，那么就要算上当前的数字，进入下一层中</span></span><br><span class="line">                <span class="keyword">if</span> (!record[result]) &#123;</span><br><span class="line">                    record[result] = <span class="keyword">true</span>;</span><br><span class="line">                    TreeNode nextNode = <span class="keyword">new</span> TreeNode(result, level + <span class="number">1</span>);</span><br><span class="line">                    queue.add(nextNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点的值</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">// 当前属于第几层，也就是当前是第几个数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h3 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h3><p>还有一种就是利用递推公式了，但可能我数学不好，并没有看懂，给大家看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 首先初始化长度为 n+1 的数组dp，每个位置都为0</span><br><span class="line">2. 如果 n 为0，则结果为0</span><br><span class="line">3. 对数组进行遍历，下标为 i，每次都将当前数字先更新为最大的结果，即 dp[i]=i，比如 i=4，最坏结果为 4=1+1+1+1 即为4个数字</span><br><span class="line">4. 动态转移方程为：dp[i] = MIN(dp[i], dp[i - j * j] + 1)，i表示当前数字，j*j表示平方数</span><br></pre></td></tr></table></figure></p><p>这个思路相当于求出了从1到n所有数字的最小平方数的个数。关键在于第4点，也就是后面的计算可以依赖于前面求出的结果，每一个数都找出其所有基于以前求过的数，加上1个完全平方数后，最小的的平方数的个数。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; <span class="comment">// 默认初始化值都为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = i; <span class="comment">// 最坏的情况就是每次+1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; j++) &#123; </span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>); <span class="comment">// 动态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，但这种方法并没有上面有效率，因为上面可以从最大的平方数找起，只要满足当前n的情况即可，这个的话需要求出所有从1到n的情况，因此你需要看情况选择合适的方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目主要还是在于利用广度优先搜索实现动态规划，也可以找规律，本质其实都是动态规划。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要利用广度优先搜索进行动态规划，就可以解决了，也可以推导出关系解决。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="广度优先搜索" scheme="https://www.death00.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>力扣240——搜索二维矩阵</title>
    <link href="https://www.death00.top/2020/01/11/%E5%8A%9B%E6%89%A3240%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>https://www.death00.top/2020/01/11/力扣240——搜索二维矩阵/</id>
    <published>2020-01-11T02:00:00.000Z</published>
    <updated>2020-01-11T04:41:34.648Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要是利用搜索二维矩阵本身的特性，找到其中的规律，就可以解决了。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><p>示例:</p><p>现有矩阵 matrix 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p>原题url：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题相比之前的二维矩阵，可能有序性没有之前那么强，所以没法直接拉成一个一维数组利用二分法查找，需要结合其特性，进行查找。</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>就是一行行、一列列慢慢找。假设是一个<code>m * n</code>的二维数组，那么时间复杂度就是<code>O(mn)</code>，这个方法没什么好说的，贴个代码看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="行列同时寻找"><a href="#行列同时寻找" class="headerlink" title="行列同时寻找"></a>行列同时寻找</h3><p>这是我自己想的方法，就是每次查找行列，只查每一行每一列最大值和最小值。根据这个二维数组的特性，找出可能存在 target 的行列的范围，然后逐渐缩小，如果行列相同时，则开始遍历寻找。</p><p>让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(<span class="number">0</span>, matrix.length - <span class="number">1</span>, <span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>, matrix, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> rowStart, <span class="keyword">int</span> rowEnd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> colStart, <span class="keyword">int</span> colEnd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rowStart == rowEnd || colStart == colEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rowStart == rowEnd) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = colStart; i &lt;= colEnd; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[rowStart][i] == target) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rowStart; i &lt;= rowEnd; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][colStart] == target) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 是否有合适的行，默认没有</span></span><br><span class="line">        <span class="keyword">boolean</span> has = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 新的rowStart、rowEnd</span></span><br><span class="line">        <span class="keyword">int</span> newRowStart = <span class="number">0</span>, newRowEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 筛选行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rowStart; i &lt;= rowEnd; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果相等，说明找到了</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][colStart] == target || matrix[i][colEnd] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// target大于这一行的最大值，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; matrix[i][colEnd]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// target小于这一行的最小值，说明之后的就不用找了</span></span><br><span class="line">            <span class="keyword">if</span> (target &lt; matrix[i][colStart]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是第一次找到</span></span><br><span class="line">            <span class="keyword">if</span> (!has) &#123;</span><br><span class="line">                has = <span class="keyword">true</span>;</span><br><span class="line">                newRowStart = i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            newRowEnd = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span> (!has) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        has = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> newColStart = <span class="number">0</span>, newColEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 筛选列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = colStart; i &lt;= colEnd; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果相等，说明找到了</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[newRowStart][i] == target || matrix[newRowEnd][i] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// target大于这一列的最大值，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; matrix[newRowEnd][i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// target小于这一列的最小值，说明之后的就不用找了</span></span><br><span class="line">            <span class="keyword">if</span> (target &lt; matrix[newRowStart][i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是第一次找到</span></span><br><span class="line">            <span class="keyword">if</span> (!has) &#123;</span><br><span class="line">                has = <span class="keyword">true</span>;</span><br><span class="line">                newColStart = i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            newColEnd = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span> (!has) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> search(newRowStart, newRowEnd, newColStart, newColEnd, matrix, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度上，应该是比最基础的暴力法好一些，但应该也是没有本质区别。</p><h3 id="行列同时二分查找"><a href="#行列同时二分查找" class="headerlink" title="行列同时二分查找"></a>行列同时二分查找</h3><p>以行列总数中较小的那个数，选择构成正方形的正对角线，每一次按照二分法，查找相应的行列，可以参考下面这张图：<br><img src="https://imgkr.cn-bj.ufileos.com/efa57c2e-908c-47db-af59-4e03cff20c49.png" alt=""></p><p>每次都会对行和列各用一次二分法，逐步排查。让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用二分法搜索</span></span><br><span class="line">        <span class="comment">// 寻找出行数、列数中较小的那个值，作为迭代次数</span></span><br><span class="line">        <span class="keyword">int</span> count = Math.min(matrix.length, matrix[<span class="number">0</span>].length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low, high, middle;</span><br><span class="line">        <span class="comment">// 迭代循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">// 从(i,i)开始，寻找这一行是否有target</span></span><br><span class="line">            low = i;</span><br><span class="line">            high = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][middle] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][middle] &gt; target) &#123;</span><br><span class="line">                    high = middle - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从(i,i)开始，寻找这一列是否有target</span></span><br><span class="line">            low = i;</span><br><span class="line">            high = matrix.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (matrix[middle][i] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (matrix[middle][i] &gt; target) &#123;</span><br><span class="line">                    high = middle - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的时间复杂度为<code>O(lg(n!))</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这个算法产生的时间复杂度并不是特别明显的是 O(lg(n!)) ，所以让我们一步一步地分析它。</span><br><span class="line">在主循环中执行的工作量逐渐最大，它运行 min(m,n)次迭代，其中 m 表示行数，n 表示列数。</span><br><span class="line">在每次迭代中，我们对长度为 m-i 和 n-i 的数组执行两次二分查找。因此，循环的每一次迭代都以 O(lg(m-i)+lg(n-i)) 时间运行，其中 i 表示当前迭代。</span><br><span class="line">我们可以将其简化为 O(2 lg(n-i))= O(lg(n-i)) ，在最坏的情况是 n≈m 。当 n≪m 时，n 将在渐近分析中占主导地位。通过汇总所有迭代的运行时间，我们得到以下表达式：</span><br><span class="line">O(lg(n)+lg(n−1)+lg(n−2)+…+lg(1))</span><br><span class="line"></span><br><span class="line">然后，我们可以利用对数乘法规则（lg(a)+lg(b)=lg(ab)）将复杂度改写为：</span><br><span class="line"></span><br><span class="line">O(lg(n)+lg(n−1)+lg(n−2)+…+lg(1))</span><br><span class="line">=O(lg(n⋅(n−1)⋅(n−2)⋅…⋅1))</span><br><span class="line">=O(lg(1⋅…⋅(n−2)⋅(n−1)⋅n))</span><br><span class="line">=O(lg(n!))</span><br></pre></td></tr></table></figure></p><h3 id="划分为四个二维数组"><a href="#划分为四个二维数组" class="headerlink" title="划分为四个二维数组"></a>划分为四个二维数组</h3><p>这是一种递归查找，同样也是利用了这个二维搜索数组的特性。我们在当前矩阵中间的列上进行比较，如果小于 target 就继续向下比较，直到找到比 target 大的数，此时递归查找左上和右上的矩阵。</p><p>以下面这张图为例，我们假设<code>target = 9</code>，那么中间列找到 10 以后，发现比 9 大，因此寻找左上和右上两个标红的矩阵：<br><img src="https://imgkr.cn-bj.ufileos.com/82c84161-1bbb-4ede-bf6f-d33595913fe3.png" alt=""></p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用搜索二维矩阵的特性，划分为2个搜索矩阵进行递归搜索</span></span><br><span class="line">        <span class="keyword">return</span> searchRecursive(<span class="number">0</span>, <span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>, matrix.length - <span class="number">1</span>, matrix, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左上角和右下角的坐标，在这个二维矩阵中进行搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">searchRecursive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> left, <span class="keyword">int</span> up,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> right, <span class="keyword">int</span> down,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此时矩阵的长度或者宽度为0，那么就没有必要搜索了</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right || up &gt; down) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果target小于该矩阵的最小值(左上角)或者大于该矩阵的最大值(右下角)，也没有必要搜索了</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[up][left] || target &gt; matrix[down][right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用列进行拆分</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 从上到下开始寻找</span></span><br><span class="line">        <span class="keyword">int</span> row = up;</span><br><span class="line">        <span class="keyword">for</span> (; row &lt;= down; row++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// matrix[row][mid]作为一个标准点，如果小于target，则继续往下一行寻找</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[row][mid] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果matrix[row][mid]大于target，则停止增加</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> searchRecursive(left, row, mid - <span class="number">1</span>, down, matrix, target) ||</span><br><span class="line">               searchRecursive(mid + <span class="number">1</span>, up, right, row - <span class="number">1</span>, matrix, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：O(nlgn)。分析如下：<br><img src="https://imgkr.cn-bj.ufileos.com/50e71edf-40b8-476d-9384-094a33ab3ccd.png" alt=""></p><h3 id="单向寻找"><a href="#单向寻找" class="headerlink" title="单向寻找"></a>单向寻找</h3><p>结合该二维数组的特性，我们希望在进行比较的时候，只往一个方向寻找，这样可以简化查询步骤。如果从左上(最小)开始寻找时，如果 target 比当前值大，我们不知道是该往右移还是往下移，右下(最大)同理。</p><p>此时我们可以换一种思路，从左下开始，因为比它小的数一定在它右边，比它大的数一定在它右边，这样寻找的时候就简单多了。</p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左下角开始寻找，如果当前值大于target，则向上移动一行；如果当前值小于target，则向右移动一列。</span></span><br><span class="line">        <span class="comment">// 直到找到target，或者超出矩阵边界</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列的最大值</span></span><br><span class="line">        <span class="keyword">int</span> colMax = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 行列开始的下标</span></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &gt;= <span class="number">0</span> &amp;&amp; col &lt;= colMax) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果大于target，则向上移一行</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] &gt; target) &#123;</span><br><span class="line">                row--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果小于target，则向右一列</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                col++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：O(n+m)。如果和上面一样，假设 n &lt;&lt; m，那么就是 O(m)，总的来说，还是比较高效的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目主要还是在于利用二维搜索数组的特性，完成解题。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要是利用搜索二维矩阵本身的特性，找到其中的规律，就可以解决了。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣221——最大正方形</title>
    <link href="https://www.death00.top/2020/01/09/%E5%8A%9B%E6%89%A3221%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <id>https://www.death00.top/2020/01/09/力扣221——最大正方形/</id>
    <published>2020-01-09T02:00:00.000Z</published>
    <updated>2020-01-08T13:44:06.739Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要是利用动态规划，注意好边界条件，就可以解决。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-square/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>这道题应该很快会让我们想起使用动态规划，从左上角往右下角开始找。</p><p>假设我们用一个二维数组<code>dp</code>，记录每一个位置所能构成的最大正方形的边长（从左上角开始算）。位置<code>(i, j)</code>是 1，则其可能构成的正方形的边长是<code>Min(dp(i - 1, j - 1), dp(i - 1, j), dp(i, j - 1)) + 1</code>。看到这个，相信你也会理解了，每一个位置所能构成的最大边长的条件，其实是要求包围着它的左上角三个位置都是 1 才可以。</p><p>一直递推回到最初点，也就意味着，第一行和第一列需要单独判断。</p><p>之前应该也有做过类似空间复杂度上的优化，我们真的需要一个真正的二维数据<code>dp</code>来记录中间结果吗？其实我们发现，当一个位置用过之后，这个位置本身的数字已经不再重要，关键是该位置所能构成的最大正方形的边长，也就是我们记录的中间结果。因此可以直接更新原数组上的数字。</p><p>还有就是需要考虑一些特殊情况，比如只有一行或者一列的时候，我们应该如何做。</p><p>接下来让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 高</span></span><br><span class="line">        <span class="keyword">int</span> height = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 宽</span></span><br><span class="line">        <span class="keyword">int</span> width = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查第一行和第一列，是否有'1'</span></span><br><span class="line">        <span class="keyword">int</span> result = checkFirstRowAndCol(matrix, height, width);</span><br><span class="line">        <span class="comment">// 只有一行或一列，或者只有一个</span></span><br><span class="line">        <span class="keyword">if</span> (height == <span class="number">1</span> || width == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// result现在做为记录最大边的长度</span></span><br><span class="line">        <span class="comment">// 中间结果</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; width; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 求出matrix[i - 1][j - 1]、matrix[i - 1][j]、matrix[i][j - 1]中的最小值</span></span><br><span class="line">                temp = matrix[i - <span class="number">1</span>][j] &lt; matrix[i][j - <span class="number">1</span>] ? matrix[i - <span class="number">1</span>][j] : matrix[i][j - <span class="number">1</span>];</span><br><span class="line">                temp = temp &lt; matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] ? temp : matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 更新当前节点的值</span></span><br><span class="line">                matrix[i][j] = (<span class="keyword">char</span>) (temp + <span class="number">1</span>);</span><br><span class="line">                temp = temp + <span class="number">1</span> - <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result &lt; temp) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result * result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkFirstRowAndCol</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>5 ms</code>，内存消耗：<code>41.1 MB</code>。</p><p>上面的这个代码，我并不是一次性就直接写出来的，也是在不断的提交中，发现有一些特殊情况没有考虑，幸运的是力扣会每次提交完之后会告诉我不满足时的输入的是什么样的，但这也会让我经常考虑不足，还需要努力。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目利用动态规划其实就差不多了，但重点还是在于特殊情况的判断，需要注意。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要是利用动态规划，注意好边界条件，就可以解决。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣208——实现 Trie (前缀树)</title>
    <link href="https://www.death00.top/2020/01/08/%E5%8A%9B%E6%89%A3208%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/"/>
    <id>https://www.death00.top/2020/01/08/力扣208——实现 Trie (前缀树)/</id>
    <published>2020-01-08T02:00:00.000Z</published>
    <updated>2020-01-07T13:11:55.951Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要是构造前缀树节点的数据结构，帮助解答问题。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 true</span><br></pre></td></tr></table></figure></p><p>说明:</p><ul><li>你可以假设所有的输入都是由小写字母 a-z 构成的。</li><li>保证所有输入均为非空字符串。</li></ul><p>原题url：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="前缀树的意义"><a href="#前缀树的意义" class="headerlink" title="前缀树的意义"></a>前缀树的意义</h3><p>我们用前缀树这种数据结构，主要是用在<code>在字符串数据集中搜索单词</code>的场景，但针对这种场景，我们也可以使用<code>平衡树</code>和<code>哈希表</code>，而且哈希表可以在<code>O(1)</code>时间内寻找到键值。那为什么还要前缀树呢？</p><p>原因有3：</p><ol><li>前缀树可以找到具有同意前缀的全部键值。</li><li>前缀树可以按词典枚举字符串的数据集。</li><li>前缀树在存储多个具有相同前缀的键时可以使用较少的空间，只需要<code>O(m)</code>的时间复杂度，其中 m 为键长。在平衡树中查找键值却需要<code>O(m log n)</code>，其中 n 是插入的键的数量；而哈希表随着大小的增加，会出现大量的冲突，时间复杂度可能增加到<code>O(n)</code>。</li></ol><h3 id="构造前缀树的节点结构"><a href="#构造前缀树的节点结构" class="headerlink" title="构造前缀树的节点结构"></a>构造前缀树的节点结构</h3><p>既然是树，肯定也是有根节点的。至于其节点结构，需要有以下特点：</p><ol><li>最多 R 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。本题中假定 R 为 26，小写拉丁字母的数量。</li><li>布尔字段，以指定节点是对应键的结尾还是只是键前缀。</li></ol><p><img src="https://pic.leetcode-cn.com/3463d9e7cb323911aa67cbd94910a34d88c9402a1ab41bbea10852cd0a74f2af-file_1562596867185" alt=""></p><p>接下来让我们看看节点结构的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TrieNode[] nodes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 26个小写英文字母</span></span><br><span class="line">        nodes = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 当前是否已经结束</span></span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前节点是否包含字符 ch</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nodes[ch - <span class="string">'a'</span>] != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置新的下一个节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">setNode</span><span class="params">(<span class="keyword">char</span> ch, TrieNode node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 判断当前新的节点是否已经存在</span></span><br><span class="line">        TrieNode tempNode = nodes[ch - <span class="string">'a'</span>];</span><br><span class="line">                <span class="comment">// 如果存在，就直接返回已经存在的节点</span></span><br><span class="line">        <span class="keyword">if</span> (tempNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tempNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则就设置为新的节点，并返回</span></span><br><span class="line">        nodes[ch - <span class="string">'a'</span>] = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取 ch 字符</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">getNode</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nodes[ch - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置当前节点为结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前节点是否已经结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来就是真正的前缀树的结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode before = root;</span><br><span class="line">        TrieNode node;</span><br><span class="line">                <span class="comment">// 遍历插入单词中的每一个字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            node = before.setNode(word.charAt(i), node);</span><br><span class="line">            before = node;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// 设置当前为终点</span></span><br><span class="line">        before.setIsEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode before = root;</span><br><span class="line">        TrieNode temp;</span><br><span class="line">                <span class="comment">// 遍历查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            temp = before.getNode(word.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            before = temp;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// 且最后一个节点也是终点</span></span><br><span class="line">        <span class="keyword">return</span> before.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode before = root;</span><br><span class="line">        TrieNode temp;</span><br><span class="line">                <span class="comment">// 遍历查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            temp = before.getNode(prefix.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            before = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>43 ms</code>，内存消耗：<code>55.3 MB</code>，虽然只战胜了<code>87.40%</code>的提交，但试了一下最快的那个代码，和我这个方法在时间上基本没什么差别，应该是当初提交的时候测试用例没有那么多吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目可能需要专门去理解一下前缀树的用途，这样可以有助于构造前缀树的结构。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要是构造前缀树节点的数据结构，帮助解答问题。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="前缀树" scheme="https://www.death00.top/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>力扣207——课程表</title>
    <link href="https://www.death00.top/2020/01/07/%E5%8A%9B%E6%89%A3207%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <id>https://www.death00.top/2020/01/07/力扣207——课程表/</id>
    <published>2020-01-07T02:00:00.000Z</published>
    <updated>2020-01-06T13:27:56.431Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要利用拓扑排序，判断该图是否有环，其中还会涉及到邻接矩阵。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure></p><p>说明:</p><ol><li>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。</li><li>你可以假定输入的先决条件中没有重复的边。</li></ol><p>提示:</p><ol><li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li><li>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li><li>拓扑排序也可以通过 BFS 完成。</li></ol><p>原题url：<a href="https://my.openwrite.cn/user/article/write" target="_blank" rel="noopener">https://my.openwrite.cn/user/article/write</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这是我第一次遇到图相关的题目，讲道理，有向图、无向图、出度、入度之类的概念还能记得，但是拓扑排序、邻接矩阵、逆邻接矩阵却只是知道有这么一个概念，但具体内容也已经忘光了。我会在下面的解题过程中为大家呈现这些概念。</p><p>先介绍一下拓扑排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：</span><br><span class="line"></span><br><span class="line">1. 每个顶点出现且只出现一次。</span><br><span class="line">2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</span><br><span class="line"></span><br><span class="line">有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</span><br></pre></td></tr></table></figure></p><p>从上面的概念中可以看出，这道题目就是要判断给定的图是否是<code>有向无环图</code>，也就是其是否有<code>拓扑排序</code>。</p><p>求一个图是否有拓扑排序，我们一般有两种办法：<code>广度优先搜索 + 邻接矩阵</code>、<code>深度优先搜索 + 逆邻接矩阵</code>。接下来我们逐一来为大家分析：</p><h3 id="广度优先搜索-邻接矩阵"><a href="#广度优先搜索-邻接矩阵" class="headerlink" title="广度优先搜索 + 邻接矩阵"></a>广度优先搜索 + 邻接矩阵</h3><p>首先看一下什么是<code>邻接矩阵</code>：</p><blockquote><p>在图论中，邻接矩阵（英语：adjacency matrix）是表示一种图结构的常用表示方法。它用数字方阵记录各点之间是否有边相连，数字的大小可以表示边的权值大小。</p></blockquote><p>这么看有点抽象，简单点说：就是一个图中各个节点的后继节点链表。</p><p>举个例子：</p><p><img src="https://imgkr.cn-bj.ufileos.com/ed815f80-ba50-41f8-84bc-bf33bfc723fe.png" alt=""></p><p>这样一个图，其邻接矩阵为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; null</span><br><span class="line">2 -&gt; 4 -&gt; null</span><br><span class="line">3 -&gt; 4 -&gt; null</span><br><span class="line">4 -&gt; null</span><br></pre></td></tr></table></figure></p><p>好了，弄懂了邻接矩阵，我们来想想如何使用<code>广度优先搜索</code>？</p><p>假设有向图无环，那么从入度为 0 的点，依次<code>删除</code>，这里并不是真正意义上的删除，只是如果该节点消失后，其后继节点的入度需要减1，此时再判断是否又有新的入度为0的节点，如果最终所有节点都会被减到0，那么说明有向图无环，让我们看一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用入度表和DFS进行拓扑排序</span></span><br><span class="line">        <span class="comment">// 下标i对应的节点，其入度的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] indegressArray = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// key:节点i，value:其所有出度节点</span></span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(numCourses * <span class="number">4</span> / <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">            indegressArray[pre[<span class="number">0</span>]] += <span class="number">1</span>;</span><br><span class="line">            List&lt;Integer&gt; list = map.get(pre[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                map.put(pre[<span class="number">1</span>], list);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(pre[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将入度为0的入队列</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegressArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> indegress = indegressArray[i];</span><br><span class="line">            <span class="keyword">if</span> (indegress != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取第一个节点，并将这个节点"删除"</span></span><br><span class="line">            <span class="keyword">int</span> node = list.removeFirst();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="comment">// 那么以node作为前驱节点的节点，其入度-1</span></span><br><span class="line">            List&lt;Integer&gt; preList = map.get(node);</span><br><span class="line">            <span class="keyword">if</span> (preList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer suffixNode : preList) &#123;</span><br><span class="line">                indegressArray[suffixNode] -= <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果该节点入度减为0，则也入队</span></span><br><span class="line">                <span class="keyword">if</span> (indegressArray[suffixNode] == <span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(suffixNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最终所有节点都入队并且也出队，那么说明该图无环。</span></span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>8 ms</code>，内存消耗：<code>45 MB</code>，执行用时只战胜了<code>84.74%</code>的 java 提交记录，我们再优化优化试试。</p><h3 id="广度优先搜索-邻接矩阵-优化"><a href="#广度优先搜索-邻接矩阵-优化" class="headerlink" title="广度优先搜索 + 邻接矩阵 优化"></a>广度优先搜索 + 邻接矩阵 优化</h3><p>map 虽然理论上查找速度为 O(1)，但需要先计算 hash 值，而数组的话，其获取地址是根据下标的。而我们这里的数字是连续的，并且从 0 开始，因此很适用数组的情况，因此做一个改造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用入度表DFS进行拓扑排序</span></span><br><span class="line">        <span class="comment">// 下标i对应的节点，其入度的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] indegressArray = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 邻接矩阵，数组下标:节点i，list:其所有后继节点</span></span><br><span class="line">        List&lt;Integer&gt;[] adjacencyMatrix = <span class="keyword">new</span> LinkedList[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">            <span class="comment">// 入度表相应节点的入度+1</span></span><br><span class="line">            indegressArray[pre[<span class="number">0</span>]] += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 邻接矩阵</span></span><br><span class="line">            List&lt;Integer&gt; list = adjacencyMatrix[pre[<span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                adjacencyMatrix[pre[<span class="number">1</span>]] = list;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(pre[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将入度为0的入队列</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegressArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> indegress = indegressArray[i];</span><br><span class="line">            <span class="keyword">if</span> (indegress != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取第一个节点，并将这个节点"删除"</span></span><br><span class="line">            <span class="keyword">int</span> node = list.removeFirst();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="comment">// 那么以node作为前驱节点的后继节点，入度-1</span></span><br><span class="line">            List&lt;Integer&gt; preList = adjacencyMatrix[node];</span><br><span class="line">            <span class="keyword">if</span> (preList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer prefixNode : preList) &#123;</span><br><span class="line">                indegressArray[prefixNode] -= <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果该节点入度减为0，则也入队</span></span><br><span class="line">                <span class="keyword">if</span> (indegressArray[prefixNode] == <span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(prefixNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最终所有节点都入队并且也出队，那么说明该图无环。</span></span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>5 ms</code>，内存消耗：<code>45 MB</code>，执行用时战胜了<code>94.01%</code>的 java 提交记录，应该差不多了。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>既然知道了邻接矩阵，那么逆连接矩阵就是指的各个节点的前驱节点链表。还是以之前的那个例子：</p><p><img src="https://imgkr.cn-bj.ufileos.com/ed815f80-ba50-41f8-84bc-bf33bfc723fe.png" alt=""></p><p>这样一个图，其逆逆邻接矩阵为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; null</span><br><span class="line">2 -&gt; 1 -&gt; null</span><br><span class="line">3 -&gt; 1 -&gt; null</span><br><span class="line">4 -&gt; 2 -&gt; 3 -&gt; null</span><br></pre></td></tr></table></figure></p><p>那么如何进行深度优先遍历呢？也就是以一个节点出发，访问其相邻节点，一直遍历下去，如果发现一个节点被访问两次，说明有环，那么返回失败，否则就标记该节点已经全部访问完成。当访问完全部节点成功后，说明有向图无环。</p><p>这么一看，深度优先遍历的时候，其实只要保证相邻即可，无所谓邻接矩阵还是逆邻接矩阵。</p><p>我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用逆邻接矩阵，进行深度优先搜索</span></span><br><span class="line">        HashSet&lt;Integer&gt;[] inadjacencyMatrix = <span class="keyword">new</span> HashSet[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            inadjacencyMatrix[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造逆连接矩阵（每个节点的所有后继节点）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] array : prerequisites) &#123;</span><br><span class="line">            inadjacencyMatrix[array[<span class="number">1</span>]].add(array[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有节点的被使用情况，如果正在使用的节点，再次被访问，说明有环</span></span><br><span class="line">        <span class="comment">// 0：未使用；1：正在使用；2：已经使用完成；</span></span><br><span class="line">        <span class="keyword">int</span>[] used = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(i, inadjacencyMatrix, used)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, HashSet&lt;Integer&gt;[] inadjacencyMatrix, <span class="keyword">int</span>[] used)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前节点已经处于正在被访问的状态，现在又再次访问，说明有环</span></span><br><span class="line">        <span class="keyword">if</span> (used[index] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点已经访问结束，则可以不用再次被访问</span></span><br><span class="line">        <span class="keyword">if</span> (used[index] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// used[index] == 0，说明该节点从未被访问过，那么现在开始访问该节点</span></span><br><span class="line">        used[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 深度遍历该节点的后继节点</span></span><br><span class="line">        HashSet&lt;Integer&gt; suffixNodes = inadjacencyMatrix[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> suffixNode : suffixNodes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(suffixNode, inadjacencyMatrix, used)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 深度遍历完成该节点，直接结束</span></span><br><span class="line">        used[index] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>8 ms</code>，内存消耗：<code>44.6 MB</code>，优化的话，暂时并没有想到好方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这也是我第一次解决图相关的题目，涉及的知识点有些多，需要好好消化。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要利用拓扑排序，判断该图是否有环，其中还会涉及到邻接矩阵。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="图" scheme="https://www.death00.top/tags/%E5%9B%BE/"/>
    
      <category term="拓扑排序" scheme="https://www.death00.top/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="广度优先搜索" scheme="https://www.death00.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="深度优先搜索" scheme="https://www.death00.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="邻接矩阵" scheme="https://www.death00.top/tags/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5/"/>
    
      <category term="逆邻接矩阵" scheme="https://www.death00.top/tags/%E9%80%86%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>力扣152——乘积最大子序列</title>
    <link href="https://www.death00.top/2020/01/06/%E5%8A%9B%E6%89%A3152%E2%80%94%E2%80%94%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://www.death00.top/2020/01/06/力扣152——乘积最大子序列/</id>
    <published>2020-01-06T02:00:00.000Z</published>
    <updated>2020-01-05T09:24:06.614Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是利用动态规划进行解答，如果要进行优化，就需要找规律了。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>看到这道题，第一眼想到的就是暴力求解，从第一个数字开始，一直连续着求到最后。稍微增加了对于 0 的判断，因为 0 乘以任何数都等于 0，所以只要碰到 0，当前的这次求解就可以停止。让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (max &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    max = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dfs(nums, i + <span class="number">1</span>, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前乘积是否最大</span></span><br><span class="line">        <span class="keyword">if</span> (total &gt; max) &#123;</span><br><span class="line">            max = total;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有没有越界</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前数字是否是0，是0的话就没有必要继续下去，因为乘积永远为0</span></span><br><span class="line">        <span class="keyword">if</span> (nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(nums, index + <span class="number">1</span>, total * nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交之后，报<code>超出时间限制</code>。看来暴力求解果然不可取，让我们再想想。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>既然不能暴力求解，那我们能不能利用上之前求解的结果呢？没错，这就是<code>动态规划</code>了。</p><p>原本想着是逐个求出当前下标下的最大值，但因为是乘积，考虑到负负得正的情况，只记录最大值可能还不够，需要最大值和最小值一起记录。</p><p>但根据之前优化的经验，并不需要申请额外的数组存储最大值和最小值，只需要用常数量的空间存储之前的结果，因为题目要求的是连续，只需要记录上一个序号的结果就够了。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// 包含上一个位置的数，得出来的最大值和最小值</span></span><br><span class="line">        <span class="keyword">int</span> dpMax = nums[<span class="number">0</span>], dpMin = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 最终结果的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 遍历求解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 更新 dpMin 的时候需要 dpMax 之前的信息，所以先保存起来</span></span><br><span class="line">            <span class="keyword">int</span> preMax = dpMax;</span><br><span class="line">                        <span class="comment">// 求出 (dpMin * nums[i])、(dpMax * nums[i])、nums[i] 这三个数的最大值和最小值</span></span><br><span class="line">            dpMax = Math.max(dpMin * nums[i], Math.max(dpMax * nums[i], nums[i]));</span><br><span class="line">            dpMin = Math.min(dpMin * nums[i], Math.min(preMax * nums[i], nums[i]));</span><br><span class="line">                        <span class="comment">// 更新最终的最大值</span></span><br><span class="line">            max = Math.max(max, dpMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>2 ms</code>，内存消耗：<code>38.1 MB</code>。但似乎还有稳定耗时只要<code>1 ms</code>的解法，看来可以继续优化。</p><h3 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h3><p>我们设想一下，如果这个整数数组只有正数，那么最大值就只需要将所有数字相乘即可。</p><p>如果包含负数，那么需要分成两种情况：</p><ol><li>负数为偶数个，因为负负得正，所以依旧将所有数字相乘即可。</li><li>负数为奇数个，要么从前往后乘到最后一个负数之前，要么从后往前乘到第一个负数之前。</li></ol><p>如果包含 0，那么依旧只需要从前往后和从后往前各乘一遍，只是在遇到 0 的时候，将之前相乘所得到的结果置为 1 即可，这样就可以达到<code>单独计算中间数字连续相乘</code>的效果。</p><p>根据上面的规律，其实就是从后往前、从前往后，各乘一遍，找出最大结果即可。接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 记录中间相乘的结果</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 记录最终的结果</span></span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 从前往后乘一遍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            max *= nums[i];</span><br><span class="line">            res = Math.max(res, max);</span><br><span class="line">                        <span class="comment">// 如果遇到 0，则将中间记录的结果置为 1</span></span><br><span class="line">            <span class="keyword">if</span> (max == <span class="number">0</span>) &#123;</span><br><span class="line">                max = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        max = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 从后往前乘一遍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            max *= nums[i];</span><br><span class="line">            res = Math.max(res, max);</span><br><span class="line">                        <span class="comment">// 如果遇到 0，则将中间记录的结果置为 1</span></span><br><span class="line">            <span class="keyword">if</span> (max == <span class="number">0</span>) &#123;</span><br><span class="line">                max = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>1 ms</code>，内存消耗：<code>36.3 MB</code>。这个方法真的是又快又省空间，只是需要我们耐心寻找其中的规律。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。一般来说利用动态规划就够了，如果想继续优化，就需要寻找其中的规律了。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是利用动态规划进行解答，如果要进行优化，就需要找规律了。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣148——排序链表</title>
    <link href="https://www.death00.top/2020/01/05/%E5%8A%9B%E6%89%A3148%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.death00.top/2020/01/05/力扣148——排序链表/</id>
    <published>2020-01-05T02:00:00.000Z</published>
    <updated>2020-01-05T03:10:12.758Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是在链表上利用归并排序和快速排序的变形，解决排序问题。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list/</a></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>题目很明确，排序，对于时间复杂度和空间复杂度有要求，针对<code>O(n log n)</code>，让我想到了<code>归并排序</code>和<code>快速排序</code>，接下来我们各自来看看。</p><p>对了，这里先统一放一下节点类，单向链表中的节点，存储当前节点的值和后一个节点的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Definition for singly-linked list.</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序，说白了，就是先分解到最小单元，然后逐个进行合并并排序，这样在合并的时候，其实两个链表本身就是有序的，那么当有一个全部取完后，另一个可以直接拼接在最后面。</p><p>让我们看一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 归并排序</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先分隔，利用快慢指针分隔。</span></span><br><span class="line">        <span class="comment">// 快指针先走，因为只有当空节点或1个节点才是终止条件，2个节点的时候，如果不让快指针先走，而是也指向head，那么2个节点永远不会被分隔，会陷入死循环</span></span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后半部分的开头</span></span><br><span class="line">        ListNode second = slow.next;</span><br><span class="line">        second = sortList(second);</span><br><span class="line">        <span class="comment">// 前半部分的开头</span></span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        first = sortList(first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head = result;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span> &amp;&amp; second != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.val &lt; second.val) &#123;</span><br><span class="line">                result.next = first;</span><br><span class="line">                first = first.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.next = second;</span><br><span class="line">                second = second.next;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.next = first;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.next = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>5 ms</code>，内存消耗：<code>39.6 MB</code>，执行用时只战胜了<code>59.07%</code>的 java 提交记录，应该还有优化的空间。</p><h3 id="归并排序——优化"><a href="#归并排序——优化" class="headerlink" title="归并排序——优化"></a>归并排序——优化</h3><p>针对上面的代码，在分隔的时候，设置<code>fast = head.next.next</code>，这是因为我们设置的递归终止条件是针对<code>null</code>或者单个节点的。其实当只剩下两个节点的时候，就可以进行排序了，这样应该可以节省近一半的时间，当然了，从时间复杂度上来说并没有改变。</p><p>我们看一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 归并排序</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明只有两个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode second = head.next;</span><br><span class="line">            <span class="keyword">if</span> (head.val &gt; second.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                second.next = head;</span><br><span class="line">                head.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先分隔，利用快慢指针分隔。</span></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后半部分的开头</span></span><br><span class="line">        ListNode second = slow.next;</span><br><span class="line">        second = sortList(second);</span><br><span class="line">        <span class="comment">// 前半部分的开头</span></span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        first = sortList(first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head = result;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span> &amp;&amp; second != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.val &lt; second.val) &#123;</span><br><span class="line">                result.next = first;</span><br><span class="line">                first = first.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.next = second;</span><br><span class="line">                second = second.next;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.next = first;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.next = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行用时，有的时候是<code>4 ms</code>，有的时候是<code>3 ms</code>，看来归并排序这条路差不多就是这样了。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的思想就是选择一个标准值，将比它大的和比它的小的，做交换。针对链表这种结构，就是将比它大的放在一个链表中，比它小的放在一个链表中，和它一样大的，放在另一个链表中。然后针对小的和大的链表，继续排序。最终将三个链表按照小、相等、大进行连接。</p><p>接下来让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 利用快排</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 单个节点是终止节点</span></span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比标准值小的节点</span></span><br><span class="line">            ListNode lowHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode low = lowHead;</span><br><span class="line">            <span class="comment">// 和标准值一样的节点</span></span><br><span class="line">            ListNode midHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode mid = midHead;</span><br><span class="line">            <span class="comment">// 比标准值大的节点</span></span><br><span class="line">            ListNode highHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode high = highHead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标准值</span></span><br><span class="line">            <span class="keyword">int</span> val = head.val;</span><br><span class="line">            ListNode node = head;</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 比标准值大的节点</span></span><br><span class="line">                <span class="keyword">if</span> (node.val &gt; val) &#123;</span><br><span class="line">                    high.next = node;</span><br><span class="line">                    high = high.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 比标准值小的节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node.val &lt; val) &#123;</span><br><span class="line">                    low.next = node;</span><br><span class="line">                    low = low.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 和标准值一样的节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    mid.next = node;</span><br><span class="line">                    mid = mid.next;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 终止，避免造成环</span></span><br><span class="line">            low.next = <span class="keyword">null</span>;</span><br><span class="line">            high.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            lowHead.next = sortList(lowHead.next);</span><br><span class="line">            highHead.next = sortList(highHead.next);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找出小节点链表的末尾</span></span><br><span class="line">            low = lowHead;</span><br><span class="line">            <span class="keyword">while</span> (low.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                low = low.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拼接</span></span><br><span class="line">            low.next = midHead.next;</span><br><span class="line">            mid.next = highHead.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lowHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>2 ms</code>，内存消耗：<code>40.01 MB</code>。</p><p>和归并排序相比，时间更短，至于原因，我确实是没有想明白，因为都需要比较，然后重新构造新链表。我猜测是测试数据离散程度更高，这样归并排序的话，并没有充分利用其特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当两个链表合并时，如果一个链表已经全部结束，另一个链表剩余的部分可以直接拼接。</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。针对它的时间复杂度要求，利用归并排序或者快速排序解决。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是在链表上利用归并排序和快速排序的变形，解决排序问题。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="归并排序" scheme="https://www.death00.top/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://www.death00.top/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>力扣142——环形链表 II</title>
    <link href="https://www.death00.top/2020/01/04/%E5%8A%9B%E6%89%A3142%E2%80%94%E2%80%94%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/"/>
    <id>https://www.death00.top/2020/01/04/力扣142——环形链表 II/</id>
    <published>2020-01-04T02:00:00.000Z</published>
    <updated>2020-01-05T03:08:23.738Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是找规律，推导出路径之间的关系，从而解决问题。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt=""></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p><p>示例 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p><p>进阶：</p><p>你是否可以不用额外空间解决此题？</p><p>原题url：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>在这里贴一下题目所提供的节点结构，这样下面的代码就不重复贴了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Definition for singly-linked list.</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(int x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="利用集合"><a href="#利用集合" class="headerlink" title="利用集合"></a>利用集合</h3><p>拿到题目的时候，一开始想到的就是利用集合，存储已经遍历过的节点，如果访问到 null，说明不是环；如果添加失败，说明已经添加过，那么一定是环，并且该节点就是环的入口；</p><p>顺便说一句，我认为集合所占空间应该不是很大，因为它只是存储对象的应用地址，当然了，集合本身也是一个新的对象，也会占用额外的空间。</p><p>让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode current = head;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加成功，则继续访问下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (set.add(current)) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加不成功，说明重复</span></span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>5 ms</code>，内存消耗：<code>37.7 MB</code>，但是提交用时只战胜了<code>30.99%</code>的 java 提交记录，看来有必要优化一下。</p><h3 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h3><p>以前我们判断链表是否有环，都是通过快慢指针最终是否相等。现在的话，因为环可能并不是首尾相连，所以只找一次可能不够了，需要继续寻找规律。</p><p>我们假设一开始 slow 指针走过的路程为 x，那么 fast 指针走过的路程就为 2x，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = x;</span><br><span class="line">f = 2x;</span><br></pre></td></tr></table></figure></p><p>如果 fast 指针最终为 null，那么说明不是环。</p><p>如果 fast、slow 指针最终指向的节点相等，说明有环，并且， fast 指针比 flow 指针多走了 n 圈环的长度，那么我们假设环的长度为 b，那么可以得出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = x + nb;</span><br></pre></td></tr></table></figure></p><p>可以得出：<code>s = nb;</code></p><p>以上就是最重要的结论了，slow 指针其实也已经走了 n 圈环的长度了。那么，我们再假设从 head 节点到环入口节点的长度为 a，那么从快慢指针相遇节点再走 a 步，最终会走到哪儿呢？</p><p>最终也会走到环的入口节点，因为<code>(nb + a)</code>可以理解为<code>(a + nb)</code>，相当于从 head 节点出发，达到环的入口节点处，又绕环走了 n 圈，所以也会走到环的入口。所以此时我们也找到环的入口节点了。</p><p>接下来让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先利用快慢指针，如果最终能相遇，说明有环</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 快指针为null，说明没有环</span></span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 慢指针移动一步</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 快指针移动两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">// 快慢指针相等，说明相遇</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再用两个指针，一个从头结点出发，一个从相遇点出发，两个指针每次移动1步，两个指针相遇的地方为环的入口</span></span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>1 ms</code>，内存消耗：<code>37.8 MB</code>，但是提交用时只战胜了<code>55.14%</code>的 java 提交记录，难道还有更加高效的方法？</p><p>我找了一个执行用时 0 ms 的代码，发现就是和我这个类似的，我将它的代码再次提交后，发现和我这个提交结果一样。看来那些比我们快的算法，可能是因为提交时间比较早，测试案例并不像现在那么多，所以不必担心了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目不仅要利用快慢指针，还要总结规律，最终也能解决，总的来说是一道很考验逻辑思维的题目。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是找规律，推导出路径之间的关系，从而解决问题。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣139——单词拆分</title>
    <link href="https://www.death00.top/2020/01/03/%E5%8A%9B%E6%89%A3139%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>https://www.death00.top/2020/01/03/力扣139——单词拆分/</id>
    <published>2020-01-03T02:00:00.000Z</published>
    <updated>2020-01-05T03:06:52.526Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是利用动态规划，能够利用上之前的结果，进行优化。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure></p><p>示例 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-break/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>我拿到这道题目时，第一个想到的就是暴力法，从下标0开始，每一个字母都去找，如果找到，就以当前的结尾下标作为下一次的开始下标，继续查找，看起来还是很简单的。</p><p>让我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暴力法，从第一个字母开始尝试，长度递增，如果wordDict中存在，则继续往后找，直到找到最后一个字母</span></span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="keyword">new</span> HashSet&lt;&gt;(wordDict), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s：待查找的字符串</span></span><br><span class="line"><span class="comment">     * wordDict：字典集合</span></span><br><span class="line"><span class="comment">     * start：本次查找开始的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 全部查找完成</span></span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="comment">// 当前单词包含在字典表中，并且一路查下去，都能找到</span></span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end)) &amp;&amp; dfs(s, wordDict, end)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交之后，报<code>超出时间限制</code>，我们分析一下，既然是暴力解法，针对特殊情况，一定效率很低。</p><p>在我们这里，那就是如果原字符串<code>s</code>里包含一连串相同的字母，比如：aaaaaaaaaaaaaaaaaaqqqq，并且字典里有一项就是相匹配的单个字母，比如：a，那么这个递归查找，就会针对每一个下标都去寻找一次，并且一旦失败，在下一次遍历中，又会重新查找一遍。</p><p>这时我们进行复杂度分析：</p><ul><li>时间复杂度为：<code>O(n^n)</code>，其中，n代表原字符串<code>s</code>的长度，此时就是最坏的情况。</li><li>空间复杂度为：<code>O(n)</code>，这代表递归回溯时，最多只会有 n 个调用栈同时存在。</li></ul><h3 id="初步优化——利用之前的结果"><a href="#初步优化——利用之前的结果" class="headerlink" title="初步优化——利用之前的结果"></a>初步优化——利用之前的结果</h3><p>既然上面说每次失败后，都会重新进行查找，并且明显存在重复，那么我们这一次优化的目标，就是尽可能<code>利用之前的结果</code>，那么该如何利用呢？</p><p>因为我们这是在从前向后查找，那么可以想到的就是后缀匹配，也就是利用一个记忆数组，记录每一个节点到最后一个节点是否是可以被查到的，这样在进行第一次遍历的时候，就可以得出一些中间结果，被使用到之后的查找中。</p><p>让我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记忆回溯，增加一个后缀记忆的Boolean数组，当下标i的值为true，说明从i开始可以一直找到最后，这样针对后缀可以避免重复查找</span></span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="keyword">new</span> HashSet&lt;&gt;(wordDict), <span class="number">0</span>, <span class="keyword">new</span> Boolean[s.length()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s：待查找的字符串</span></span><br><span class="line"><span class="comment">     * wordDict：字典集合</span></span><br><span class="line"><span class="comment">     * start：本次查找开始的下标</span></span><br><span class="line"><span class="comment">     * suffixMemoryArray：记忆后缀数组，当下标i的值为true，说明从i开始可以一直找到最后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start, Boolean[] suffixMemoryArray)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 全部查找完成</span></span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从当前start是否可以直接找到最后，不等于null，说明已经查找过了，直接利用之前的结果</span></span><br><span class="line">        <span class="keyword">if</span> (suffixMemoryArray[start] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> suffixMemoryArray[start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="comment">// 当前单词包含在字典表中，并且一路查下去，都能找到</span></span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end)) &amp;&amp; dfs(s, wordDict, end, suffixMemoryArray)) &#123;</span><br><span class="line">                <span class="comment">// 说明从当前start能一直从字典中找完</span></span><br><span class="line">                suffixMemoryArray[start] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        suffixMemoryArray[start] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>6 ms</code>，内存消耗：<code>37 MB</code>，执行用时只战胜了<code>73.92%</code>的 java 提交记录，看来还可以继续优化。</p><p>让我们再看一下复杂度：</p><ul><li>时间复杂度：<code>O(n^2)</code>，因为可以利用之前的结果，最多只是进行双重 for 循环。</li><li>空间复杂度为：<code>O(n)</code>，这个和之前一样的。</li></ul><h3 id="继续优化——后缀改为前缀"><a href="#继续优化——后缀改为前缀" class="headerlink" title="继续优化——后缀改为前缀"></a>继续优化——后缀改为前缀</h3><p>之前用的是后缀记忆，那么能不能用前缀记忆呢？这就相当于把问题拆分，原本的字符串<code>s</code>，拆分为前部分<code>s1</code>和后部分<code>s2</code>，如果<code>s1</code>和<code>s2</code>都能被找到，则说明<code>s</code>能被找到，然后继续拆分。</p><p>将前缀查找过的部分，也记录下来。我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划，将原本的s拆分为s1和s2，如果s1和s2都包含，则认为s是可以的，本质是前缀匹配</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字典集合</span></span><br><span class="line">        Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        <span class="comment">// 后缀记忆，默认prefixMemoryArray[0]是存在于字典中的，因为0代表着空，下标为i时，代表从0到i的字符可以直接或者被拆分后在wordDict中找到</span></span><br><span class="line">        <span class="keyword">boolean</span>[] prefixMemoryArray = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        prefixMemoryArray[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prefixMemoryArray[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    prefixMemoryArray[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prefixMemoryArray[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>7 ms</code>，内存消耗：<code>36.4 MB</code>，执行用时只战胜了<code>56.96%</code>的 java 提交记录，还不如上面那种，只是在空间上有所优化，毕竟将递归改造了一下，看来还可以继续优化。</p><p>让我们再看一下复杂度：</p><ul><li>时间复杂度：<code>O(n^2)</code>，还是和之前一样的。</li><li>空间复杂度为：<code>O(n)</code>，这个和之前一样的。</li></ul><h3 id="最终优化——找出快速失败的条件"><a href="#最终优化——找出快速失败的条件" class="headerlink" title="最终优化——找出快速失败的条件"></a>最终优化——找出快速失败的条件</h3><p>感觉思路上应该没有问题，估计在边界判定时有一些点我们可能还没有看到。</p><p>既然是要在字典集合中存在，那么如果需要查找的字符串太长或太短肯定都不可以，即不可以超过字典里最长的单词，也不可以少于字典里最短的单词。</p><p>针对上面的解法，就是：</p><ul><li>j 的初始值应该是 0 和 (i - max) 中的最大值，因为如果 j 太小，那么后续需要查找的字符串可能太长，那么就没必要找了。</li><li>j 的最大值应该是 (i - j &gt;= min)，因为如果后续需要查找的字符串可能太短，也没必要查找了。</li></ul><p>让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划，将原本的s拆分为s1和s2，如果s1和s2都包含，则认为s是可以的，本质是前缀匹配</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字典集合</span></span><br><span class="line">        Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找出wordDict中最大长度和最小长度</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word.length() &gt; max) &#123;</span><br><span class="line">                max = word.length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (word.length() &lt; min) &#123;</span><br><span class="line">                min = word.length();</span><br><span class="line">            &#125;</span><br><span class="line">            wordDictSet.add(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后缀记忆，默认prefixMemoryArray[0]是存在于字典中的，因为0代表着空，下标为i时，代表从0到i的字符可以直接或者被拆分后在wordDict中找到</span></span><br><span class="line">        <span class="keyword">boolean</span>[] prefixMemoryArray = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        prefixMemoryArray[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果需要查找的长度大于最大值或者小于最小值，就没必要继续找了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = Math.max(<span class="number">0</span>, i - max); i - j &gt;= min; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prefixMemoryArray[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    prefixMemoryArray[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prefixMemoryArray[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>2 ms</code>，内存消耗：<code>34.4 MB</code>，执行用时战胜了<code>97.96%</code>的 java 提交记录，这应该没什么问题了。</p><p>时间复杂度和空间复杂度还是和上面一样，没有本质区别。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目主要利用动态规划，复用之前计算的结果，再找出更加合适的边界条件，快速失败，最终得到比较合适的方案。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是利用动态规划，能够利用上之前的结果，进行优化。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣105——从前序与中序遍历序列构造二叉树</title>
    <link href="https://www.death00.top/2020/01/02/%E5%8A%9B%E6%89%A3105%E2%80%94%E2%80%94%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.death00.top/2020/01/02/力扣105——从前序与中序遍历序列构造二叉树/</id>
    <published>2020-01-02T02:00:00.000Z</published>
    <updated>2020-01-05T03:04:38.163Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是找规律，能否思考出前序遍历、中序遍历与二叉树之间的关系。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure></p><p>返回如下的二叉树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">          /  \</span><br><span class="line">      15   7</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题目，主要就是在于大家对于二叉树这个数据结构的熟悉程度了，根据其前序遍历和中序遍历，推算出原本的二叉树。</p><p>我们想想，如果不是写代码，只是通过手写的话，我们是如何查找的，就用题目给出的例子：</p><ol><li>根据前序遍历，第一个一定是根节点，那么 3 就是根节点。</li><li>从中序遍历中寻找 3，在它左边的，都是其左子树上的节点，在它右边的，都是其右子树上的节点。</li><li>因为中序遍历中，3 的左边只有9，那么 9 就是 3 的左子节点。</li><li>根据前序遍历<code>先根然后左子节点，然后再右子节点</code>的规律，3 、9 之后的 20 一定是 3 的右子节点。</li><li>20 在中序遍历中，其左右两边就是 15 和 7，因此15 和 7 就分别是它的左右子节点。</li></ol><p>根据上面的分析，你就可以画出例子中的二叉树了。</p><p>那么我们寻找的顺序是，先从前序遍历的第一个节点开始，在中序遍历中找出它的位置，其左右两边就是其左右子树了，</p><p>接着从左子树入手，前序遍历根节点之后的两个节点应该就是其左右子树，但需要考虑没有左右子树的情况，然后再以其子树为根，在中序遍历中找其左右子树。</p><p>需要注意的是，只有针对根节点，其左右子节点是在前序遍历中紧跟着根节点的，其他都是有距离的，需要根据左子树递推。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    <span class="comment">// preorder中遍历过的数量，这样找完左子树中的节点，剩下的第一个节点，必然是右子节点</span></span><br><span class="line">    <span class="keyword">int</span> preorderIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// key为inorder中的值，value为inorder中的下标</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; inorderMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (preorder.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">this</span>.inorderMap = <span class="keyword">new</span> HashMap&lt;&gt;(inorder.length * <span class="number">4</span> / <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.inorderMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> generateNode(<span class="number">0</span>, inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找当前节点的左右子节点</span></span><br><span class="line"><span class="comment">     * start：inorder里开始寻找的节点下标</span></span><br><span class="line"><span class="comment">     * end：inorder里终止寻找的节点下标</span></span><br><span class="line"><span class="comment">     * preorderIndex：当前节点在preorder中的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">generateNode</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        <span class="keyword">int</span> value = preorder[preorderIndex];</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">        <span class="comment">// 当前节点的值，在inorder中的下标</span></span><br><span class="line">        <span class="keyword">int</span> inorderIndex = inorderMap.get(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点已经找到，寻找下一个节点。</span></span><br><span class="line">        <span class="comment">// 因为会先去寻找左节点，当该节点左子树中所有节点全部找完后，前序遍历中，剩下节点的第一个节点，一定是该节点的右节点。</span></span><br><span class="line">        preorderIndex++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找左节点</span></span><br><span class="line">        node.left = generateNode(start, inorderIndex);</span><br><span class="line">        <span class="comment">// 寻找右节点</span></span><br><span class="line">        node.right = generateNode(inorderIndex + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>3 ms</code>，内存消耗：<code>40.1 MB</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目主要就是寻找规律，优化的话，可能就是利用 map 构造中序遍历中节点值和顺序的关系。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是找规律，能否思考出前序遍历、中序遍历与二叉树之间的关系。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣96——不同的二叉搜索树</title>
    <link href="https://www.death00.top/2020/01/01/%E5%8A%9B%E6%89%A396%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.death00.top/2020/01/01/力扣96——不同的二叉搜索树/</id>
    <published>2020-01-01T02:00:00.000Z</published>
    <updated>2020-01-05T03:02:57.298Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是找规律，找出递推关系。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3       2      1</span><br><span class="line">    \        /     /      / \      \</span><br><span class="line">     3      2     1      1   3      2</span><br><span class="line">    /      /       \                 \</span><br><span class="line">   2     1         2                  3</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题看到的第一眼，就和之前的格雷编码一样，又想用动态规划，每次都是遍历所有情况去检查是否有效，但感觉时间复杂度会很高，找找看有没有什么更高效的做法。</p><p>所谓高效，也就是寻找规律了，最好的是可以递推，下一次运算可以利用之前的结果，而本题就是用这种规律的。我们来试试 n 等于0、1、2、3的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n = 0，只有1种。</span><br><span class="line"></span><br><span class="line">n = 1，也只有1种。</span><br><span class="line"></span><br><span class="line">n = 2，有2种</span><br><span class="line">1           2</span><br><span class="line"> \         /</span><br><span class="line">   2    1</span><br><span class="line"></span><br><span class="line">n = 3，有5种</span><br><span class="line">   1         3     3      2     1</span><br><span class="line">    \        /     /      / \      \</span><br><span class="line">    3      2     1     1   3      2</span><br><span class="line">    /      /       \                    \</span><br><span class="line">   2     1         2                    3</span><br></pre></td></tr></table></figure></p><p>让我们回想一下什么叫<code>二叉搜索树</code>，就是针对每个节点，其左子树中所有节点都比它小，其右子树中所有节点都比它大。</p><p>再想一下，如果我们针对根选中的情况下，左右子树节点的个数其实也已经定下来了，那么假设同样是 3 个节点，”1、2、3”和”4、5、6”可以组成二叉搜索树，从数量上讲是一样的，因为大小关系没有变。</p><p>因此，我们可以说，针对二叉搜索树，其不用考虑值具体是多少，只需要考虑其大小关系即可，那么这就符合上面我所希望的场景了，下一次的运算可以利用之前的结果。</p><p>以这道题来说，其具体规律就是：</p><ol><li>从 1 开始遍历直至 n，以每个节点作为根节点，这样就能计算出左右各个子树的所有节点数。</li><li>当我们知道了个数，也就可以利用之前计算的结果，获得左右子树可能的情况，两者相乘，也就是在当前根的情况，所有二叉搜索树的情况。</li><li>将所有根节点的总计算出的数量做累加，也就得出了当前节点数的总情况。</li></ol><p>让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 存放中间结果</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="comment">// 左子树总节点数 + 右子树总节点数</span></span><br><span class="line">                count += (result[j - <span class="number">1</span>] * result[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，   执行用时：<code>0 ms</code>，内存消耗：<code>33.2 MB</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目只要利用规律，构造递推关系，也就能解决了。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是找规律，找出递推关系。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="递推" scheme="https://www.death00.top/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
</feed>
