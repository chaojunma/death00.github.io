<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>健程之道</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.death00.top/"/>
  <updated>2020-01-05T09:24:06.614Z</updated>
  <id>https://www.death00.top/</id>
  
  <author>
    <name>健健</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>力扣152——乘积最大子序列</title>
    <link href="https://www.death00.top/2020/01/06/%E5%8A%9B%E6%89%A3152%E2%80%94%E2%80%94%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://www.death00.top/2020/01/06/力扣152——乘积最大子序列/</id>
    <published>2020-01-06T02:00:00.000Z</published>
    <updated>2020-01-05T09:24:06.614Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是利用动态规划进行解答，如果要进行优化，就需要找规律了。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>看到这道题，第一眼想到的就是暴力求解，从第一个数字开始，一直连续着求到最后。稍微增加了对于 0 的判断，因为 0 乘以任何数都等于 0，所以只要碰到 0，当前的这次求解就可以停止。让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (max &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    max = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dfs(nums, i + <span class="number">1</span>, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前乘积是否最大</span></span><br><span class="line">        <span class="keyword">if</span> (total &gt; max) &#123;</span><br><span class="line">            max = total;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有没有越界</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前数字是否是0，是0的话就没有必要继续下去，因为乘积永远为0</span></span><br><span class="line">        <span class="keyword">if</span> (nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(nums, index + <span class="number">1</span>, total * nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交之后，报<code>超出时间限制</code>。看来暴力求解果然不可取，让我们再想想。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>既然不能暴力求解，那我们能不能利用上之前求解的结果呢？没错，这就是<code>动态规划</code>了。</p><p>原本想着是逐个求出当前下标下的最大值，但因为是乘积，考虑到负负得正的情况，只记录最大值可能还不够，需要最大值和最小值一起记录。</p><p>但根据之前优化的经验，并不需要申请额外的数组存储最大值和最小值，只需要用常数量的空间存储之前的结果，因为题目要求的是连续，只需要记录上一个序号的结果就够了。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// 包含上一个位置的数，得出来的最大值和最小值</span></span><br><span class="line">        <span class="keyword">int</span> dpMax = nums[<span class="number">0</span>], dpMin = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 最终结果的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 遍历求解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 更新 dpMin 的时候需要 dpMax 之前的信息，所以先保存起来</span></span><br><span class="line">            <span class="keyword">int</span> preMax = dpMax;</span><br><span class="line">                        <span class="comment">// 求出 (dpMin * nums[i])、(dpMax * nums[i])、nums[i] 这三个数的最大值和最小值</span></span><br><span class="line">            dpMax = Math.max(dpMin * nums[i], Math.max(dpMax * nums[i], nums[i]));</span><br><span class="line">            dpMin = Math.min(dpMin * nums[i], Math.min(preMax * nums[i], nums[i]));</span><br><span class="line">                        <span class="comment">// 更新最终的最大值</span></span><br><span class="line">            max = Math.max(max, dpMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>2 ms</code>，内存消耗：<code>38.1 MB</code>。但似乎还有稳定耗时只要<code>1 ms</code>的解法，看来可以继续优化。</p><h3 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h3><p>我们设想一下，如果这个整数数组只有正数，那么最大值就只需要将所有数字相乘即可。</p><p>如果包含负数，那么需要分成两种情况：</p><ol><li>负数为偶数个，因为负负得正，所以依旧将所有数字相乘即可。</li><li>负数为奇数个，要么从前往后乘到最后一个负数之前，要么从后往前乘到第一个负数之前。</li></ol><p>如果包含 0，那么依旧只需要从前往后和从后往前各乘一遍，只是在遇到 0 的时候，将之前相乘所得到的结果置为 1 即可，这样就可以达到<code>单独计算中间数字连续相乘</code>的效果。</p><p>根据上面的规律，其实就是从后往前、从前往后，各乘一遍，找出最大结果即可。接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 记录中间相乘的结果</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 记录最终的结果</span></span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 从前往后乘一遍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            max *= nums[i];</span><br><span class="line">            res = Math.max(res, max);</span><br><span class="line">                        <span class="comment">// 如果遇到 0，则将中间记录的结果置为 1</span></span><br><span class="line">            <span class="keyword">if</span> (max == <span class="number">0</span>) &#123;</span><br><span class="line">                max = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        max = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 从后往前乘一遍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            max *= nums[i];</span><br><span class="line">            res = Math.max(res, max);</span><br><span class="line">                        <span class="comment">// 如果遇到 0，则将中间记录的结果置为 1</span></span><br><span class="line">            <span class="keyword">if</span> (max == <span class="number">0</span>) &#123;</span><br><span class="line">                max = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>1 ms</code>，内存消耗：<code>36.3 MB</code>。这个方法真的是又快又省空间，只是需要我们耐心寻找其中的规律。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。一般来说利用动态规划就够了，如果想继续优化，就需要寻找其中的规律了。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是利用动态规划进行解答，如果要进行优化，就需要找规律了。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣148——排序链表</title>
    <link href="https://www.death00.top/2020/01/05/%E5%8A%9B%E6%89%A3148%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.death00.top/2020/01/05/力扣148——排序链表/</id>
    <published>2020-01-05T02:00:00.000Z</published>
    <updated>2020-01-05T03:10:12.758Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是在链表上利用归并排序和快速排序的变形，解决排序问题。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list/</a></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>题目很明确，排序，对于时间复杂度和空间复杂度有要求，针对<code>O(n log n)</code>，让我想到了<code>归并排序</code>和<code>快速排序</code>，接下来我们各自来看看。</p><p>对了，这里先统一放一下节点类，单向链表中的节点，存储当前节点的值和后一个节点的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Definition for singly-linked list.</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序，说白了，就是先分解到最小单元，然后逐个进行合并并排序，这样在合并的时候，其实两个链表本身就是有序的，那么当有一个全部取完后，另一个可以直接拼接在最后面。</p><p>让我们看一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 归并排序</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先分隔，利用快慢指针分隔。</span></span><br><span class="line">        <span class="comment">// 快指针先走，因为只有当空节点或1个节点才是终止条件，2个节点的时候，如果不让快指针先走，而是也指向head，那么2个节点永远不会被分隔，会陷入死循环</span></span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后半部分的开头</span></span><br><span class="line">        ListNode second = slow.next;</span><br><span class="line">        second = sortList(second);</span><br><span class="line">        <span class="comment">// 前半部分的开头</span></span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        first = sortList(first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head = result;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span> &amp;&amp; second != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.val &lt; second.val) &#123;</span><br><span class="line">                result.next = first;</span><br><span class="line">                first = first.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.next = second;</span><br><span class="line">                second = second.next;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.next = first;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.next = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>5 ms</code>，内存消耗：<code>39.6 MB</code>，执行用时只战胜了<code>59.07%</code>的 java 提交记录，应该还有优化的空间。</p><h3 id="归并排序——优化"><a href="#归并排序——优化" class="headerlink" title="归并排序——优化"></a>归并排序——优化</h3><p>针对上面的代码，在分隔的时候，设置<code>fast = head.next.next</code>，这是因为我们设置的递归终止条件是针对<code>null</code>或者单个节点的。其实当只剩下两个节点的时候，就可以进行排序了，这样应该可以节省近一半的时间，当然了，从时间复杂度上来说并没有改变。</p><p>我们看一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 归并排序</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明只有两个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode second = head.next;</span><br><span class="line">            <span class="keyword">if</span> (head.val &gt; second.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                second.next = head;</span><br><span class="line">                head.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先分隔，利用快慢指针分隔。</span></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后半部分的开头</span></span><br><span class="line">        ListNode second = slow.next;</span><br><span class="line">        second = sortList(second);</span><br><span class="line">        <span class="comment">// 前半部分的开头</span></span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        first = sortList(first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head = result;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span> &amp;&amp; second != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.val &lt; second.val) &#123;</span><br><span class="line">                result.next = first;</span><br><span class="line">                first = first.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.next = second;</span><br><span class="line">                second = second.next;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.next = first;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.next = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行用时，有的时候是<code>4 ms</code>，有的时候是<code>3 ms</code>，看来归并排序这条路差不多就是这样了。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的思想就是选择一个标准值，将比它大的和比它的小的，做交换。针对链表这种结构，就是将比它大的放在一个链表中，比它小的放在一个链表中，和它一样大的，放在另一个链表中。然后针对小的和大的链表，继续排序。最终将三个链表按照小、相等、大进行连接。</p><p>接下来让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 利用快排</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 单个节点是终止节点</span></span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比标准值小的节点</span></span><br><span class="line">            ListNode lowHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode low = lowHead;</span><br><span class="line">            <span class="comment">// 和标准值一样的节点</span></span><br><span class="line">            ListNode midHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode mid = midHead;</span><br><span class="line">            <span class="comment">// 比标准值大的节点</span></span><br><span class="line">            ListNode highHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode high = highHead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标准值</span></span><br><span class="line">            <span class="keyword">int</span> val = head.val;</span><br><span class="line">            ListNode node = head;</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 比标准值大的节点</span></span><br><span class="line">                <span class="keyword">if</span> (node.val &gt; val) &#123;</span><br><span class="line">                    high.next = node;</span><br><span class="line">                    high = high.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 比标准值小的节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node.val &lt; val) &#123;</span><br><span class="line">                    low.next = node;</span><br><span class="line">                    low = low.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 和标准值一样的节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    mid.next = node;</span><br><span class="line">                    mid = mid.next;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 终止，避免造成环</span></span><br><span class="line">            low.next = <span class="keyword">null</span>;</span><br><span class="line">            high.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            lowHead.next = sortList(lowHead.next);</span><br><span class="line">            highHead.next = sortList(highHead.next);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找出小节点链表的末尾</span></span><br><span class="line">            low = lowHead;</span><br><span class="line">            <span class="keyword">while</span> (low.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                low = low.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拼接</span></span><br><span class="line">            low.next = midHead.next;</span><br><span class="line">            mid.next = highHead.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lowHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>2 ms</code>，内存消耗：<code>40.01 MB</code>。</p><p>和归并排序相比，时间更短，至于原因，我确实是没有想明白，因为都需要比较，然后重新构造新链表。我猜测是测试数据离散程度更高，这样归并排序的话，并没有充分利用其特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当两个链表合并时，如果一个链表已经全部结束，另一个链表剩余的部分可以直接拼接。</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。针对它的时间复杂度要求，利用归并排序或者快速排序解决。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是在链表上利用归并排序和快速排序的变形，解决排序问题。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="归并排序" scheme="https://www.death00.top/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://www.death00.top/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>力扣142——环形链表 II</title>
    <link href="https://www.death00.top/2020/01/04/%E5%8A%9B%E6%89%A3142%E2%80%94%E2%80%94%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/"/>
    <id>https://www.death00.top/2020/01/04/力扣142——环形链表 II/</id>
    <published>2020-01-04T02:00:00.000Z</published>
    <updated>2020-01-05T03:08:23.738Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是找规律，推导出路径之间的关系，从而解决问题。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt=""></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p><p>示例 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p><p>进阶：</p><p>你是否可以不用额外空间解决此题？</p><p>原题url：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>在这里贴一下题目所提供的节点结构，这样下面的代码就不重复贴了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Definition for singly-linked list.</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(int x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="利用集合"><a href="#利用集合" class="headerlink" title="利用集合"></a>利用集合</h3><p>拿到题目的时候，一开始想到的就是利用集合，存储已经遍历过的节点，如果访问到 null，说明不是环；如果添加失败，说明已经添加过，那么一定是环，并且该节点就是环的入口；</p><p>顺便说一句，我认为集合所占空间应该不是很大，因为它只是存储对象的应用地址，当然了，集合本身也是一个新的对象，也会占用额外的空间。</p><p>让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode current = head;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加成功，则继续访问下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (set.add(current)) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加不成功，说明重复</span></span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>5 ms</code>，内存消耗：<code>37.7 MB</code>，但是提交用时只战胜了<code>30.99%</code>的 java 提交记录，看来有必要优化一下。</p><h3 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h3><p>以前我们判断链表是否有环，都是通过快慢指针最终是否相等。现在的话，因为环可能并不是首尾相连，所以只找一次可能不够了，需要继续寻找规律。</p><p>我们假设一开始 slow 指针走过的路程为 x，那么 fast 指针走过的路程就为 2x，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = x;</span><br><span class="line">f = 2x;</span><br></pre></td></tr></table></figure></p><p>如果 fast 指针最终为 null，那么说明不是环。</p><p>如果 fast、slow 指针最终指向的节点相等，说明有环，并且， fast 指针比 flow 指针多走了 n 圈环的长度，那么我们假设环的长度为 b，那么可以得出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = x + nb;</span><br></pre></td></tr></table></figure></p><p>可以得出：<code>s = nb;</code></p><p>以上就是最重要的结论了，slow 指针其实也已经走了 n 圈环的长度了。那么，我们再假设从 head 节点到环入口节点的长度为 a，那么从快慢指针相遇节点再走 a 步，最终会走到哪儿呢？</p><p>最终也会走到环的入口节点，因为<code>(nb + a)</code>可以理解为<code>(a + nb)</code>，相当于从 head 节点出发，达到环的入口节点处，又绕环走了 n 圈，所以也会走到环的入口。所以此时我们也找到环的入口节点了。</p><p>接下来让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先利用快慢指针，如果最终能相遇，说明有环</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 快指针为null，说明没有环</span></span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 慢指针移动一步</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 快指针移动两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">// 快慢指针相等，说明相遇</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再用两个指针，一个从头结点出发，一个从相遇点出发，两个指针每次移动1步，两个指针相遇的地方为环的入口</span></span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>1 ms</code>，内存消耗：<code>37.8 MB</code>，但是提交用时只战胜了<code>55.14%</code>的 java 提交记录，难道还有更加高效的方法？</p><p>我找了一个执行用时 0 ms 的代码，发现就是和我这个类似的，我将它的代码再次提交后，发现和我这个提交结果一样。看来那些比我们快的算法，可能是因为提交时间比较早，测试案例并不像现在那么多，所以不必担心了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目不仅要利用快慢指针，还要总结规律，最终也能解决，总的来说是一道很考验逻辑思维的题目。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是找规律，推导出路径之间的关系，从而解决问题。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣139——单词拆分</title>
    <link href="https://www.death00.top/2020/01/03/%E5%8A%9B%E6%89%A3139%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>https://www.death00.top/2020/01/03/力扣139——单词拆分/</id>
    <published>2020-01-03T02:00:00.000Z</published>
    <updated>2020-01-05T03:06:52.526Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是利用动态规划，能够利用上之前的结果，进行优化。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure></p><p>示例 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-break/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>我拿到这道题目时，第一个想到的就是暴力法，从下标0开始，每一个字母都去找，如果找到，就以当前的结尾下标作为下一次的开始下标，继续查找，看起来还是很简单的。</p><p>让我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暴力法，从第一个字母开始尝试，长度递增，如果wordDict中存在，则继续往后找，直到找到最后一个字母</span></span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="keyword">new</span> HashSet&lt;&gt;(wordDict), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s：待查找的字符串</span></span><br><span class="line"><span class="comment">     * wordDict：字典集合</span></span><br><span class="line"><span class="comment">     * start：本次查找开始的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 全部查找完成</span></span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="comment">// 当前单词包含在字典表中，并且一路查下去，都能找到</span></span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end)) &amp;&amp; dfs(s, wordDict, end)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交之后，报<code>超出时间限制</code>，我们分析一下，既然是暴力解法，针对特殊情况，一定效率很低。</p><p>在我们这里，那就是如果原字符串<code>s</code>里包含一连串相同的字母，比如：aaaaaaaaaaaaaaaaaaqqqq，并且字典里有一项就是相匹配的单个字母，比如：a，那么这个递归查找，就会针对每一个下标都去寻找一次，并且一旦失败，在下一次遍历中，又会重新查找一遍。</p><p>这时我们进行复杂度分析：</p><ul><li>时间复杂度为：<code>O(n^n)</code>，其中，n代表原字符串<code>s</code>的长度，此时就是最坏的情况。</li><li>空间复杂度为：<code>O(n)</code>，这代表递归回溯时，最多只会有 n 个调用栈同时存在。</li></ul><h3 id="初步优化——利用之前的结果"><a href="#初步优化——利用之前的结果" class="headerlink" title="初步优化——利用之前的结果"></a>初步优化——利用之前的结果</h3><p>既然上面说每次失败后，都会重新进行查找，并且明显存在重复，那么我们这一次优化的目标，就是尽可能<code>利用之前的结果</code>，那么该如何利用呢？</p><p>因为我们这是在从前向后查找，那么可以想到的就是后缀匹配，也就是利用一个记忆数组，记录每一个节点到最后一个节点是否是可以被查到的，这样在进行第一次遍历的时候，就可以得出一些中间结果，被使用到之后的查找中。</p><p>让我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记忆回溯，增加一个后缀记忆的Boolean数组，当下标i的值为true，说明从i开始可以一直找到最后，这样针对后缀可以避免重复查找</span></span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="keyword">new</span> HashSet&lt;&gt;(wordDict), <span class="number">0</span>, <span class="keyword">new</span> Boolean[s.length()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s：待查找的字符串</span></span><br><span class="line"><span class="comment">     * wordDict：字典集合</span></span><br><span class="line"><span class="comment">     * start：本次查找开始的下标</span></span><br><span class="line"><span class="comment">     * suffixMemoryArray：记忆后缀数组，当下标i的值为true，说明从i开始可以一直找到最后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start, Boolean[] suffixMemoryArray)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 全部查找完成</span></span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从当前start是否可以直接找到最后，不等于null，说明已经查找过了，直接利用之前的结果</span></span><br><span class="line">        <span class="keyword">if</span> (suffixMemoryArray[start] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> suffixMemoryArray[start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="comment">// 当前单词包含在字典表中，并且一路查下去，都能找到</span></span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end)) &amp;&amp; dfs(s, wordDict, end, suffixMemoryArray)) &#123;</span><br><span class="line">                <span class="comment">// 说明从当前start能一直从字典中找完</span></span><br><span class="line">                suffixMemoryArray[start] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        suffixMemoryArray[start] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>6 ms</code>，内存消耗：<code>37 MB</code>，执行用时只战胜了<code>73.92%</code>的 java 提交记录，看来还可以继续优化。</p><p>让我们再看一下复杂度：</p><ul><li>时间复杂度：<code>O(n^2)</code>，因为可以利用之前的结果，最多只是进行双重 for 循环。</li><li>空间复杂度为：<code>O(n)</code>，这个和之前一样的。</li></ul><h3 id="继续优化——后缀改为前缀"><a href="#继续优化——后缀改为前缀" class="headerlink" title="继续优化——后缀改为前缀"></a>继续优化——后缀改为前缀</h3><p>之前用的是后缀记忆，那么能不能用前缀记忆呢？这就相当于把问题拆分，原本的字符串<code>s</code>，拆分为前部分<code>s1</code>和后部分<code>s2</code>，如果<code>s1</code>和<code>s2</code>都能被找到，则说明<code>s</code>能被找到，然后继续拆分。</p><p>将前缀查找过的部分，也记录下来。我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划，将原本的s拆分为s1和s2，如果s1和s2都包含，则认为s是可以的，本质是前缀匹配</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字典集合</span></span><br><span class="line">        Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        <span class="comment">// 后缀记忆，默认prefixMemoryArray[0]是存在于字典中的，因为0代表着空，下标为i时，代表从0到i的字符可以直接或者被拆分后在wordDict中找到</span></span><br><span class="line">        <span class="keyword">boolean</span>[] prefixMemoryArray = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        prefixMemoryArray[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prefixMemoryArray[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    prefixMemoryArray[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prefixMemoryArray[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>7 ms</code>，内存消耗：<code>36.4 MB</code>，执行用时只战胜了<code>56.96%</code>的 java 提交记录，还不如上面那种，只是在空间上有所优化，毕竟将递归改造了一下，看来还可以继续优化。</p><p>让我们再看一下复杂度：</p><ul><li>时间复杂度：<code>O(n^2)</code>，还是和之前一样的。</li><li>空间复杂度为：<code>O(n)</code>，这个和之前一样的。</li></ul><h3 id="最终优化——找出快速失败的条件"><a href="#最终优化——找出快速失败的条件" class="headerlink" title="最终优化——找出快速失败的条件"></a>最终优化——找出快速失败的条件</h3><p>感觉思路上应该没有问题，估计在边界判定时有一些点我们可能还没有看到。</p><p>既然是要在字典集合中存在，那么如果需要查找的字符串太长或太短肯定都不可以，即不可以超过字典里最长的单词，也不可以少于字典里最短的单词。</p><p>针对上面的解法，就是：</p><ul><li>j 的初始值应该是 0 和 (i - max) 中的最大值，因为如果 j 太小，那么后续需要查找的字符串可能太长，那么就没必要找了。</li><li>j 的最大值应该是 (i - j &gt;= min)，因为如果后续需要查找的字符串可能太短，也没必要查找了。</li></ul><p>让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划，将原本的s拆分为s1和s2，如果s1和s2都包含，则认为s是可以的，本质是前缀匹配</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字典集合</span></span><br><span class="line">        Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找出wordDict中最大长度和最小长度</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word.length() &gt; max) &#123;</span><br><span class="line">                max = word.length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (word.length() &lt; min) &#123;</span><br><span class="line">                min = word.length();</span><br><span class="line">            &#125;</span><br><span class="line">            wordDictSet.add(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后缀记忆，默认prefixMemoryArray[0]是存在于字典中的，因为0代表着空，下标为i时，代表从0到i的字符可以直接或者被拆分后在wordDict中找到</span></span><br><span class="line">        <span class="keyword">boolean</span>[] prefixMemoryArray = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        prefixMemoryArray[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果需要查找的长度大于最大值或者小于最小值，就没必要继续找了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = Math.max(<span class="number">0</span>, i - max); i - j &gt;= min; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prefixMemoryArray[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    prefixMemoryArray[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prefixMemoryArray[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>2 ms</code>，内存消耗：<code>34.4 MB</code>，执行用时战胜了<code>97.96%</code>的 java 提交记录，这应该没什么问题了。</p><p>时间复杂度和空间复杂度还是和上面一样，没有本质区别。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目主要利用动态规划，复用之前计算的结果，再找出更加合适的边界条件，快速失败，最终得到比较合适的方案。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是利用动态规划，能够利用上之前的结果，进行优化。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣105——从前序与中序遍历序列构造二叉树</title>
    <link href="https://www.death00.top/2020/01/02/%E5%8A%9B%E6%89%A3105%E2%80%94%E2%80%94%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.death00.top/2020/01/02/力扣105——从前序与中序遍历序列构造二叉树/</id>
    <published>2020-01-02T02:00:00.000Z</published>
    <updated>2020-01-05T03:04:38.163Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是找规律，能否思考出前序遍历、中序遍历与二叉树之间的关系。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure></p><p>返回如下的二叉树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">          /  \</span><br><span class="line">      15   7</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题目，主要就是在于大家对于二叉树这个数据结构的熟悉程度了，根据其前序遍历和中序遍历，推算出原本的二叉树。</p><p>我们想想，如果不是写代码，只是通过手写的话，我们是如何查找的，就用题目给出的例子：</p><ol><li>根据前序遍历，第一个一定是根节点，那么 3 就是根节点。</li><li>从中序遍历中寻找 3，在它左边的，都是其左子树上的节点，在它右边的，都是其右子树上的节点。</li><li>因为中序遍历中，3 的左边只有9，那么 9 就是 3 的左子节点。</li><li>根据前序遍历<code>先根然后左子节点，然后再右子节点</code>的规律，3 、9 之后的 20 一定是 3 的右子节点。</li><li>20 在中序遍历中，其左右两边就是 15 和 7，因此15 和 7 就分别是它的左右子节点。</li></ol><p>根据上面的分析，你就可以画出例子中的二叉树了。</p><p>那么我们寻找的顺序是，先从前序遍历的第一个节点开始，在中序遍历中找出它的位置，其左右两边就是其左右子树了，</p><p>接着从左子树入手，前序遍历根节点之后的两个节点应该就是其左右子树，但需要考虑没有左右子树的情况，然后再以其子树为根，在中序遍历中找其左右子树。</p><p>需要注意的是，只有针对根节点，其左右子节点是在前序遍历中紧跟着根节点的，其他都是有距离的，需要根据左子树递推。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    <span class="comment">// preorder中遍历过的数量，这样找完左子树中的节点，剩下的第一个节点，必然是右子节点</span></span><br><span class="line">    <span class="keyword">int</span> preorderIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// key为inorder中的值，value为inorder中的下标</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; inorderMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (preorder.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">this</span>.inorderMap = <span class="keyword">new</span> HashMap&lt;&gt;(inorder.length * <span class="number">4</span> / <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.inorderMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> generateNode(<span class="number">0</span>, inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找当前节点的左右子节点</span></span><br><span class="line"><span class="comment">     * start：inorder里开始寻找的节点下标</span></span><br><span class="line"><span class="comment">     * end：inorder里终止寻找的节点下标</span></span><br><span class="line"><span class="comment">     * preorderIndex：当前节点在preorder中的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">generateNode</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        <span class="keyword">int</span> value = preorder[preorderIndex];</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">        <span class="comment">// 当前节点的值，在inorder中的下标</span></span><br><span class="line">        <span class="keyword">int</span> inorderIndex = inorderMap.get(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点已经找到，寻找下一个节点。</span></span><br><span class="line">        <span class="comment">// 因为会先去寻找左节点，当该节点左子树中所有节点全部找完后，前序遍历中，剩下节点的第一个节点，一定是该节点的右节点。</span></span><br><span class="line">        preorderIndex++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找左节点</span></span><br><span class="line">        node.left = generateNode(start, inorderIndex);</span><br><span class="line">        <span class="comment">// 寻找右节点</span></span><br><span class="line">        node.right = generateNode(inorderIndex + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>3 ms</code>，内存消耗：<code>40.1 MB</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目主要就是寻找规律，优化的话，可能就是利用 map 构造中序遍历中节点值和顺序的关系。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是找规律，能否思考出前序遍历、中序遍历与二叉树之间的关系。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣96——不同的二叉搜索树</title>
    <link href="https://www.death00.top/2020/01/01/%E5%8A%9B%E6%89%A396%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.death00.top/2020/01/01/力扣96——不同的二叉搜索树/</id>
    <published>2020-01-01T02:00:00.000Z</published>
    <updated>2020-01-05T03:02:57.298Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是找规律，找出递推关系。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3       2      1</span><br><span class="line">    \        /     /      / \      \</span><br><span class="line">     3      2     1      1   3      2</span><br><span class="line">    /      /       \                 \</span><br><span class="line">   2     1         2                  3</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题看到的第一眼，就和之前的格雷编码一样，又想用动态规划，每次都是遍历所有情况去检查是否有效，但感觉时间复杂度会很高，找找看有没有什么更高效的做法。</p><p>所谓高效，也就是寻找规律了，最好的是可以递推，下一次运算可以利用之前的结果，而本题就是用这种规律的。我们来试试 n 等于0、1、2、3的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n = 0，只有1种。</span><br><span class="line"></span><br><span class="line">n = 1，也只有1种。</span><br><span class="line"></span><br><span class="line">n = 2，有2种</span><br><span class="line">1           2</span><br><span class="line"> \         /</span><br><span class="line">   2    1</span><br><span class="line"></span><br><span class="line">n = 3，有5种</span><br><span class="line">   1         3     3      2     1</span><br><span class="line">    \        /     /      / \      \</span><br><span class="line">    3      2     1     1   3      2</span><br><span class="line">    /      /       \                    \</span><br><span class="line">   2     1         2                    3</span><br></pre></td></tr></table></figure></p><p>让我们回想一下什么叫<code>二叉搜索树</code>，就是针对每个节点，其左子树中所有节点都比它小，其右子树中所有节点都比它大。</p><p>再想一下，如果我们针对根选中的情况下，左右子树节点的个数其实也已经定下来了，那么假设同样是 3 个节点，”1、2、3”和”4、5、6”可以组成二叉搜索树，从数量上讲是一样的，因为大小关系没有变。</p><p>因此，我们可以说，针对二叉搜索树，其不用考虑值具体是多少，只需要考虑其大小关系即可，那么这就符合上面我所希望的场景了，下一次的运算可以利用之前的结果。</p><p>以这道题来说，其具体规律就是：</p><ol><li>从 1 开始遍历直至 n，以每个节点作为根节点，这样就能计算出左右各个子树的所有节点数。</li><li>当我们知道了个数，也就可以利用之前计算的结果，获得左右子树可能的情况，两者相乘，也就是在当前根的情况，所有二叉搜索树的情况。</li><li>将所有根节点的总计算出的数量做累加，也就得出了当前节点数的总情况。</li></ol><p>让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 存放中间结果</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="comment">// 左子树总节点数 + 右子树总节点数</span></span><br><span class="line">                count += (result[j - <span class="number">1</span>] * result[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，   执行用时：<code>0 ms</code>，内存消耗：<code>33.2 MB</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目只要利用规律，构造递推关系，也就能解决了。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是找规律，找出递推关系。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="递推" scheme="https://www.death00.top/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>2019年终总结</title>
    <link href="https://www.death00.top/2019/12/31/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://www.death00.top/2019/12/31/2019年终总结/</id>
    <published>2019-12-31T02:00:00.000Z</published>
    <updated>2020-01-05T03:00:50.423Z</updated>
    
    <content type="html"><![CDATA[<p>2019即将过去，2020即将，看看这一年我们做了什么，下一年我们要去做什么<br><a id="more"></a></p><p>2019年终于要过去了，不知道大家过的如何，我感觉2019年对于真的是不一样的一年。</p><p>1、从差不多9月份开始写公众号文章，粉丝数终于在今天突破了100人，这对于我来说真的是一份不小的收获。有一种说法叫”输出倒逼输入”，为了写这些文章，我也是看了不少内容，真的感觉收获满满。</p><p>2、换了一份工作。其实从夏天就在南京面试了不少公司，但一直没有找到合适的，年末又来上海找工作，想着一定要进入大厂，终于在11月份入职携程。南京到上海，换了工作，也换了居住地，希望可以有一个不一样的自己。</p><p>3、对于即将到来的2020，也给自己定下了三个目标：好好工作、学英语、刷力扣。</p><p>“好好工作”是希望能够学习大厂里优秀之处，提高自己解决问题、与人沟通的能力；</p><p>“学英语”是希望自己能在未来找到一份外企的工作；</p><p>“刷力扣”是针对现在的大厂或者外企面试，算法题是绕不开的；</p><p>4、针对公众号，现在开启的力扣系列，也是督促自己不停刷题。同时也希望粉丝数能在2020年底超过300，我这么佛系推广，如果能达到300，也是说明我的文章真的是有一定价值的。这也是我对于自己副业的一种培养，现今社会讲究”斜杠青年”，也是因为如今资本环境不好，裁员屡见不鲜，我们程序员也是该为自己多找几条后路了。</p><p>2019对于我来说是一个新的开始，希望能在2020，我们能够成长为更好的自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019即将过去，2020即将，看看这一年我们做了什么，下一年我们要去做什么&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://www.death00.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>力扣90——子集 II</title>
    <link href="https://www.death00.top/2019/12/31/%E5%8A%9B%E6%89%A390%E2%80%94%E2%80%94%E5%AD%90%E9%9B%86%20II/"/>
    <id>https://www.death00.top/2019/12/31/力扣90——子集 II/</id>
    <published>2019-12-31T02:00:00.000Z</published>
    <updated>2020-01-05T02:58:03.521Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是利用递归，优化的时候需要利用数据结构的特性。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets-ii/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>这道题，针对已经刷了不少题目的我们而言，应该第一想到的就是<code>递归</code>了，从第1个数开始，每次遍历1个数，如果和之前的数相同则跳过，然后以下一个数为起点，继续遍历。让我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 从小到大排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 最终结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        result.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        dfs(<span class="number">0</span>, nums, <span class="keyword">new</span> Stack&lt;&gt;(), result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] nums, Stack&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 在这一次总的查找中，如果当前节点和上一个节点相同，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加该数</span></span><br><span class="line">            stack.push(nums[i]);</span><br><span class="line">            <span class="comment">// 作为一种情况，放进结果中</span></span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(stack));</span><br><span class="line">            <span class="comment">// 继续回溯</span></span><br><span class="line">            dfs(i + <span class="number">1</span>, nums, stack, result);</span><br><span class="line">            <span class="comment">// 回退</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>2 ms</code>，内存消耗：<code>36.5 MB</code>，但执行用时只战胜<code>40.16%</code>，那就来优化一下。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>看了第一眼，我真的不知道该如何优化。我先是想到将递归改成迭代，但感觉并没有从时间上做出优化，不过还是给大家看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从小到大排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 最终结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span> &lt;&lt; nums.length);</span><br><span class="line">        result.add(<span class="number">0</span>, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="comment">// 上一步新解的开始下标</span></span><br><span class="line">        <span class="keyword">int</span> newStartIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历添加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 和上一个数字相同，则只针对上一步的新解增加</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                j = newStartIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> length = result.size();</span><br><span class="line">            newStartIndex = length;</span><br><span class="line">            <span class="keyword">for</span> (;j &lt; length; j++) &#123;</span><br><span class="line">                List&lt;Integer&gt; tempList = result.get(j);</span><br><span class="line">                List&lt;Integer&gt; newList = <span class="keyword">new</span> LinkedList&lt;&gt;(tempList);</span><br><span class="line">                newList.add(nums[i]);</span><br><span class="line">                result.add(newList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交之后，果然不出所料，和之前一样，那就再让我们想想。</p><p>还记得在之前文章中曾经说过，<code>new LinkedList&lt;&gt;(Collection&lt;? extends E&gt; c)</code>其内部依旧是遍历，很耗性能。因此我专门看了一下<code>new ArrayList&lt;&gt;(Collection&lt;? extends E&gt; c)</code>，其内部最终会调用<code>Systemp.arraycopy</code>。让我们再试一次：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 从小到大排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 最终结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        dfs(<span class="number">0</span>, nums, <span class="keyword">new</span> Stack&lt;&gt;(), result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] nums, Stack&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 在这一次总的查找中，如果当前节点和上一个节点相同，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加该数</span></span><br><span class="line">            stack.push(nums[i]);</span><br><span class="line">            <span class="comment">// 作为一种情况，放进结果中</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line">            <span class="comment">// 继续回溯</span></span><br><span class="line">            dfs(i + <span class="number">1</span>, nums, stack, result);</span><br><span class="line">            <span class="comment">// 回退</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交之后，果然OK了，执行用时：<code>1 ms</code>，战胜<code>100%</code>的 java 提交记录。</p><p>我这里再说明一下，LinkedList 的遍历拷贝，每个元素都需要重新计算内存位置，而 ArrayList 的拷贝，可以直接一次性申请一大片空间，写入和遍历的速度会更快。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目只要利用递归就可以解决了，但优化的时候，需要注意数据结构（是不是我之前用一些的 LinkedList 换成 ArrayList 会效果更好呢）。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是利用递归，优化的时候需要利用数据结构的特性。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="递归" scheme="https://www.death00.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣89——格雷编码</title>
    <link href="https://www.death00.top/2019/12/30/%E5%8A%9B%E6%89%A389%E2%80%94%E2%80%94%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"/>
    <id>https://www.death00.top/2019/12/30/力扣89——格雷编码/</id>
    <published>2019-12-30T02:00:00.000Z</published>
    <updated>2020-01-05T02:54:58.657Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是找规律，优化的时候，需要找好边界条件。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,3,2]</span><br><span class="line">解释:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br><span class="line"></span><br><span class="line">对于给定的 n，其格雷编码序列并不唯一。</span><br><span class="line">例如，[0,2,3,1] 也是一个有效的格雷编码序列。</span><br><span class="line"></span><br><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: [0]</span><br><span class="line">解释: 我们定义格雷编码序列必须以 0 开头。</span><br><span class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。</span><br><span class="line">     因此，当 n = 0 时，其格雷编码序列为 [0]。</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/gray-code/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="初始想法"><a href="#初始想法" class="headerlink" title="初始想法"></a>初始想法</h3><p>一开始拿到这题目，我想到的是从0开始，每次从右边第一位开始改变，放入结果集中（集合），如果添加成功，就以当前数为新的起点，继续变化和添加，否则就变化下一位。</p><p>这个想法看似美好，实际有两个需要解决的难点：</p><ol><li>如何保证转化出的二进制，精确修改每一位呢？如果用 for 循环的话，效率很低。</li><li>每次这样改变的话，很可能效率会很低，时间复杂度会很高，如何优化？</li></ol><p>基于以上两点，我稍微尝试了一下，感觉这个方法不靠谱，决定换一个思路。</p><h3 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h3><p>那现在我就来尝试找找规律，自己写写0位、1位、2位、3位的格雷编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0位：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">1位：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">2位：</span><br><span class="line">00</span><br><span class="line">01</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">3位：</span><br><span class="line">000</span><br><span class="line">001</span><br><span class="line">011</span><br><span class="line">010</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">101</span><br><span class="line">100</span><br></pre></td></tr></table></figure></p><p>写完之后，应该能找到以下几个规律：</p><ol><li>第 n 位格雷编码是第 n+1 位格雷编码的子集，意味着可以利用上一次的结果。</li><li>根据2进制来看，每多一位，其实就是在多的那一位置1即可。</li><li>基于第2点，需要做补充，格雷编码是需要考虑顺序的，并不能只是简单置1，应该是针对上一次的结果集倒序输出并在最高位置1。</li></ol><p>上面3个规律，只有最后一个规律，可能比较难找，不过考虑到顺序这个特性，应该也能想出来。接下来我们看一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划，第n种情况是由：第n-1种正序各数字前加0 + 第n-1种倒序各数字前加1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先给出一开始的情况</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        result.add(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 最高位置1，可以理解为增加</span></span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 倒序</span></span><br><span class="line">            Collections.reverse(list);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> item : list) &#123;</span><br><span class="line">                result.add(item + add);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list = <span class="keyword">new</span> LinkedList&lt;&gt;(result);</span><br><span class="line">            add = add &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>3 ms</code>，内存消耗：<code>34.5 MB</code>，但是用时只战胜<code>9.59%</code>的 java 提交记录，看来还是有优化必要的。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我第一眼想到的优化是<code>倒序</code>，我并不需要真的将上一次的结果集真的倒置，而是只要倒序遍历即可。因为我存放的结果集是 LinkedList，可以利用它的<code>descendingIterator</code>，直接进行倒序遍历，其代码是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划，第n种情况是由：第n-1种正序各数字前加0 + 第n-1种倒序各数字前加1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先给出一开始的情况</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        result.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 倒序</span></span><br><span class="line">            Iterator&lt;Integer&gt; descIterator = list.descendingIterator();</span><br><span class="line">            <span class="keyword">while</span> (descIterator.hasNext()) &#123;</span><br><span class="line">                result.add(descIterator.next() + add);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list = <span class="keyword">new</span> LinkedList&lt;&gt;(result);</span><br><span class="line">            add = add &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>2 ms</code>，内存消耗：<code>34.3 MB</code>，但是用时只战胜<code>21.07%</code>的 java 提交记录，看来还可以继续优化。</p><h3 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h3><p>这次我盯上的是<code>list = new LinkedList&lt;&gt;(result);</code>，看起来是1行代码，实际内部利用了<code>addAll</code>方法，还是需要遍历这个结果集。而这里需要定义一个新的结果集是为了记录中间结果，是否真的有必要的呢？</p><p>如果还是利用 LinkedList 结构，还真就需要新建结果集。因为它想获取中间结果，用<code>get(int index)</code>这样的方法，依旧需要遍历。这时候我就想到，可以换一种数据结构<code>ArrayList</code>，这样无论是倒序遍历还是添加，都是只要记录上一次的总数量，就可以达到同样的效果了。接下来让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划，第n种情况是由：第n-1种正序各数字前加0 + 第n-1种倒序各数字前加1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先给出一开始的情况</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tempCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            tempCount = list.size();</span><br><span class="line">            <span class="comment">// 倒序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = tempCount - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                list.add(<span class="number">2</span> * tempCount - j - <span class="number">1</span>, list.get(j) + add);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            add = add &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>1 ms</code>，内存消耗：<code>34.2 MB</code>，用时战胜了<code>97.89%</code>的 java 提交记录，这下应该可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题目的难点主要在于找规律以及之后的优化。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是找规律，优化的时候，需要找好边界条件。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣86——分隔链表</title>
    <link href="https://www.death00.top/2019/12/29/%E5%8A%9B%E6%89%A386%E2%80%94%E2%80%94%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.death00.top/2019/12/29/力扣86——分隔链表/</id>
    <published>2019-12-29T02:00:00.000Z</published>
    <updated>2020-01-05T02:51:43.520Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是处理指针问题的一般思路，利用辅助节点即可。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-list/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>题目很好理解，重点在于区分大于等于和小于目标值的节点，判断其实是很简单的，主要在于如何拼接链表，以及最终如何返回。</p><p>我发现，针对链表拼接的这种题目，常常可以通过添加辅助节点（辅助头结点或者辅助尾结点）来简化拼接操作。</p><p>这道题的话，需要针对两个区间都添加辅助头结点和尾结点，然后利用一个 current 节点进行遍历，扫描到大于等于目标值的节点，添加到相应区间的尾结点，再将尾结点后移；小于目标值的节点，添加到相应区间的尾结点，再将尾结点后移。</p><p>遍历完成后，利用辅助节点将两个区间拼接，再返回。让我们看下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小于x的节点，开始节点和结束节点</span></span><br><span class="line">        ListNode lessStart = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode lessEnd = lessStart;</span><br><span class="line">        <span class="comment">// 大于等于x的节点，开始节点和结束节点</span></span><br><span class="line">        ListNode moreStart = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode moreEnd = moreStart;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 利用current节点扫描</span></span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 小于x的节点</span></span><br><span class="line">            <span class="keyword">if</span> (current.val &lt; x) &#123;</span><br><span class="line">                                <span class="comment">// 添加到相应区间的尾结点，再将尾结点后移</span></span><br><span class="line">                lessEnd.next = current;</span><br><span class="line">                lessEnd = current;</span><br><span class="line">            &#125; </span><br><span class="line">                        <span class="comment">// 大于等于x的节点</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 添加到相应区间的尾结点，再将尾结点后移</span></span><br><span class="line">                moreEnd.next = current;</span><br><span class="line">                moreEnd = current;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将两个区间拼接</span></span><br><span class="line">        lessEnd.next = moreStart.next;</span><br><span class="line">                <span class="comment">// 需要让最终尾结点指向null，因为该尾结点不一定是原链表尾结点，如果指向别的节点，可能会造成循环链表</span></span><br><span class="line">        moreEnd.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 返回现在的头结点</span></span><br><span class="line">        <span class="keyword">return</span> lessStart.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>1 ms</code>，内存消耗：<code>35.9 MB</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。正如上面所说，针对链接这样的题目，可以借用辅助节点，简化拼接过程，方便使用。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是处理指针问题的一般思路，利用辅助节点即可。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="指针" scheme="https://www.death00.top/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>力扣80——删除排序数组中的重复项 II</title>
    <link href="https://www.death00.top/2019/12/28/%E5%8A%9B%E6%89%A380%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20II/"/>
    <id>https://www.death00.top/2019/12/28/力扣80——删除排序数组中的重复项 II/</id>
    <published>2019-12-28T02:00:00.000Z</published>
    <updated>2020-01-04T06:41:33.504Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是要判断好边界情况，和一般的删除重复项不同，它需要保留重复项最多两遍。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [1,1,1,2,2,3],</span><br><span class="line"></span><br><span class="line">函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,1,2,3,3],</span><br><span class="line"></span><br><span class="line">函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>本题比较恶心的地方在于针对重复的数字，可以最多留2个，而并不是全部删除，因此在这点上需要注意。可以用一个专门的变量记录当前数字重复的次数，当重复次数大于2的时候则直接删除该数字，当不同后，再将该变量重置。</p><p>让我们看一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>, current = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 已经出现过的数字before，及其出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> before = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (current &lt; nums.length) &#123;</span><br><span class="line">            <span class="comment">// 相同并且超过2个，则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (nums[current] == before &amp;&amp; times == <span class="number">2</span>) &#123;</span><br><span class="line">                current++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 相同但是不超过2个</span></span><br><span class="line">                        </span><br><span class="line">            <span class="comment">// 如果和之前一个数相同，则增加times</span></span><br><span class="line">            <span class="keyword">if</span> (nums[current] == before) &#123;</span><br><span class="line">                times++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 如果不相同，则重置times</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                times = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 赋值，即拷贝该数到合适的位置</span></span><br><span class="line">            nums[start] = nums[current];</span><br><span class="line">            before = nums[current];</span><br><span class="line">            <span class="comment">// 移动指针</span></span><br><span class="line">            current++;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>1 ms</code>，内存消耗：<code>37.3 MB</code>。应该没什么问题了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。</p><p>这已经是第9篇刷题的文章了，都是 medium 难度，感觉 medium 难度的话，重点关注的是一些边界判断，思考是否严谨，至于算法，还是比较基础的。不知道大家感觉如何。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是要判断好边界情况，和一般的删除重复项不同，它需要保留重复项最多两遍。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣79——单词搜索</title>
    <link href="https://www.death00.top/2019/12/27/%E5%8A%9B%E6%89%A379%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>https://www.death00.top/2019/12/27/力扣79——单词搜索/</id>
    <published>2019-12-27T02:00:00.000Z</published>
    <updated>2020-01-04T06:38:50.221Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是利用递归，优化时考虑失败情况。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = &quot;ABCCED&quot;, 返回 true.</span><br><span class="line">给定 word = &quot;SEE&quot;, 返回 true.</span><br><span class="line">给定 word = &quot;ABCB&quot;, 返回 false.</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-search/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>拿到这题，我一开始想到的方法就是：</p><ul><li>以每一格为起点，开始寻找，寻找的条件是要保证当前的字母和下一个和它连接的字母（上下左右）都符合条件，那么就继续查找。</li><li>只要当前不符合，立刻返回 false，快速失败。</li><li>利用一个二维 boolean 数组记录每一格的使用情况，记住，如果从当前格出发都不成功的话，则需要<code>回退</code>。</li></ul><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 总行数</span></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="comment">// 总列数</span></span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="comment">// 原数组</span></span><br><span class="line">    <span class="keyword">char</span>[][] board;</span><br><span class="line">    <span class="comment">// 需要寻找的字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] wordArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.row = board.length;</span><br><span class="line">        <span class="keyword">this</span>.col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">this</span>.wordArray = word.toCharArray();</span><br><span class="line">        <span class="comment">// 标记每一格是否用过的二维数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 以每一格为起点开始搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>, used)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> index, <span class="keyword">boolean</span>[][] used)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前位置是否符合条件</span></span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != wordArray[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全部找完了</span></span><br><span class="line">        <span class="keyword">if</span> (index == wordArray.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置当前格使用过了</span></span><br><span class="line">        used[x][y] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找上下左右是否有符合下一个的情况</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上一格是否存在并且没有被使用过</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; !used[x - <span class="number">1</span>][y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(x - <span class="number">1</span>, y, index + <span class="number">1</span>, used)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一格是否存在并且没有被使用过</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; row - <span class="number">1</span> &amp;&amp; !used[x + <span class="number">1</span>][y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(x + <span class="number">1</span>, y, index + <span class="number">1</span>, used)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左一格是否存在并且没有被使用过</span></span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span> &amp;&amp; !used[x][y - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(x, y - <span class="number">1</span>, index + <span class="number">1</span>, used)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右一格是否存在并且没有被使用过</span></span><br><span class="line">        <span class="keyword">if</span> (y &lt; col - <span class="number">1</span> &amp;&amp; !used[x][y + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(x, y + <span class="number">1</span>, index + <span class="number">1</span>, used)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上下左右的情况都走完了，因此回退，设置当前格没有使用过</span></span><br><span class="line">        used[x][y] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>19 ms</code>，内存消耗：<code>38.3 MB</code>。从时间上看起来还有不少优化的空间，那该怎么做呢？</p><h3 id="似乎无用的优化"><a href="#似乎无用的优化" class="headerlink" title="似乎无用的优化"></a>似乎无用的优化</h3><p>我看了别人更优的解法，发现思想都是一致的，只是在判断上可能会更加简洁一些，如果是判断快速失败的话，似乎没有什么本质上的区别。我将自己的写法稍微优化了一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 总行数</span></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="comment">// 总列数</span></span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="comment">// 原数组</span></span><br><span class="line">    <span class="keyword">char</span>[][] board;</span><br><span class="line">    <span class="comment">// 需要寻找的字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] wordArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.row = board.length;</span><br><span class="line">        <span class="keyword">this</span>.col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">this</span>.wordArray = word.toCharArray();</span><br><span class="line">        <span class="comment">// 标记每一格是否用过的二维数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 以每一格为起点开始搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>, used)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> index, <span class="keyword">boolean</span>[][] used)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前位置不存在或者使用过，则返回失败</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= row || y &lt; <span class="number">0</span> || y &gt;= col || used[x][y]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前位置是否符合条件</span></span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != wordArray[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全部找完了</span></span><br><span class="line">        <span class="keyword">if</span> (index == wordArray.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置当前格使用过了</span></span><br><span class="line">        used[x][y] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找上下左右是否有符合下一个的情况</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = dfs(x - <span class="number">1</span>, y, index + <span class="number">1</span>, used) || dfs(x + <span class="number">1</span>, y, index + <span class="number">1</span>, used) ||</span><br><span class="line">                        dfs(x, y - <span class="number">1</span>, index + <span class="number">1</span>, used) || dfs(x, y + <span class="number">1</span>, index + <span class="number">1</span>, used);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上下左右的情况都走完了，因此回退，设置当前格没有使用过</span></span><br><span class="line">        used[x][y] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>5 ms</code>，内存消耗：<code>38.4 MB</code>。用时上少了很多，应该在于判断上：</p><ul><li>针对位置是否存在的判断，之前的写法是判断下一个位置是否存在，分散在四个 if 判断中，现在是写在一个里面，用于判断当前位置。</li><li>寻找上下左右时，因为逻辑运算<code>||</code>是支持<code>短路</code>的，所以和之前分在四个 if 中效果是差不多的，但看起来更加简洁。</li></ul><p>好吧，其实我自己也没有看懂为什么这样写时间上会减少，大家如果知道的话，欢迎在下方留言。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要就是<code>回溯</code>，针对边界情况需要注意，应该就没有其他问题了。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是利用递归，优化时考虑失败情况。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="递归" scheme="https://www.death00.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣77——组合</title>
    <link href="https://www.death00.top/2019/12/26/%E5%8A%9B%E6%89%A377%E2%80%94%E2%80%94%E7%BB%84%E5%90%88/"/>
    <id>https://www.death00.top/2019/12/26/力扣77——组合/</id>
    <published>2019-12-26T02:00:00.000Z</published>
    <updated>2020-01-04T06:36:00.468Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要利用栈就可以解决，优化时需要考虑那些失败情况。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="递归获取"><a href="#递归获取" class="headerlink" title="递归获取"></a>递归获取</h3><p>一开始的想法就是遍历递归获取，利用一个 stack 存储中间结果，不断进行出栈入栈，这样肯定就能拿全。</p><p>让我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, stack, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> remain, <span class="keyword">int</span> index, Stack&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= n; i++) &#123;</span><br><span class="line">                        <span class="comment">// 加入stack中</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">                        <span class="comment">// 是否加到k个数</span></span><br><span class="line">            <span class="keyword">if</span> (remain - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(stack));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dfs(n, remain - <span class="number">1</span>, i + <span class="number">1</span>, stack, result);</span><br><span class="line">            &#125;</span><br><span class="line">                        <span class="comment">// 将数从stack中拿出</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>73 ms</code>，内存消耗：<code>44 MB</code>。是否还可以优化呢？</p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>今天看到了一个词<code>剪枝</code>，其实这个词是<code>回溯剪枝</code>，<code>回溯</code>大家都懂，<code>剪枝</code>其实就是一种优化，减少<code>回溯</code>中不需要的情况。</p><p>从上面的代码可以看出，在<code>回溯</code>中的遍历，并不需要一直遍历到 n。比如：从 7 个数中取 4 个数，开始的时候遍历到 4 就足够了，因为从 5 开始凑不齐 4 个数，之后的遍历也是同样如此。</p><p>明知失败的事不需要一直进行到最后，和<code>快速失败</code>有些类似，接下来看看优化后的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, stack, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> remain, <span class="keyword">int</span> index, Stack&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 当剩余没有遍历的数，比还需要遍遍历的数少时，也可以不用继续了。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= n &amp;&amp; (n - i + <span class="number">1</span> &gt;= remain); i++) &#123;</span><br><span class="line">                        <span class="comment">// 加入stack中</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">                        <span class="comment">// 是否加到k个数</span></span><br><span class="line">            <span class="keyword">if</span> (remain - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(stack));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dfs(n, remain - <span class="number">1</span>, i + <span class="number">1</span>, stack, result);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码更改极少，我们看看结果：执行用时：<code>5 ms</code>，内存消耗：<code>40.7 MB</code>。</p><p>看似很小的变化，但效果却很好，看来这些细节确实是需要注意的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要教会了需要<code>剪枝</code>，找到边界情况，边界找的更细，那么需要执行的时间也可能会越少。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要利用栈就可以解决，优化时需要考虑那些失败情况。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="栈" scheme="https://www.death00.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>力扣75——颜色分类</title>
    <link href="https://www.death00.top/2019/12/25/%E5%8A%9B%E6%89%A375%E2%80%94%E2%80%94%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <id>https://www.death00.top/2019/12/25/力扣75——颜色分类/</id>
    <published>2019-12-25T02:00:00.000Z</published>
    <updated>2020-01-04T06:34:03.036Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要在于空间复杂度的优化，利用指针，可以完成这一点。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:</p><p>不能使用代码库中的排序函数来解决这道题。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure></p><p>进阶：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 一个直观的解决方案是使用计数排序的两趟扫描算法。</span><br><span class="line">首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</span><br><span class="line">* 你能想出一个仅使用常数空间的一趟扫描算法吗？</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="两趟扫描"><a href="#两趟扫描" class="headerlink" title="两趟扫描"></a>两趟扫描</h3><p>我当时想到的第一种想法就是排序，后来感觉没有必要，因为只有3种元素，我完全就可以按照<code>进阶</code>提示中的第一条，先扫描统计出各元素个数，然后第二遍扫描时，直接进行赋值。</p><p>让我们直接来看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录0,1,2的个数</span></span><br><span class="line">        <span class="keyword">int</span> num0 = <span class="number">0</span>, num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算各个数字出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">switch</span>(i) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    num0++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    num1++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    num2++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; num0) &#123;</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; num0 + num1) &#123;</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>0 ms</code>，内存消耗：<code>35.2 MB</code>。是否还可以优化呢？</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>参考<code>进阶</code>提示中的第二条，上面的方法使用了常数空间，但一遍扫描该如何做到呢？</p><p>我其实并没有想出来，参考了别人的解法：<code>利用三个指针进行一次遍历并交换</code>。</p><p>具体来说，就是增加一个当前指针<code>current</code>（从下标0开始）、一个指向数字0区间的末尾指针<code>p0</code>（从下标0开始）、一个指向数字2区间的开始指针<code>p2</code>（从下标 nums.length - 1）。下标0 到下标 p0 之间存放数字0，下标 p0 到 p2 之间存放数字1，下标 p2 到 下标 (nums.length - 1) 之间存放数字2。current 指针从下标0开始遍历，如果值为0，则和 p0 交换，如果值为2，则和 p2 交换。</p><p>让我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用3个指针current、p0、p2</span></span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>, p0 = <span class="number">0</span>, p2 = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (current &lt;= p2) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前值为1，current指针往后移动</span></span><br><span class="line">            <span class="keyword">if</span> (nums[current] == <span class="number">1</span>) &#123;</span><br><span class="line">                current++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">// 如果当前值为0，则和 p0 交换，p0指针往后移动</span></span><br><span class="line">            <span class="keyword">if</span> (nums[current] == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[current] = nums[p0];</span><br><span class="line">                nums[p0] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 因为p0一开始和current相同</span></span><br><span class="line">                <span class="keyword">if</span> (p0 == current) &#123;</span><br><span class="line">                    current++;</span><br><span class="line">                &#125;</span><br><span class="line">                p0++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前值为2，则和 p2 交换，p2指针往前移动</span></span><br><span class="line">            <span class="keyword">if</span> (nums[current] == <span class="number">2</span>) &#123;</span><br><span class="line">                nums[current] = nums[p2];</span><br><span class="line">                nums[p2] = <span class="number">2</span>;</span><br><span class="line">                p2--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>0 ms</code>，内存消耗：<code>35 MB</code>。这结果，感觉好像没有多少优化，但对于我们而言，最重要的是增加了一种解题思路。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要在于<code>利用指针</code>一遍扫描得出结果，优化解题。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要在于空间复杂度的优化，利用指针，可以完成这一点。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="指针" scheme="https://www.death00.top/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>力扣74——搜索二维矩阵</title>
    <link href="https://www.death00.top/2019/12/24/%E5%8A%9B%E6%89%A374%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>https://www.death00.top/2019/12/24/力扣74——搜索二维矩阵/</id>
    <published>2019-12-24T02:00:00.000Z</published>
    <updated>2020-01-04T06:31:18.167Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是利用二分查找，将矩阵做变换进行优化。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-a-2d-matrix/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>既然是已经排好序的，那么我第一想到的就是<code>二分查找</code>了。每次进行对半查找，时间复杂度<code>O(log(mn))</code>，应该还是很高效。</p><p>我准备将查找分成两部分，第一是<code>二分查找</code>找到 target 在哪一行，然后从那一行再利用<code>二分查找</code>找到 target 在这一行的哪个位置。</p><p>让我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总行数</span></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="comment">// 总列数</span></span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        row = matrix.length;</span><br><span class="line">        col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 利用二分法查询</span></span><br><span class="line">        <span class="keyword">return</span> binarySearchMatrix(matrix, <span class="number">0</span>, matrix.length - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 查找这是矩阵的哪一行</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">binarySearchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] array = matrix[left];</span><br><span class="line">            <span class="keyword">if</span> (target &lt; array[<span class="number">0</span>] || target &gt; array[col - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 从数据中心查找</span></span><br><span class="line">            <span class="keyword">return</span> binarySearchArray(array, <span class="number">0</span>, col - <span class="number">1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] middleArray = matrix[middle];</span><br><span class="line">        <span class="keyword">if</span> (middleArray[<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearchMatrix(matrix, left, middle - <span class="number">1</span>, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middleArray[col - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearchMatrix(matrix, middle + <span class="number">1</span>, right, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearchArray(middleArray, <span class="number">0</span>, col - <span class="number">1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 查找这是数组中的哪个位置</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">binarySearchArray</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> array[left] == target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[middle] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearchArray(array, left, middle - <span class="number">1</span>, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[middle] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearchArray(array, middle + <span class="number">1</span>, right, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，其执行用时：<code>1 ms</code>，内存消耗：<code>38.3 MB</code>。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>虽然解题成功，且效果不错，但总感觉这样写的太过。因为我将二维数组的查找分为两种情况，如果以后变成三维、四维数组，岂不是代码更长？其实这种查找都是利用的同一种思想——二分查找，那我们是否可以将其进行合并呢？</p><p>可以的，我们可以将二维数组<code>拉长</code>。拉成1层后，就可以直接用一维数组中的二分查找了。</p><p>让我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 将二维数组拉成一维数组，利用二分法解决</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix.length * col - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 计算中间数的下标和值</span></span><br><span class="line">            <span class="keyword">int</span> middleIndex = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> middleVal = matrix[middleIndex / col][middleIndex % col];</span><br><span class="line">            <span class="keyword">if</span> (middleVal == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (middleVal &lt; target) &#123;</span><br><span class="line">                left = middleIndex + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = middleIndex - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，其执行用时：<code>0 ms</code>，内存消耗：<code>40.9 MB</code>。</p><p>大家知道这多余的内存消耗在哪儿呢？按道理说，跟前面的方法相比，这里不涉及递归，理论上其调用栈更少，内存消耗应该更少才对。如果大家知道的话，可以在下方评论，我将感激不尽。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题应该主要就是涉及到<code>二分查找</code>，然后加一些优化，应该就没有问题了。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是利用二分查找，将矩阵做变换进行优化。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="二分查找" scheme="https://www.death00.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>力扣73——矩阵置零</title>
    <link href="https://www.death00.top/2019/12/23/%E5%8A%9B%E6%89%A360%E2%80%94%E2%80%94%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>https://www.death00.top/2019/12/23/力扣60——第k个排列/</id>
    <published>2019-12-23T02:00:00.000Z</published>
    <updated>2020-01-04T06:29:26.738Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是找规律，考虑好边界情况。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;123&quot;</span><br><span class="line">2. &quot;132&quot;</span><br><span class="line">3. &quot;213&quot;</span><br><span class="line">4. &quot;231&quot;</span><br><span class="line">5. &quot;312&quot;</span><br><span class="line">6. &quot;321&quot;</span><br></pre></td></tr></table></figure></p><p>给定 n 和 k，返回第 k 个排列。</p><p>说明：</p><ul><li>给定 n 的范围是 [1, 9]。</li><li>给定 k 的范围是[1,  n!]。</li></ul><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 3, k = 3</span><br><span class="line">输出: &quot;213&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 4, k = 9</span><br><span class="line">输出: &quot;2314&quot;</span><br></pre></td></tr></table></figure></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>按照题目所描述的，其实就是按照排列规律，找出相应的数字。</p><p>每一位上可以存在的可能数字范围逐渐减少，因此我们需要记录一下<code>当前用过哪些数字</code>。</p><p>每一位上前缀数字最终对应的可能性也是一个全排列，比如 n 为4时，当第1位定下来一个数字，其对应的所有数字组合有 3!，当第2位定下来后，其对应的数字组合就是2!。当你确认的数字越多，其组合也越少。</p><p>直接上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前数字是否用过，默认为false，代表没有用过</span></span><br><span class="line">    <span class="keyword">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> all = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">            all *= i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = dfs(n, all, k);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n:当前还剩几个数字没有添加</span></span><br><span class="line"><span class="comment">     * all:为了计算出当前数字属于第几组，例如n等于5时，all是4!，这样k/n就知道是第几组了</span></span><br><span class="line"><span class="comment">     * k:所求结果是当前组的第几个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> all, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 组内偏移量</span></span><br><span class="line">        <span class="keyword">int</span> offset = k % all;</span><br><span class="line">        <span class="comment">// 当前是第几组</span></span><br><span class="line">        <span class="keyword">int</span> groupIndex = k / all + (offset == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前没有被访问过的数字里，找第groupIndex个数字</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; used.length &amp;&amp; groupIndex &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                groupIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用当前数字</span></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder().append(i);</span><br><span class="line">        <span class="comment">// 标记当前数字已经用过</span></span><br><span class="line">        used[i - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明是最后一个数字</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 确认一位数字后，其对应的可能性就在减少</span></span><br><span class="line">        <span class="keyword">return</span> result.append(dfs(n - <span class="number">1</span>, all / (n - <span class="number">1</span>), (offset == <span class="number">0</span> ? all : offset)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行用时：<code>2ms</code>，内存消耗：<code>34.4MB</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题应该主要就是找规律了，确认好边界情况就应该没什么问题。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是找规律，考虑好边界情况。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣64——最小路径和</title>
    <link href="https://www.death00.top/2019/12/22/%E5%8A%9B%E6%89%A364%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://www.death00.top/2019/12/22/力扣64——最小路径和/</id>
    <published>2019-12-22T02:00:00.000Z</published>
    <updated>2020-01-04T06:27:27.515Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要就是找规律，逆向思考，进行优化。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="错误的正向思路"><a href="#错误的正向思路" class="headerlink" title="错误的正向思路"></a>错误的正向思路</h3><p>我一开始的想法是正向思路，从起点开始，每个点都有两种后续走法——向下或者向右，当然其中需要判断是否可以向下或者向右以及到达终点就停止。我想到的优化是当走到终点后，将当前走过的路径和记录下来，找出最小值，别的路径上在走的时候，如果比当前最小和大，就没必要继续了。</p><p>来看看我的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> min = Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        map = grid;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">long</span> sum)</span> </span>&#123;</span><br><span class="line">        sum += Long.valueOf(map[x][y]);</span><br><span class="line">        <span class="comment">// 如果已经大于等于当前的最小值，那么就没有必要继续走了</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= min) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否到达终点</span></span><br><span class="line">        <span class="keyword">if</span> (x == map.length - <span class="number">1</span> &amp;&amp; y == map[x].length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; min) &#123;</span><br><span class="line">                min = sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否可以向右</span></span><br><span class="line">        <span class="keyword">if</span> (y &lt; map[x].length - <span class="number">1</span>) &#123;</span><br><span class="line">            dfs(x, y + <span class="number">1</span>, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否可以向下</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; map.length - <span class="number">1</span>) &#123;</span><br><span class="line">            dfs(x + <span class="number">1</span>, y, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>感觉很理想，然而现实是超时了，确实效率不高，除了第一列和第一行的点，其他点都有可能存在重复计算的可能。</p><h3 id="逆向思路"><a href="#逆向思路" class="headerlink" title="逆向思路"></a>逆向思路</h3><p>既然正向不行，那咋们就逆向，从终点出发，以终点为起点，计算当前点到终点的最小值，最后推算出到达起点的最小值（这也是我看了别人的解法才知道的，看来自己的思路果然有问题）。这样就能保证每个点只计算一次，时间效率就是O(m * n)，看起来就高效多了。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从终点开始找起，算当前节点到终点的最小值</span></span><br><span class="line">        <span class="keyword">int</span> right, down;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = grid.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = grid[i].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">// 如果是终点，则保持不变</span></span><br><span class="line">                <span class="keyword">if</span> (i == grid.length - <span class="number">1</span> &amp;&amp; j == grid[i].length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果没有右节点</span></span><br><span class="line">                <span class="keyword">if</span> (j == grid[i].length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 那么就设置当前节点的值加上下节点的值</span></span><br><span class="line">                    grid[i][j] += grid[i + <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果没有下节点</span></span><br><span class="line">                <span class="keyword">if</span> (i == grid.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 那么就设置当前节点的值加上右节点的值</span></span><br><span class="line">                    grid[i][j] += grid[i][j + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果下节点和右节点都有的话，则加上其中较小的那个</span></span><br><span class="line">                grid[i][j] += grid[i + <span class="number">1</span>][j] &lt; grid[i][j + <span class="number">1</span>] ? grid[i + <span class="number">1</span>][j] : grid[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OK，通过了，执行用时：<code>3ms</code>，内存消耗：<code>39.5MB</code>。</p><p>核心思想就是：</p><blockquote><p>从终点出发，每个点到终点的最小值 = 每个点当前的值 + Min(该点下一个点值, 该点右一个点)。</p></blockquote><p>你想想，是否是如此呢？</p><p>既然知道了反向思路，我们可以优化一下我们之前的正向思路解法。</p><h3 id="优化正向思路"><a href="#优化正向思路" class="headerlink" title="优化正向思路"></a>优化正向思路</h3><p>之前的超时，是因为每个点可能会被计算多次，那么我们如果计算出，从起点出发，到每个节点的最小值，最终计算到终点，也应该是终点的最小值，你想想是不是这样呢？</p><p>来看看代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从起点开始找起，算当前节点到起点的最小值 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总行数</span></span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="comment">// 总列数</span></span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 左节点和上节点计算出的最小值</span></span><br><span class="line">        <span class="keyword">int</span> left, up;</span><br><span class="line">        <span class="comment">// 遍历并计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="comment">// 起点不计算</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果没有左节点</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 就设置当前节点的值加上节点</span></span><br><span class="line">                    grid[i][j] += grid[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果没有上节点</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 就设置当前节点的值加上左节点</span></span><br><span class="line">                    grid[i][j] += grid[i][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果左节点和上节点都存在，就加上其中最小的值</span></span><br><span class="line">                grid[i][j] += (grid[i][j - <span class="number">1</span>] &lt; grid[i - <span class="number">1</span>][j] ? grid[i][j - <span class="number">1</span>] : grid[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grid[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OK，也通过了，执行用时：<code>3ms</code>，内存消耗：<code>42.4MB</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。算法本来就是就是在做优化，如何能比之前更好更合适，就是优化了。希望能与大家共同进步。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要就是找规律，逆向思考，进行优化。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣71——简化路径</title>
    <link href="https://www.death00.top/2019/12/21/%E5%8A%9B%E6%89%A371%E2%80%94%E2%80%94%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.death00.top/2019/12/21/力扣71——简化路径/</id>
    <published>2019-12-21T02:00:00.000Z</published>
    <updated>2020-01-04T06:23:24.823Z</updated>
    
    <content type="html"><![CDATA[<p>这应该是一个比较基础的题目，利用基本数据结构——栈，应该就够了。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</p><p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</span><br></pre></td></tr></table></figure></p><p>示例 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure></p><p>示例 4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br></pre></td></tr></table></figure></p><p>示例 5：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/a/../../b/../c//.//&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br></pre></td></tr></table></figure></p><p>示例 6：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;/a//b////c/d//././/..&quot;</span><br><span class="line">输出：&quot;/a/b/c&quot;</span><br></pre></td></tr></table></figure></p><p>原题url:<a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/simplify-path/</a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>看起也不难，但一开始我拿到的时候也是无从下手。</p><h3 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h3><p>看到<code>..</code>的逻辑就特别容易让人想到后退，而记录后退最方便的数据结构应该就是<code>栈</code>了。至于<code>.</code>就可以想象成可以忽略的内容，而<code>/</code>则可以作为分隔符了，来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储路径</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 分隔</span></span><br><span class="line">        String[] array = path.split(<span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : array) &#123;</span><br><span class="line">                        <span class="comment">// 忽略</span></span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">""</span>) || str.equals(<span class="string">"."</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 后退</span></span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">".."</span>)) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 需要存储的内容</span></span><br><span class="line">            stack.push(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String str : stack) &#123;</span><br><span class="line">            sb.append(<span class="string">"/"</span>).append(str);</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// 如果内容为空，则需要输出"/"</span></span><br><span class="line">        <span class="keyword">if</span> (sb.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"/"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起来很美好，提交之后报错了。说是<code>stack.push(str);</code>这行抛出了异常<code>java.util.EmptyStackException</code>，确实，如果栈为空，依旧还是需要在最顶层的（看来还是没有把问题想全面）。让我们来优化一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储路径</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 分隔</span></span><br><span class="line">        String[] array = path.split(<span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : array) &#123;</span><br><span class="line">                        <span class="comment">// 忽略</span></span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">""</span>) || str.equals(<span class="string">"."</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 后退</span></span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">".."</span>)) &#123;</span><br><span class="line">                            <span class="comment">// 判断是否为空，不为空，才需要回退</span></span><br><span class="line">                <span class="keyword">if</span> (!stack.empty()) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                                <span class="comment">// 无论stack空不空，都需要结束</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stack.push(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String str : stack) &#123;</span><br><span class="line">            sb.append(<span class="string">"/"</span>).append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sb.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"/"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OK，通过了，执行用时：<code>6ms</code>，内存消耗：<code>36.2MB</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。因为之前已经刷了一些题目了，所以会把这些解题过程都补上去，也当做复习了。我刷题都是选 medium 的，所以不会很难，主要我看外企的面试大多也是以这样的题目为主，刷 hard 的题目确实感觉太费脑子，打击积极性。希望能与大家共同进步。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这应该是一个比较基础的题目，利用基本数据结构——栈，应该就够了。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="栈" scheme="https://www.death00.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>力扣73——矩阵置零</title>
    <link href="https://www.death00.top/2019/12/20/%E5%8A%9B%E6%89%A373%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
    <id>https://www.death00.top/2019/12/20/力扣73——矩阵置零/</id>
    <published>2019-12-20T02:00:00.000Z</published>
    <updated>2020-01-04T06:21:49.372Z</updated>
    
    <content type="html"><![CDATA[<p>准备开一个力扣解题的系列，督促自己每天刷题，就从今天开始。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>进阶:</p><ul><li>一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。</li><li>你能想出一个常数空间的解决方案吗？</li></ul><p>原题url:<a href="https://leetcode-cn.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/set-matrix-zeroes/</a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>其实题目本身不难，只要判断出哪些数字是0，将其所在行和列记录一下， 最终全部置0即可，关键在于你所需要消耗的空间是多少。</p><h3 id="用一个数字"><a href="#用一个数字" class="headerlink" title="用一个数字"></a>用一个数字</h3><p>首先我想到的是用一个数字进行表示，用二进制表示，一共<code>m + n</code>位，其中前<code>m</code>位表示行，后<code>n</code>位表示列，矩阵中哪个数字为0，则其行列所在位的数字为1，也就是加上相应的二进制数。为了不重复添加，可以用<code>&amp;</code>进行判断。来看看代码是什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转化为二进制后，前m位表示列，后n位表示行</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第j列是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">int</span> num = <span class="number">1</span> &lt;&lt; (matrix.length + j);</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; num) != num) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有，则加上</span></span><br><span class="line">                    temp += num;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第i行是否已经被设置为0</span></span><br><span class="line">                num = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; num) != num) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有，则加上</span></span><br><span class="line">                    temp += num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 第j列是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">int</span> numCol = <span class="number">1</span> &lt;&lt; (matrix.length + j);</span><br><span class="line">                <span class="comment">// 第i行是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">int</span> numRow = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; numRow) == numRow || (temp &amp; numCol) == numCol) &#123;</span><br><span class="line">                    <span class="comment">// 如果有，则设置当前值为0</span></span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>理论上没什么问题，提交之后报错。当<code>m</code>和<code>n</code>很大时，数字会很大，这个时候<code>temp</code>会越界。我想着是不是求2的幂用<code>Math.pow()</code>，并且 temp 的类型改为 long ，是不是就可以了，说干就干：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转化为二进制后，前m位表示列，后n位表示行</span></span><br><span class="line">        <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第j列是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">long</span> num = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, matrix.length + j);</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; num) != num) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有，则加上</span></span><br><span class="line">                    temp += num;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第i行是否已经被设置为0</span></span><br><span class="line">                num = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, i);</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; num) != num) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有，则加上</span></span><br><span class="line">                    temp += num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 第j列是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">long</span> numCol = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, matrix.length + j);</span><br><span class="line">                <span class="comment">// 第i行是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">long</span> numRow = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, i);</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; numRow) == numRow || (temp &amp; numCol) == numCol) &#123;</span><br><span class="line">                    <span class="comment">// 如果有，则设置当前值为0</span></span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好吧，依然不可以，看来确实很大，最终还是溢出变成负数了。看来得另寻他法了。</p><h3 id="利用矩阵本身"><a href="#利用矩阵本身" class="headerlink" title="利用矩阵本身"></a>利用矩阵本身</h3><p>如果1个数字不够，那么多来几个数字应该也是不够用的，而且如果用的太多也可能会增长到<code>m + n</code>，空间依旧比较多。这个时候我也想不出来，看了看别人的解法，让我顿时领悟——利用矩阵本身。</p><p>就是利用矩阵的第一行和第一列来记录需要置零的行和列，至于第一行和第一列是否需要置零，则可以单独拿两个 boolean 对象来表示。（怎么好的思路，为啥我就是没想到呢）来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用第一行和第一列表示当前行和当前列是否需要置0</span></span><br><span class="line">        <span class="comment">// 单独计算第一行和第一列是否需要置0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 第一行是否需要置0</span></span><br><span class="line">        <span class="keyword">boolean</span> row0 = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) &#123;</span><br><span class="line">                row0 = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一列是否需要置0</span></span><br><span class="line">        <span class="keyword">boolean</span> col0 = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                col0 = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断每一行每一列是否需要置0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行是否需要都置0</span></span><br><span class="line">        <span class="keyword">if</span> (row0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一列是否需要都置0</span></span><br><span class="line">        <span class="keyword">if</span> (col0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>终于通过了，执行用时：<code>2ms</code>，内存消耗：<code>43.5MB</code>。那么是否可以继续优化呢？</p><h3 id="利用矩阵本身-优化"><a href="#利用矩阵本身-优化" class="headerlink" title="利用矩阵本身 优化"></a>利用矩阵本身 优化</h3><p>首先，需要第一行和第一列都判断一遍的吗？可以只判断其中一个即可，比如只判断第一列是否需要置零，那么第一行是否需要置零就可以依赖<code>matrix[0][0]</code>了。在置零的时候，也是将第一列单独判断即可。</p><p>需要注意的是，置零操作需要从后往前，因为<code>matrix[0][0]</code>会有双重含义，所以最后判断即可。来看看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一列是否需要置零</span></span><br><span class="line">        <span class="keyword">boolean</span> col0 = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要置零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果第一列不需要置零，并且第一列有数字是0，则col0设置为true</span></span><br><span class="line">            <span class="keyword">if</span> (!col0 &amp;&amp; matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                col0 = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 置零，从后往前开始，因为如果从前往后，第一行如果因为第一列置为0，会对之后结果误导</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 第一列不动</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一列置零</span></span><br><span class="line">            <span class="keyword">if</span> (col0) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。我准备把我刷力扣的过程记录下来，作为这个系列的内容，希望能和大家多多分享。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准备开一个力扣解题的系列，督促自己每天刷题，就从今天开始。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal的进化——TransmittableThreadLocal</title>
    <link href="https://www.death00.top/2019/12/15/ThreadLocal%E7%9A%84%E8%BF%9B%E5%8C%96%E2%80%94%E2%80%94TransmittableThreadLocal/"/>
    <id>https://www.death00.top/2019/12/15/ThreadLocal的进化——TransmittableThreadLocal/</id>
    <published>2019-12-15T02:00:00.000Z</published>
    <updated>2020-01-04T02:48:10.127Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中，我们谈到了 InheritableThreadLocal，它解决了 ThreadLocal 针对父子线程无法共享<code>上下文</code>的问题。但我们可能听说过阿里的开源产品<code>TransmittableThreadLocal</code>，那么它又是做什么的呢？<br><a id="more"></a></p><h2 id="线程池中的共享"><a href="#线程池中的共享" class="headerlink" title="线程池中的共享"></a>线程池中的共享</h2><p>我们在多线程中，很少会直接 new 一个线程，更多的可能是利用线程池处理任务，那么利用 InheritableThreadLocal 可以将生成任务线程的上下文传递给执行任务的线程吗？废话不多说，直接上代码测试一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Context&gt; context = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 固定线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        <span class="comment">// 生成任务的线程对context进行赋值</span></span><br><span class="line">                        Context contextMain = <span class="keyword">new</span> Context();</span><br><span class="line">                        contextMain.name = String.format(<span class="string">"Thread%s name"</span>, finalI);</span><br><span class="line">                        contextMain.value = finalI * <span class="number">20</span>;</span><br><span class="line">                        InheritableThreadLocalContext.context.set(contextMain);</span><br><span class="line">                        <span class="comment">// 提交任务</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Thread"</span> + finalI + <span class="string">" produce task "</span> + (finalI * <span class="number">20</span> + j));</span><br><span class="line">                            executorService.execute(() -&gt; &#123;</span><br><span class="line">                                <span class="comment">// 执行任务的子线程</span></span><br><span class="line">                                Context contextChild = InheritableThreadLocalContext.context.get();</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">" execute task, name : "</span> + contextChild.name + <span class="string">" value : "</span> + contextChild.value);</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">            ).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们希望的结果是，子线程输出的内容能够和父线程对应上。然而，实际的结果却出乎所料，我将结果整理一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Thread1 produce task 21</span><br><span class="line">// 省略8行</span><br><span class="line">Thread1 produce task 30</span><br><span class="line"></span><br><span class="line">Thread2 produce task 41</span><br><span class="line">// 省略8行</span><br><span class="line">Thread2 produce task 50</span><br><span class="line">pool-1-thread-1 execute task, name : Thread2 name value : 40</span><br><span class="line">// 省略47行</span><br><span class="line">pool-1-thread-1 execute task, name : Thread2 name value : 40</span><br><span class="line"></span><br><span class="line">Thread3 produce task 61</span><br><span class="line">// 省略8行</span><br><span class="line">Thread3 produce task 70</span><br><span class="line"></span><br><span class="line">Thread4 produce task 81</span><br><span class="line">// 省略8行</span><br><span class="line">Thread4 produce task 90</span><br><span class="line"></span><br><span class="line">Thread5 produce task 101</span><br><span class="line">// 省略8行</span><br><span class="line">Thread5 produce task 110</span><br><span class="line"></span><br><span class="line">Thread6 produce task 121</span><br><span class="line">// 省略8行</span><br><span class="line">Thread6 produce task 130</span><br><span class="line"></span><br><span class="line">Thread7 produce task 141</span><br><span class="line">// 省略8行</span><br><span class="line">Thread7 produce task 150</span><br><span class="line">pool-1-thread-2 execute task, name : Thread7 name value : 140</span><br><span class="line">// 省略6行</span><br><span class="line">pool-1-thread-2 execute task, name : Thread7 name value : 140</span><br><span class="line"></span><br><span class="line">Thread8 produce task 161</span><br><span class="line">// 省略8行</span><br><span class="line">Thread8 produce task 170</span><br><span class="line"></span><br><span class="line">Thread9 produce task 181</span><br><span class="line">// 省略8行</span><br><span class="line">Thread9 produce task 190</span><br><span class="line">pool-1-thread-4 execute task, name : Thread9 name value : 180</span><br><span class="line">pool-1-thread-4 execute task, name : Thread9 name value : 180</span><br><span class="line"></span><br><span class="line">Thread10 produce task 201</span><br><span class="line">// 省略8行</span><br><span class="line">Thread10 produce task 210</span><br><span class="line">pool-1-thread-3 execute task, name : Thread10 name value : 200</span><br><span class="line">// 省略39行</span><br><span class="line">pool-1-thread-3 execute task, name : Thread10 name value : 200</span><br></pre></td></tr></table></figure></p><p>虽然生产总数和消费总数都是100，但是明显有的消费多了，有的消费少了。合理推测一下，应该是在主线程放进任务后，子线程才生成。为了验证这个猜想，将线程池用 ThreadPoolExecutor 生成，并在用子线程生成任务之前，先赋值 context 并开启所有线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 固定线程池</span></span><br><span class="line">    ThreadPoolExecutor executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">4</span>,</span><br><span class="line">            <span class="number">4</span>,</span><br><span class="line">            <span class="number">0L</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;() );</span><br><span class="line">    <span class="comment">// 在main线程中赋值</span></span><br><span class="line">    Context context = <span class="keyword">new</span> Context();</span><br><span class="line">    context.name = <span class="string">"Thread0 name"</span>;</span><br><span class="line">    context.value = <span class="number">0</span>;</span><br><span class="line">    InheritableThreadLocalContext.context.set(context);</span><br><span class="line">    <span class="comment">// 开启所有线程</span></span><br><span class="line">    executorService.prestartAllCoreThreads();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalI = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 生成任务的线程对context进行赋值</span></span><br><span class="line">                    Context contextMain = <span class="keyword">new</span> Context();</span><br><span class="line">                    contextMain.name = String.format(<span class="string">"Thread%s name"</span>, finalI);</span><br><span class="line">                    contextMain.value = finalI * <span class="number">20</span>;</span><br><span class="line">                    InheritableThreadLocalContext.context.set(contextMain);</span><br><span class="line">                    <span class="comment">// 提交任务</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Thread"</span> + finalI + <span class="string">" produce task "</span> + (finalI * <span class="number">20</span> + j));</span><br><span class="line">                        executorService.execute(() -&gt; &#123;</span><br><span class="line">                            <span class="comment">// 执行任务的子线程</span></span><br><span class="line">                            Context contextChild = InheritableThreadLocalContext.context.get();</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" execute task, name : "</span> + contextChild.name + <span class="string">" value : "</span> + contextChild.value);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果不出所料，执行任务的线程输出的，都是最外面主线程设置的值。</p><p>那么我们该如何才能达到最初想要的效果呢？就是利用线程池执行任务时，如何能够让执行者线程能够获取调用者线程的 context 呢？</p><h2 id="使用-TransmittableThreadLocal-解决"><a href="#使用-TransmittableThreadLocal-解决" class="headerlink" title="使用 TransmittableThreadLocal 解决"></a>使用 TransmittableThreadLocal 解决</h2><p>上面的问题主要是因为执行任务的线程是被线程池管理，可以被复用（可以称为<code>池化复用</code>）。那复用了之后，如果还是依赖于父线程的 context，自然是有问题的，因为我们想要的效果是执行线程获取调用线程的 context，这时候就是<code>TransmittableThreadLocal</code>出场了。</p><p>TransmittableThreadLocal 是阿里提供的工具类，其主要解决的就是上面遇到的问题。那么该如何使用呢？</p><p>首先，你需要引入相应的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;transmittable-thread-local&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.11.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>具体代码，就拿上文提到的情况，我们用 TransmittableThreadLocal 做一个改造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransmittableThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TransmittableThreadLocal&lt;Context&gt; context = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 固定线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        <span class="comment">// 生成任务的线程对context进行赋值</span></span><br><span class="line">                        Context contextMain = <span class="keyword">new</span> Context();</span><br><span class="line">                        contextMain.name = String.format(<span class="string">"Thread%s name"</span>, finalI);</span><br><span class="line">                        contextMain.value = finalI * <span class="number">20</span>;</span><br><span class="line">                        TransmittableThreadLocalTest.context.set(contextMain);</span><br><span class="line">                        <span class="comment">// 提交任务</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Thread"</span> + finalI + <span class="string">" produce task "</span> + (finalI * <span class="number">20</span> + j));</span><br><span class="line">                            Runnable task = () -&gt; &#123;</span><br><span class="line">                                <span class="comment">// 执行任务的子线程</span></span><br><span class="line">                                Context contextChild = TransmittableThreadLocalTest.context.get();</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">" execute task, name : "</span> + contextChild.name + <span class="string">" value : "</span> + contextChild.value);</span><br><span class="line">                            &#125;;</span><br><span class="line">                            <span class="comment">// 额外的处理，生成修饰了的对象ttlRunnable</span></span><br><span class="line">                            Runnable ttlRunnable = TtlRunnable.get(task);</span><br><span class="line">                            executorService.execute(ttlRunnable);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">            ).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时再次运行，就会发现执行线程运行时的输出内容是完全可以和调用线程对应上的了。当然了，我这种方式是修改了 Runnable 的写法，阿里也提供了线程池的写法，简单如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 固定线程池</span></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 额外的处理，生成修饰了的对象executorService</span></span><br><span class="line">    executorService = TtlExecutors.getTtlExecutorService(executorService);</span><br><span class="line">    ExecutorService finalExecutorService = executorService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalI = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 生成任务的线程对context进行赋值</span></span><br><span class="line">                    Context contextMain = <span class="keyword">new</span> Context();</span><br><span class="line">                    contextMain.name = String.format(<span class="string">"Thread%s name"</span>, finalI);</span><br><span class="line">                    contextMain.value = finalI * <span class="number">20</span>;</span><br><span class="line">                    TransmittableThreadLocalTest.context.set(contextMain);</span><br><span class="line">                    <span class="comment">// 提交任务</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Thread"</span> + finalI + <span class="string">" produce task "</span> + (finalI * <span class="number">20</span> + j));</span><br><span class="line">                        Runnable task = () -&gt; &#123;</span><br><span class="line">                            <span class="comment">// 执行任务的子线程</span></span><br><span class="line">                            Context contextChild = TransmittableThreadLocalTest.context.get();</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" execute task, name : "</span> + contextChild.name + <span class="string">" value : "</span> + contextChild.value);</span><br><span class="line">                        &#125;;</span><br><span class="line">                        finalExecutorService.execute(task);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实还有更加简单的写法，具体可以参考其github:<a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">https://github.com/alibaba/transmittable-thread-local</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实两篇 ThreadLocal 升级文章的出现，都是因为周三听了一个部门关于 TTL 的分享会，也是介绍了 TransmittableThreadLocal，但因为携程商旅面临国际化的改动，当前的语种信息肯定是存储在线程的 context 中最方便，但涉及到线程传递的问题（因为会调用异步接口等等），所以自然就需要考虑这个了。性能方面的话，他们有做过测试，但我也只是一个听者，并没有具体使用过，大家也可以一起交流。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://jjcoder.top/" target="_blank" rel="noopener">https://jjcoder.top/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中，我们谈到了 InheritableThreadLocal，它解决了 ThreadLocal 针对父子线程无法共享&lt;code&gt;上下文&lt;/code&gt;的问题。但我们可能听说过阿里的开源产品&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;，那么它又是做什么的呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="https://www.death00.top/tags/ThreadLocal/"/>
    
      <category term="TransmittableThreadLocal" scheme="https://www.death00.top/tags/TransmittableThreadLocal/"/>
    
  </entry>
  
</feed>
