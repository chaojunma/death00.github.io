<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>death00</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-23T05:41:37.995Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>death00</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty - 粘包和半包(上)</title>
    <link href="http://yoursite.com/2019/10/24/Netty%20-%20%E7%B2%98%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85(%E4%B8%8A)/"/>
    <id>http://yoursite.com/2019/10/24/Netty - 粘包和半包(上)/</id>
    <published>2019-10-24T01:00:00.000Z</published>
    <updated>2019-10-23T05:41:37.995Z</updated>
    
    <content type="html"><![CDATA[<p>在网络传输中，粘包和半包应该是最长出现的问题，作为 Java 中最常使用的 NIO 网络框架 Netty，它又是如何解决的呢？今天就让我们来看看。<br><a id="more"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>TCP 传输中，客户端发送数据，实际是把数据写入到了 TCP 的缓存中，粘包和半包也就会在此时产生。</p><p>客户端给服务端发送了两条消息<code>ABC</code>和<code>DEF</code>，服务端这边的接收会有多少种情况呢？有可能是一次性收到了所有的消息<code>ABCDEF</code>，有可能是收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>。</p><p>上面所说的一次性收到了所有的消息<code>ABCDEF</code>，类似于粘包。如果客户端发送的包的大小比 TCP 的缓存容量小，并且 TCP 缓存可以存放多个包，那么客户端和服务端的一次通信就可能传递了多个包，这时候服务端从 TCP 缓存就可能一下读取了多个包，这种现象就叫<code>粘包</code>。</p><p>上面说的后面那种收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>，类似于半包。如果客户端发送的包的大小比 TCP 的缓存容量大，那么这个数据包就会被分成多个包，通过 Socket 多次发送到服务端，服务端第一次从接受缓存里面获取的数据，实际是整个包的一部分，这时候就产生了<code>半包</code>(半包不是说只收到了全包的一半，是说收到了全包的一部分)。</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>其实从上面的定义，我们就可以大概知道产生的原因了。</p><p>粘包的主要原因：</p><ol><li>发送方每次写入数据 &lt; 套接字(Socket)缓冲区大小</li><li>接收方读取套接字(Socket)缓冲区数据不够及时</li></ol><p>半包的主要原因：</p><ol><li>发送方每次写入数据 &gt; 套接字(Socket)缓冲区大小</li><li>发送的数据大于协议的 MTU (Maximum Transmission Unit，最大传输单元)，因此必须拆包</li></ol><p>其实我们可以换个角度看待问题：</p><ol><li>从<code>收发</code>的角度看，便是一个发送可能被多次接收，多个发送可能被一次接收。</li><li>从<code>传输</code>的角度看，便是一个发送可能占用多个传输包，多个发送可能公用一个传输包。</li></ol><p>根本原因，其实是</p><blockquote><p>TCP 是流式协议，消息无边界。</p><p>(PS ： UDP 虽然也可以一次传输多个包或者多次传输一个包，但每个消息都是有边界的，因此不会有粘包和半包问题。)</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>就像上面说的，UDP 之所以不会产生粘包和半包问题，主要是因为消息有边界，因此，我们也可以采取类似的思路。</p><h3 id="改成短连接"><a href="#改成短连接" class="headerlink" title="改成短连接"></a>改成短连接</h3><p>将 TCP 连接改成短连接，一个请求一个短连接。这样的话，建立连接到释放连接之间的消息即为传输的信息，消息也就产生了边界。</p><p>这样的方法就是十分简单，不需要在我们的应用中做过多修改。但缺点也就很明显了，效率低下，TCP 连接和断开都会涉及三次握手以及四次握手，每个消息都会涉及这些过程，十分浪费性能。</p><p>因此，并不推介这种方式。</p><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>封装成帧(Framing)，也就是原本发送消息的单位是缓冲大小，现在换成了帧，这样我们就可以自定义边界了。一般有4种方式：</p><h4 id="固定长度"><a href="#固定长度" class="headerlink" title="固定长度"></a>固定长度</h4><p>这种方式下，消息边界也就是固定长度即可。</p><p>优点就是实现很简单，缺点就是空间有极大的浪费，如果传递的消息中大部分都比较短，这样就会有很多空间是浪费的。</p><p>因此，这种方式一般也是不推介的。</p><h4 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h4><p>这种方式下，消息边界也就是分隔符本身。</p><p>优点是空间不再浪费，实现也比较简单。缺点是当内容本身出现分割符时需要转义，所以无论是发送还是接受，都需要进行整个内容的扫描。</p><p>因此，这种方式效率也不是很高，但可以尝试使用。</p><h4 id="专门的-length-字段"><a href="#专门的-length-字段" class="headerlink" title="专门的 length 字段"></a>专门的 length 字段</h4><p>这种方式，就有点类似 Http 请求中的 Content-Length，有一个专门的字段存储消息的长度。作为服务端，接受消息时，先解析固定长度的字段（length字段）获取消息总长度，然后读取后续内容。</p><p>优点是精确定位用户数据，内容也不用转义。缺点是长度理论上有限制，需要提前限制可能的最大长度从而定义长度占用字节数。</p><p>因次，十分推介用这种方式。</p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>其他方式就各不相同了，比如 JSON 可以看成是使用<code>{}</code>是否成对。这些优缺点就需要大家在各自的场景中进行衡量了。</p><h2 id="Netty-中的实现"><a href="#Netty-中的实现" class="headerlink" title="Netty 中的实现"></a>Netty 中的实现</h2><p>Netty 支持上文所讲的封装成帧(Framing)中的前三种方式，简单介绍下：</p><table><thead><tr><th style="text-align:left">方式</th><th style="text-align:left">解码</th><th style="text-align:left">编码</th></tr></thead><tbody><tr><td style="text-align:left">固定长度</td><td style="text-align:left">FixedLengthFrameDecoder</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">分割符</td><td style="text-align:left">DelimiterBasedFrameDecoder</td><td style="text-align:left">简答</td></tr><tr><td style="text-align:left">专门的 length 字段</td><td style="text-align:left">LengthFieldBasedFrameDecoder</td><td style="text-align:left">LengthFieldPrepender</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天主要介绍了粘包和半包问题、解决思路和 Netty 中的支持，我会在下一篇文章里重点讲述 Netty 中的具体实现，敬请期待。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网络传输中，粘包和半包应该是最长出现的问题，作为 Java 中最常使用的 NIO 网络框架 Netty，它又是如何解决的呢？今天就让我们来看看。&lt;br&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="粘包" scheme="http://yoursite.com/tags/%E7%B2%98%E5%8C%85/"/>
    
      <category term="半包" scheme="http://yoursite.com/tags/%E5%8D%8A%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试 - ThreadLocal 原理</title>
    <link href="http://yoursite.com/2019/10/23/Java%20%E9%9D%A2%E8%AF%95%20-%20ThreadLocal%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/10/23/Java 面试 - ThreadLocal原理/</id>
    <published>2019-10-23T01:30:00.000Z</published>
    <updated>2019-10-22T08:57:58.314Z</updated>
    
    <content type="html"><![CDATA[<p>关于 ThreadLocal，我们经常用它来解决多线程并发问题，那它究竟是如何做到的？今天就让我们来好好看一下。<br><a id="more"></a></p><h2 id="从源码入手"><a href="#从源码入手" class="headerlink" title="从源码入手"></a>从源码入手</h2><p>首先，让我们看看 ThreadLocal 类中的介绍：</p><blockquote><p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</p><p>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</p></blockquote><p>按照文中所述，ThreadLocal 提供的是线程本地变量，每个线程都有一份单独的副本，经常使用的方式是<code>私有静态变量</code>。关键在于下一段，线程存活，ThreadLocal 实例就可以被访问，线程消失，就会被垃圾回收。</p><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h3><p>看到这儿，有没有想起上一篇内容所说的<code>引用类型</code>，有可能是<code>软引用</code>或者<code>弱引用</code>，具体是什么呢？还是来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取线程里的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面展示的是 ThreadLocal 中的<code>get()</code>方法，关键的 map 是在 Thread 类中的<code>threadLocals</code>变量，让我们继续看看 ThreadLocalMap 的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="comment">// 使用ThreadLocal作为key，并且是弱引用</span></span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上一篇文章所述，如果一个对象只有<code>弱引用</code>，那么当下一次 GC 进行时，该对象就会被回收。那么让我们整理一下：</p><ol><li>ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为<code>弱引用</code>。</li><li>ThreadLocal 本身并不存储值，具体的 value 依旧在各个线程中。因此你可以把 ThreadLocal 看成一个工具类。</li></ol><p>但需要注意的是，Entry 中，只有key是弱引用，但 value 依旧是强引用。那会不会出现 key 被垃圾回收后，这个 map 的 key 为 null，但 value 依旧存在的情况呢？</p><h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h3><p>确实是有可能的，但 JDK 本身也做了优化，可以看看 ThreadLocalMap 的 set()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用 set()的时候，ThreadLocalMap 检查到 key 为 null 的 entry 时，会将 value 也设置为 null，这样 value 之前对应的实例也可以被回收。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>先让我们看一个简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalSimpleDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threads = <span class="number">3</span>;</span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= threads; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                    innerClass.add(String.valueOf(j));</span><br><span class="line">                    innerClass.print();</span><br><span class="line">                &#125;</span><br><span class="line">                innerClass.set(<span class="string">"hello world"</span>);</span><br><span class="line">            &#125;, <span class="string">"thread - "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String newStr)</span> </span>&#123;</span><br><span class="line">            StringBuilder str = Counter.counter.get();</span><br><span class="line">            Counter.counter.set(str.append(newStr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.printf(</span><br><span class="line">                    <span class="string">"Thread name:%s , ThreadLocal hashcode:%s, Instance hashcode:%s, Value:%s\n"</span>,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    Counter.counter.hashCode(),</span><br><span class="line">                    Counter.counter.get().hashCode(),</span><br><span class="line">                    Counter.counter.get().toString()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 赋值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">            Counter.counter.set(<span class="keyword">new</span> StringBuilder(words));</span><br><span class="line">            System.out.printf(</span><br><span class="line">                    <span class="string">"Set, Thread name:%s , ThreadLocal hashcode:%s,  Instance hashcode:%s, Value:%s\n"</span>,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    Counter.counter.hashCode(),</span><br><span class="line">                    Counter.counter.get().hashCode(),</span><br><span class="line">                    Counter.counter.get().toString()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化时是一个空的StringBuilder对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;StringBuilder&gt; counter = ThreadLocal.withInitial(StringBuilder::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其打印结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread name:thread - 3 , ThreadLocal hashcode:310471657, Instance hashcode:640658548, Value:0</span><br><span class="line">Thread name:thread - 2 , ThreadLocal hashcode:310471657, Instance hashcode:126253473, Value:0</span><br><span class="line">Thread name:thread - 2 , ThreadLocal hashcode:310471657, Instance hashcode:126253473, Value:01</span><br><span class="line">Thread name:thread - 2 , ThreadLocal hashcode:310471657, Instance hashcode:126253473, Value:012</span><br><span class="line">Thread name:thread - 2 , ThreadLocal hashcode:310471657, Instance hashcode:126253473, Value:0123</span><br><span class="line">Thread name:thread - 1 , ThreadLocal hashcode:310471657, Instance hashcode:829132711, Value:0</span><br><span class="line">Thread name:thread - 1 , ThreadLocal hashcode:310471657, Instance hashcode:829132711, Value:01</span><br><span class="line">Thread name:thread - 1 , ThreadLocal hashcode:310471657, Instance hashcode:829132711, Value:012</span><br><span class="line">Thread name:thread - 1 , ThreadLocal hashcode:310471657, Instance hashcode:829132711, Value:0123</span><br><span class="line">Set, Thread name:thread - 1 , ThreadLocal hashcode:310471657,  Instance hashcode:820066274, Value:hello world</span><br><span class="line">Thread name:thread - 3 , ThreadLocal hashcode:310471657, Instance hashcode:640658548, Value:01</span><br><span class="line">Thread name:thread - 3 , ThreadLocal hashcode:310471657, Instance hashcode:640658548, Value:012</span><br><span class="line">Set, Thread name:thread - 2 , ThreadLocal hashcode:310471657,  Instance hashcode:155293473, Value:hello world</span><br><span class="line">Thread name:thread - 3 , ThreadLocal hashcode:310471657, Instance hashcode:640658548, Value:0123</span><br><span class="line">Set, Thread name:thread - 3 , ThreadLocal hashcode:310471657,  Instance hashcode:1804272849, Value:hello world</span><br></pre></td></tr></table></figure></p><p>可以看出，我们在使用 ThreadLocal 时，用的是同一个对象，但各个线程对应的实例是不一样的。而在调用 set() 方法后，对应的实例会被替换。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>对于 Java Web 应用而言，Session 保存了很多信息。很多时候需要通过 Session 获取信息，有些时候又需要修改 Session 的信息。一方面，需要保证每个线程有自己单独的 Session 实例。另一方面，由于很多地方都需要操作 Session，存在多方法共享 Session 的需求。使用 ThreadLocal 进行实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Session&gt; session = ThreadLocal.&lt;Session&gt;withInitial(() -&gt; <span class="keyword">new</span> Session());</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Data</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> session.get().getUser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> session.get().getStatus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">    session.get().setStatus(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      SessionHandler handler = <span class="keyword">new</span> SessionHandler();</span><br><span class="line">      handler.getStatus();</span><br><span class="line">      handler.getUser();</span><br><span class="line">      handler.setStatus(<span class="string">"close"</span>);</span><br><span class="line">      handler.getStatus();</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ThreadLocal 使用起来虽然简单，但考虑到其设计确实很精巧，值得了解一下。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 ThreadLocal，我们经常用它来解决多线程并发问题，那它究竟是如何做到的？今天就让我们来好好看一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="弱引用" scheme="http://yoursite.com/tags/%E5%BC%B1%E5%BC%95%E7%94%A8/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试 - 四种引用类型</title>
    <link href="http://yoursite.com/2019/10/22/Java%20%E9%9D%A2%E8%AF%95%20-%20%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/10/22/Java 面试 - 四种引用类型/</id>
    <published>2019-10-22T01:30:00.000Z</published>
    <updated>2019-10-22T06:05:01.944Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们提到过 GC，但当 Java 中引用的对象越来越多，会导致内存空间不足，最终会产生错误 OutOfMemoryError，并让应用程序终止。那为什么 GC 在此时不能多收集一些对象呢？这就和今天说的引用类型有关了。<br><a id="more"></a></p><p>首先，从 JDK1.2 开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：<code>强引用</code>、<code>软引用</code>、<code>弱引用</code>和<code>虚引用</code>。</p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用(Strong Reference)是使用最普遍的引用。如果一个对象具有强引用，那么它永远不会被 GC。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object strongReference = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></p><p>当内存空间不足时，JVM 宁愿抛出<code>OutOfMemoryError</code>，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p><p>如果强引用对象不使用时，需要弱化从而可以被 GC，例如<code>ArrayList</code>中的<code>clear()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment"> * be empty after this call returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显式地设置强引用对象为<code>null</code>，或让其超出对象的生命周期范围，则垃圾回收器认为该对象不存在引用，就会回收这个对象。具体什么时候收集这要取决于具体的垃圾回收器。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>如果一个对象只具有软引用(Soft Reference)，当内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。让我们来看一个例子具体了解一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(str);</span><br><span class="line">String result = softReference.get();</span><br></pre></td></tr></table></figure></p><p>让我们来看一下<code>get()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T o = <span class="keyword">super</span>.get();</span><br><span class="line">    <span class="comment">// timestamp代表上一次软引用上一次被使用的时间(初始化、get())</span></span><br><span class="line">    <span class="comment">// clock代表上一次GC的时间</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.timestamp != clock)</span><br><span class="line">        <span class="keyword">this</span>.timestamp = clock;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，<code>软引用</code>在被垃圾回收时，也遵循<code>LRU法则</code>，优先回收最近最少被使用的对象进行回收。</p><p>软引用的使用场景多是<code>内存敏感的高速缓存</code>。具体来说，就是我们希望将数据存放到缓存中，这样可以快速进行读取。但是，当 JVM 中内存不够用时，我们又不希望缓存数据会占用到 JVM 的内存。例如配合<code>ReferenceQueue</code>，如果软引用所引用对象被垃圾回收，JVM 就会把这个软引用加入到与之关联的引用队列中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;String&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(str, referenceQueue);</span><br><span class="line"></span><br><span class="line">str = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Notify GC</span></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(softReference.get()); <span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line">Reference&lt;? extends String&gt; reference = referenceQueue.poll();</span><br><span class="line">System.out.println(reference); <span class="comment">//null</span></span><br></pre></td></tr></table></figure></p><p>但是需要注意的时，如果使用软引用缓存，有可能导致<code>Full GC</code>增多。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>如果一个对象只具有弱引用(Weak Reference)，其生命周期相比于软引用更加短暂。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会对它进行回收。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。其使用为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(str);</span><br><span class="line">str = weakReference.get();</span><br></pre></td></tr></table></figure></p><p>讲到弱引用，就不得不提到<code>WeakHashMap</code>。和<code>HashMap</code>相比，当我们给 JVM 分配的内存不足的时候，HashMap 宁可抛出 OutOfMemoryError 异常，也不会回收其相应的没有被引用的对象，而 WeakHashMap 则会回收存储在其中但有被引用的对象。</p><p>WeakHashMap 通过将一些没有被引用的键的值赋值为 null ，这样的话就会告知GC去回收这些存储的值了。假如我们特地传入 key 为 null 的键，WeakHashMap 会将键设置为特殊的 Oject，源码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    // key会被重新赋值</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    int h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    int i = indexFor(h, tab.length);</span><br><span class="line"></span><br><span class="line">    for (Entry&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</span><br><span class="line">        if (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (value != oldValue)</span><br><span class="line">                e.value = value;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class="line">    tab[i] = new Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class="line">    if (++size &gt;= threshold)</span><br><span class="line">        resize(tab.length * 2);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Value representing null keys inside tables.</span><br><span class="line"> * 特殊的key</span><br><span class="line"> */</span><br><span class="line">private static final Object NULL_KEY = new Object();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Use NULL_KEY for key if it is null.</span><br><span class="line"> */</span><br><span class="line">private static Object maskNull(Object key) &#123;</span><br><span class="line">    return (key == null) ? NULL_KEY : key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用(PhantomReference),顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。 虚引用与软引用和弱引用的一个区别在于：</p><blockquote><p>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p></blockquote><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line"><span class="comment">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class="line">PhantomReference pr = <span class="keyword">new</span> PhantomReference(str, queue);</span><br></pre></td></tr></table></figure></p><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，也可以理解为一种回调方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 中4种引用的级别和强度由高到低依次为：<code>强引用</code> -&gt; <code>软引用</code> -&gt; <code>弱引用</code> -&gt; <code>虚引用</code></p><p>通过表格，说明其特性：</p><table><thead><tr><th style="text-align:left">引用类型</th><th style="text-align:left">被垃圾回收的时间</th><th style="text-align:left">使用场景</th><th style="text-align:left">生存时间</th></tr></thead><tbody><tr><td style="text-align:left">强引用</td><td style="text-align:left">从来不会</td><td style="text-align:left">对象的一般状态</td><td style="text-align:left">JVM停止运行时</td></tr><tr><td style="text-align:left">软引用</td><td style="text-align:left">内存不足时</td><td style="text-align:left">对象缓存</td><td style="text-align:left">内存不足时</td></tr><tr><td style="text-align:left">弱引用</td><td style="text-align:left">正常垃圾回收时</td><td style="text-align:left">对象缓存</td><td style="text-align:left">垃圾回收后终止</td></tr><tr><td style="text-align:left">虚引用</td><td style="text-align:left">正常垃圾回收时</td><td style="text-align:left">跟踪对象的垃圾回收</td><td style="text-align:left">垃圾回收后终止</td></tr></tbody></table><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们提到过 GC，但当 Java 中引用的对象越来越多，会导致内存空间不足，最终会产生错误 OutOfMemoryError，并让应用程序终止。那为什么 GC 在此时不能多收集一些对象呢？这就和今天说的引用类型有关了。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="强引用" scheme="http://yoursite.com/tags/%E5%BC%BA%E5%BC%95%E7%94%A8/"/>
    
      <category term="软引用" scheme="http://yoursite.com/tags/%E8%BD%AF%E5%BC%95%E7%94%A8/"/>
    
      <category term="弱引用" scheme="http://yoursite.com/tags/%E5%BC%B1%E5%BC%95%E7%94%A8/"/>
    
      <category term="虚引用" scheme="http://yoursite.com/tags/%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试 - 垃圾回收（下）</title>
    <link href="http://yoursite.com/2019/10/21/Java%20%E9%9D%A2%E8%AF%95%20-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2019/10/21/Java 面试 - 垃圾回收（下）/</id>
    <published>2019-10-21T01:30:00.000Z</published>
    <updated>2019-10-21T00:52:29.174Z</updated>
    
    <content type="html"><![CDATA[<p>接着上一篇，介绍完了 JVM 中识别需要回收的垃圾对象之后，这一篇我们来说说 JVM 是如何进行垃圾回收。<br><a id="more"></a></p><p>首先要在这里介绍一下<code>80/20 法则</code>:</p><blockquote><p>约仅有20%的变因操纵着80%的局面。也就是说：所有变量中，最重要的仅有20%，虽然剩余的80%占了多数，控制的范围却远低于“关键的少数”。</p></blockquote><p>Java 对象的生命周期也满足也这样的定律，即大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间。</p><p>因此，这也就造就了 JVM 中<code>分代回收</code>的思想。简单来说，就是将堆空间划分为两代，分别叫做<code>新生代</code>和<code>老年代</code>。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。</p><p>这样也就可以让 JVM 给不同代使用不同的回收算法。</p><p>对于新生代，我们猜测大部分的 Java 对象只存活一小段时间，那么便可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。</p><p>对于老年代，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。此时，JVM 往往需要做一次全堆扫描，耗时也将不计成本。（当然，现代的垃圾回收器都在并发收集的道路上发展，来避免这种全堆扫描的情况。）</p><p>那么，我们先来看看 JVM 中堆究竟是如何划分的。</p><h2 id="堆划分"><a href="#堆划分" class="headerlink" title="堆划分"></a>堆划分</h2><p>按照上文所述，JVM 将堆划分为新生代和老年代，其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019101901.png?raw=true" alt=""></p><p>通常来说，当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。否则，将有可能出现两个对象共用一段内存的事故。</p><p>JVM 的解决方法是为每个线程预先申请一段连续的堆空间，并且只允许每个线程在自己申请过的堆空间中创建对象，如果申请的堆空间被用完了，那么再继续申请即可，这也就是 TLAB（Thread Local Allocation Buffer，对应虚拟机参数 -XX:+UseTLAB，默认开启）。</p><p>此时，如果线程操作涉及到加锁，则该线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。</p><p>接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。</p><p>如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。</p><p>那有没有可能出现申请不到的情况呢？有的，这个时候就会触发<code>Minor GC</code>了。</p><h2 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h2><p>所谓 Minor GC，就是指：</p><blockquote><p>当 Eden 区的空间耗尽时，JVM 会进行一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。</p></blockquote><p>上文提到，新生代共有两个 Survivor 区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivior 区是空的。</p><p>当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。</p><p>JVM 会记录 Survivor 区中每个对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。</p><p>另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。</p><p>总而言之，当发生 Minor GC 时，我们应用了<code>标记 - 复制</code>算法，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种<code>标记 - 复制</code>算法的效果极好。</p><p>Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。但是，它却有一个问题，那就是老年代中的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。这样一来，岂不是又做了一次全堆扫描呢？</p><p>为了避免扫描全堆，JVM 引入了名为<code>卡表</code>的技术，大致地标出可能存在老年代到新生代引用的内存区域。有兴趣的朋友可以去详细了解一下，这里限于篇幅，就不具体介绍了。</p><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>那什么时候会发生<code>Full GC</code>呢？针对不同的垃圾收集器，Full GC 的触发条件可能不都一样。按 HotSpot VM 的 serial GC 的实现来看，触发条件是:</p><blockquote><p>当准备要触发一次 Minor GC 时，如果发现统计数据说之前 Minor GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Minor GC 而是转为触发 Full GC。</p><p>因为 HotSpot VM 的 GC 里，除了垃圾回收器 CMS 能单独收集老年代之外，其他的 GC 都会同时收集整个堆，所以不需要事先准备一次单独的 Minor GC。</p></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>基础的回收方式有三种：<code>清除</code>、<code>压缩</code>、<code>复制</code>，接下来让我们来一一了解一下。</p><h3 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h3><p>所谓清除，就是把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p><p>其原理十分简单，但是有两个缺点：</p><ol><li>会造成内存碎片。由于 JVM 的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。</li><li>分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，JVM 则需要逐个访问空闲列表中的项，来查找能够放入新建对象的空闲内存。</li></ol><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>所谓压缩，就是把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。</p><p>这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销，因此分配效率问题依旧没有解决。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>所谓复制，就是把内存区域平均分为两块，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针所指向的内存区域中，并且交换 from 指针和 to 指针的内容。</p><p>这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。</p><h3 id="具体垃圾收集器"><a href="#具体垃圾收集器" class="headerlink" title="具体垃圾收集器"></a>具体垃圾收集器</h3><p>针对<code>新生代</code>的垃圾回收器共有三个：Serial ，Parallel Scavenge 和 Parallel New。这三个采用的都是<code>标记 - 复制</code>算法。</p><p>其中，Serial 是一个单线程的，Parallel New 可以看成是 Serial 的多线程版本，Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。</p><p>针对<code>老年代</code>的垃圾回收器也有三个：Serial Old ，Parallel Old 和 CMS。</p><p>Serial Old 和 Parallel Old 都是<code>标记 - 压缩</code>算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。</p><p>CMS 采用的是<code>标记 - 清除</code>算法，并且是并发的。除了少数几个操作需要 STW(Stop the world) 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，JVM 会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃。</p><p>G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是<code>标记 - 压缩</code>算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。</p><p>G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要讲述的是 JVM 中具体的垃圾回收方法，从对象的生存规律，引出回收方法，结合多线程的特点，逐步优化，最终产生了我们现在所能知道各种垃圾收集器。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接着上一篇，介绍完了 JVM 中识别需要回收的垃圾对象之后，这一篇我们来说说 JVM 是如何进行垃圾回收。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试 - 垃圾回收（上）</title>
    <link href="http://yoursite.com/2019/10/20/Java%20%E9%9D%A2%E8%AF%95%20-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2019/10/20/Java 面试 - 垃圾回收（上）/</id>
    <published>2019-10-20T01:30:00.000Z</published>
    <updated>2019-10-21T00:52:05.454Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中的垃圾回收，常常是由 JVM 帮我们做好的。虽然这节省了大家很多的学习的成本，提高了项目的执行效率，但是当项目变得越来越复杂，用户量越来越大时，还是需要我们懂得垃圾回收机制，这样也能进行更深一步的优化。<br><a id="more"></a></p><h2 id="辨别对象存亡"><a href="#辨别对象存亡" class="headerlink" title="辨别对象存亡"></a>辨别对象存亡</h2><p>垃圾回收( Garbage Collection，以下简称 GC )，从字面上理解，就是将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。</p><p>在 JVM 中，垃圾就是指的死亡对象所占据的堆空间( GC 是发生在堆空间中)，那么我们如果辨别一个对象是否死亡呢？JVM 使用的是<code>引用计数法</code>和<code>可达性分析</code>。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法( Reference Counting)，是为每个对象添加一个引用计数器，用来统计引用该对象的个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。</p><p>其具体实现为：</p><blockquote><p>如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。</p><p>如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。</p><p>也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。</p></blockquote><p>看似很简单的实现，其实里面有不少缺陷：</p><ol><li>需要额外的空间来存储计数器。</li><li>计数器的更新操作十分繁琐。</li><li>最重要的：无法处理循环引用对象。</li></ol><p>针对第3点，举个例子特别说明一下：</p><p>假设对象 a 与 b 相互引用，除此之外没有其他引用指向他们。在这种情况下，a 和 b 实际上已经死了。</p><p>但由于它们的引用计数器皆不为0（因为相互引用，两者均为1），在引用计数法的计算中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了<code>内存泄露</code>。</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>可达性分析( Reachability Analysis )，是目前 JVM 主要采取的判定对象死亡的方法。实质在于将一系列<code>GC Roots</code>作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p><p>那么什么是<code>GC Roots</code>呢？我们可以暂时理解为由堆外指向堆内的引用，一般而言，GC Roots 包括（但不限于）如下几种：</p><ol><li>Java 方法栈桢中的局部变量</li><li>已加载类的静态变量</li><li>JNI handles</li><li>已启动且未停止的 Java 线程</li></ol><p>之前我们说<code>引用计数法</code>会有循环引用的问题，<code>可达性分析</code>就不会了。举例来说，即便对象 a 和 b 相互引用，只要从 GC Roots 出发无法到达 a 或者 b，那么可达性分析便会认为它们已经死亡。</p><p>那<code>可达性分析</code>有没有什么缺点呢？有的，在多线程环境下，其他线程可能会更新已经分析过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。</p><p>误报并没有什么伤害，JVM 至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 JVM 崩溃。</p><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p>既然<code>可达性分析</code>在多线程下有缺点，那 JVM 是如何解决的呢？答案便是 Stop-the-world(以下简称<code>JWT</code>)，停止了其他非垃圾回收线程的工作直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。</p><p>那 SWT 是如何实现的呢？当 JVM 收到 SWT 请求后，它会等待所有的线程都到达安全点（Safe Point），才允许请求 SWT 的线程进行独占的工作。</p><p>那什么又叫安全点呢？安全点是 JVM 能找到一个稳定的执行状态，在这个执行状态下，JVM 的堆栈不会发生变化。</p><p>这么一来，垃圾回收器便能够“安全”地执行可达性分析，所有存活的对象也都可以成功被标记，那么之后就可以将死亡的对象进行垃圾回收了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是发现死亡对象的过程，这也为之后的垃圾回收进行铺垫，具体的垃圾回收过程，我会在下一篇文章中讲述，敬请期待。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中的垃圾回收，常常是由 JVM 帮我们做好的。虽然这节省了大家很多的学习的成本，提高了项目的执行效率，但是当项目变得越来越复杂，用户量越来越大时，还是需要我们懂得垃圾回收机制，这样也能进行更深一步的优化。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试-即时编译( JIT )</title>
    <link href="http://yoursite.com/2019/10/14/Java%20%E9%9D%A2%E8%AF%95-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91(%20JIT%20)%20/"/>
    <id>http://yoursite.com/2019/10/14/Java 面试-即时编译( JIT ) /</id>
    <published>2019-10-14T01:30:00.000Z</published>
    <updated>2019-10-18T10:03:15.709Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在写代码时，一个方法内部的行数自然是越少越好，这样逻辑清晰、方便阅读，其实好处远不止如此，通过即时编译，甚至可以提高执行时的性能，今天就让我们好好来了解一下其中的原理。<br><a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当 JVM 的初始化完成后，类在调用执行过程中，执行引擎会把字节码转为机器码，然后在操作系统中才能执行。在字节码转换为机器码的过程中，虚拟机中还存在着一道编译，那就是<code>即时编译</code>。</p><p>最初，JVM 中的字节码是由解释器（ Interpreter ）完成编译的，当虚拟机发现某个方法或代码块的运行特别频繁的时候，就会把这些代码认定为<code>热点代码</code>。</p><p>为了提高热点代码的执行效率，在运行时，即时编译器（JIT，Just In Time）会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后保存到内存中。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>在 HotSpot 虚拟机中，内置了两种 JIT，分别为<code>C1 编译器</code>和<code>C2 编译器</code>，这两个编译器的编译过程是不一样的。</p><h2 id="C1-编译器"><a href="#C1-编译器" class="headerlink" title="C1 编译器"></a>C1 编译器</h2><p>C1 编译器是一个简单快速的编译器，主要的关注点在于局部性的优化，适用于执行时间较短或对启动性能有要求的程序，也称为<code>Client Compiler</code>，例如，GUI 应用对界面启动速度就有一定要求。</p><h2 id="C2-编译器"><a href="#C2-编译器" class="headerlink" title="C2 编译器"></a>C2 编译器</h2><p>C2 编译器是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序，也称为<code>Server Compiler</code>，例如，服务器上长期运行的 Java 应用对稳定运行就有一定的要求。</p><h2 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h2><p>在 Java7 之前，需要根据程序的特性来选择对应的 JIT，虚拟机默认采用解释器和其中一个编译器配合工作。</p><p>Java7 引入了分层编译，这种方式综合了 C1 的启动性能优势和 C2 的峰值性能优势，我们也可以通过参数 <code>-client</code>或者<code>-server</code> 强制指定虚拟机的即时编译模式。</p><p>分层编译将 JVM 的执行状态分为了 5 个层次：</p><blockquote><p>第 0 层：程序解释执行，默认开启性能监控功能（Profiling），如果不开启，可触发第二层编译；</p><p>第 1 层：可称为 C1 编译，将字节码编译为本地代码，进行简单、可靠的优化，不开启 Profiling；</p><p>第 2 层：也称为 C1 编译，开启 Profiling，仅执行带方法调用次数和循环回边执行次数 profiling 的 C1 编译；</p><p>第 3 层：也称为 C1 编译，执行所有带 Profiling 的 C1 编译；</p><p>第 4 层：可称为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</p></blockquote><p>对于 C1 的三种状态，按执行效率从高至低：第 1 层、第 2层、第 3层。</p><p>通常情况下，C2 的执行效率比 C1 高出30%以上。</p><p>在 Java8 中，默认开启分层编译，<code>-client</code> 和 <code>-server</code> 的设置已经是无效的了。如果只想开启 C2，可以关闭分层编译（<code>-XX:-TieredCompilation</code>），如果只想用 C1，可以在打开分层编译的同时，使用参数：<code>-XX:TieredStopAtLevel=1</code>。</p><p>你可以通过 <code>java -version</code>命令行可以直接查看到当前系统使用的编译模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;java -version</span><br><span class="line">java version &quot;1.8.0_45&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)</span><br></pre></td></tr></table></figure></p><p><code>mixed mode</code>代表是默认的混合编译模式，除了这种模式外，我们还可以使用<code>-Xint</code>参数强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作；也可以使用参数<code>-Xcomp</code>强制虚拟机运行于只有 JIT 的编译模式下。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;java -Xint -version</span><br><span class="line">java version &quot;1.8.0_45&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, interpreted mode)</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;java -Xcomp -version</span><br><span class="line">java version &quot;1.8.0_45&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, compiled mode)</span><br></pre></td></tr></table></figure></p><h1 id="触发标准"><a href="#触发标准" class="headerlink" title="触发标准"></a>触发标准</h1><p>在 HotSpot 虚拟机中，<code>热点探测</code>是 JIT 的触发标准。</p><blockquote><p>热点探测是基于计数器的热点探测，采用这种方法的虚拟机会为每个方法建立计数器统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法” 。</p></blockquote><p>虚拟机为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发 JIT 编译。</p><h2 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h2><p>方法调用计数器用于统计方法被调用的次数，默认阈值在 C1 模式下是 1500 次，在 C2 模式在是 10000 次，可通过<code>-XX: CompileThreshold</code>来设定；而在分层编译的情况下<code>-XX: CompileThreshold</code>指定的阈值将失效，此时将会根据当前待编译的方法数以及编译线程数来动态调整。当方法计数器和回边计数器之和超过方法计数器阈值时，就会触发 JIT 编译器。</p><h2 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h2><p>回边计数器用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge），该值用于计算是否触发 C1 编译的阈值，在不开启分层编译的情况下，C1 默认为 13995，C2 默认为 10700，可通过<code>-XX: OnStackReplacePercentage=N</code>来设置；而在分层编译的情况下，<code>-XX: OnStackReplacePercentage</code>指定的阈值同样会失效，此时将根据当前待编译的方法数以及编译线程数来动态调整。</p><p>建立回边计数器的主要目的是为了触发 OSR（On StackReplacement）编译，即栈上编译。在一些循环周期比较长的代码段中，当循环达到回边计数器阈值时，JVM 会认为这段是热点代码，JIT 编译器就会将这段代码编译成机器语言并缓存，在该循环时间段内，会直接将执行代码替换，执行缓存的机器语言。</p><h1 id="优化技术"><a href="#优化技术" class="headerlink" title="优化技术"></a>优化技术</h1><p>JIT 编译运用了一些经典的编译优化技术来实现代码的优化，即通过一些例行检查优化，可以智能地编译出运行时的最优性能代码。主要有两种：<code>方法内联</code>、<code>逃逸分析</code>。</p><h2 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h2><p>调用一个方法通常要经历压栈和出栈。调用方法是将程序执行顺序转移到存储该方法的内存地址，将方法的内容执行完后，再返回到执行该方法前的位置。</p><p>这种执行操作要求在执行前保护现场并记忆执行的地址，执行后要恢复现场，并按原来保存的地址继续执行。 因此，方法调用会产生一定的时间和空间方面的开销（其实可以理解为一种<code>上下文切换</code>的精简版）。</p><p>那么对于那些方法体代码不是很大，又频繁调用的方法来说，这个时间和空间的消耗会很大。</p><p>方法内联的优化行为就是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用。</p><p>JVM 会自动识别热点方法，并对它们使用方法内联进行优化。我们可以通过<code>-XX:CompileThreshold</code>来设置热点方法的阈值。但要强调一点，热点方法不一定会被 JVM 做内联优化，如果这个方法体太大了，JVM 将不执行内联操作。而方法体的大小阈值，我们也可以通过参数设置来优化：</p><ol><li>经常执行的方法，默认情况下，方法体大小小于 325 字节的都会进行内联，我们可以通过<code>-XX:MaxFreqInlineSize=N</code>来设置大小值；</li><li>不是经常执行的方法，默认情况下，方法大小小于 35 字节才会进行内联，我们也可以通过<code>-XX:MaxInlineSize=N</code>来重置大小值。</li></ol><p>之后我们就可以通过配置 JVM 参数来查看到方法被内联的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在控制台打印编译过程信息</span><br><span class="line">-XX:+PrintCompilation</span><br><span class="line">// 解锁对 JVM 进行诊断的选项参数。默认是关闭的，开启后支持一些特定参数对 JVM 进行诊断</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">// 将内联方法打印出来</span><br><span class="line">-XX:+PrintInlining</span><br></pre></td></tr></table></figure></p><p>热点方法的优化可以有效提高系统性能，一般我们可以通过以下几种方式来提高方法内联：</p><ol><li>通过设置 JVM 参数来减小热点阈值或增加方法体阈值，以便更多的方法可以进行内联，但这种方法意味着需要占用更多地内存；</li><li>在编程中，避免在一个方法中写大量代码，习惯使用小方法体；</li><li>尽量使用 final、private、static 关键字修饰方法，编码方法因为继承，会需要额外的类型检查。</li></ol><blockquote><p>此处就联系到了最开始提出的观点，一个方法中的内容越少，当该方法经常被执行时，则容易进行方法内联，从而优化性能。</p></blockquote><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析（Escape Analysis）是判断一个对象是否被外部方法引用或外部线程访问的分析技术，编译器会根据逃逸分析的结果对代码进行优化。</p><p>可以通过JVM参数进行设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis 开启逃逸分析（jdk1.8 默认开启）</span><br><span class="line">-XX:-DoEscapeAnalysis 关闭逃逸分析</span><br></pre></td></tr></table></figure></p><p>其具体优化方法主要有三种：<code>栈上分配</code>、<code>锁消除</code>、<code>标量替换</code>。</p><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>在 Java 中默认创建一个对象是在堆中分配内存的，而当堆内存中的对象不再使用时，则需要通过垃圾回收机制回收，这个过程相对分配在栈中的对象的创建和销毁来说，更消耗时间和性能。</p><p>这个时候，逃逸分析如果发现一个对象只在方法中使用，就会将对象分配在栈上。</p><p>但是，HotSpot 虚拟机目前的实现导致栈上分配实现比较复杂，可以说，在 HotSpot 中暂时没有实现这项优化，所以大家可能暂时无法体会到这种优化（我看的资料显示在 Java8 中还没有实现，如果大家有什么其他的发现，欢迎留言）。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>如果是在单线程环境下，其实完全没有必要使用线程安全的容器，但就算使用了，因为不会有线程竞争，这个时候 JIT 编译会对这个对象的方法锁进行锁消除。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以通过JVM参数进行设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+EliminateLocks 开启锁消除（jdk1.8 默认开启）</span><br><span class="line">-XX:-EliminateLocks 关闭锁消除</span><br></pre></td></tr></table></figure></p><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p>逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。这种编译优化就叫做标量替换。</p><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TestInfo info = <span class="keyword">new</span> TestInfo();</span><br><span class="line">    info.id = <span class="number">1</span>;</span><br><span class="line">    info.count = <span class="number">99</span>;</span><br><span class="line">    <span class="comment">// to do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>逃逸分析后，代码会被优化为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    id = <span class="number">1</span>;</span><br><span class="line">    count = <span class="number">99</span>;</span><br><span class="line">    <span class="comment">// to do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以通过JVM参数进行设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+EliminateAllocations 开启标量替换（jdk1.8 默认开启）</span><br><span class="line">-XX:-EliminateAllocations 关闭就可以了</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天的内容，由最基本的常识<code>方法内部行数和逻辑需要尽可能简单</code>引出，了解了 JVM 通过即时编译对热点代码进行优化的过程。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在写代码时，一个方法内部的行数自然是越少越好，这样逻辑清晰、方便阅读，其实好处远不止如此，通过即时编译，甚至可以提高执行时的性能，今天就让我们好好来了解一下其中的原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java面试- JVM 内存模型讲解</title>
    <link href="http://yoursite.com/2019/10/11/Java%E9%9D%A2%E8%AF%95-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/10/11/Java面试-JVM内存模型讲解/</id>
    <published>2019-10-11T01:30:00.000Z</published>
    <updated>2019-10-10T11:01:27.141Z</updated>
    
    <content type="html"><![CDATA[<p>经常有人会有这么一个疑惑，难道 Java 开发就一定要懂得 JVM 的原理吗？我不懂 JVM ，但我照样可以开发。确实，但如果懂得了 JVM ，可以让你在技术的这条路上走的更远一些。<br><a id="more"></a></p><h2 id="JVM-的重要性"><a href="#JVM-的重要性" class="headerlink" title="JVM 的重要性"></a>JVM 的重要性</h2><p>首先你应该知道，运行一个 Java 应用程序，我们必须要先安装 JDK 或者 JRE 。这是因为 Java 应用在编译后会变成字节码，然后通过字节码运行在 JVM 中，而 JVM 是 JRE 的核心组成部分。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>JVM 不仅承担了 Java 字节码的分析（JIT compiler）和执行（Runtime），同时也内置了自动内存分配管理机制。这个机制可以大大降低手动分配回收机制可能带来的内存泄露和内存溢出风险，使 Java 开发人员不需要关注每个对象的内存分配以及回收，从而更专注于业务本身。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这个机制在提升 Java 开发效率的同时，也容易使 Java 开发人员过度依赖于自动化，弱化对内存的管理能力，这样系统就很容易发生 JVM 的堆内存异常、垃圾回收（GC）的不合适以及 GC 次数过于频繁等问题，这些都将直接影响到应用服务的性能。</p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>JVM 内存模型共分为5个区：<code>堆(Heap)</code>、<code>方法区(Method Area)</code>、<code>程序计数器(Program Counter Register)</code>、<code>虚拟机栈(VM Stack)</code>、<code>本地方法栈(Native Method Stack)</code>。</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019101001.jpg?raw=true" alt=""></p><p>其中，<code>堆(Heap)</code>、<code>方法区(Method Area)</code>为<code>线程共享</code>，<code>程序计数器(Program Counter Register)</code>、<code>虚拟机栈(VM Stack)</code>、<code>本地方法栈(Native Method Stack)</code>为<code>线程隔离</code>。</p><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><p>堆是 JVM 内存中最大的一块内存空间，该内存被所有线程共享，几乎所有对象和数组都被分配到了堆内存中。</p><p>堆被划分为新生代和老年代，新生代又被进一步划分为 Eden 区和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。</p><p>随着 Java 版本的更新，其内容又有了一些新的变化：</p><blockquote><p>在 Java6 版本中，永久代在非堆内存区；到了 Java7 版本，永久代的静态变量和运行时常量池被合并到了堆中；而到了 Java8，永久代被<code>元空间</code>(处于本地内存)取代了。</p></blockquote><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019101002.png?raw=true" alt=""></p><p>为什么要用<code>元空间</code>替换永久代呢？</p><ol><li>为了融合 HotSpot JVM 与 JRockit VM，因为 JRockit 没有永久代，所以不需要配置永久代。</li><li>永久代内存经常不够用或发生内存溢出（应该是 JVM 中占用内存最大的一块），产生异常 <code>java.lang.OutOfMemoryError: PermGen</code>。在 JDK1.7 版本中，指定的 PermGen 区大小为 8M，由于 PermGen 中类的元数据信息在每次 FullGC 的时候都可能被收集，回收率都偏低，成绩很难令人满意；还有，为 PermGen 分配多大的空间很难确定，PermSize 的大小依赖于很多因素，比如，JVM 加载的 class 总数、常量池的大小和方法的大小等。</li></ol><p>看到这儿，自然就想到了 GC 回收算法，不用急，我会在之后的文章中进行讲解，现在还是以 JVM 内存模型为主。</p><h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h3><p>什么是方法区？</p><blockquote><p>方法区主要是用来存放已被虚拟机加载的类相关信息，包括<code>类信息</code>、<code>常量池</code>(字符串常量池以及所有基本类型都有其相应的常量池)、<code>运行时常量池</code>。这其中，类信息又包括了类的版本、字段、方法、接口和父类等信息。</p></blockquote><h4 id="类信息"><a href="#类信息" class="headerlink" title="类信息"></a>类信息</h4><p>JVM 在执行某个类的时候，必须经过加载、连接、初始化，而<code>连接</code>又包括验证、准备、解析三个阶段。</p><p>在加载类的时候，JVM 会先加载 class 文件，而在 class 文件中便有类的版本、字段、方法和接口等描述信息，这就是<code>类信息</code>。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>在 class 文件中，除了<code>类信息</code>，还有一项信息是常量池 (Constant Pool Table)，用于存放编译期间生成的各种<code>字面量</code>和<code>符号引用</code>。</p><p>那<code>字面量</code>和<code>符号引用</code>又是什么呢？</p><p>字面量包括字符串（String a=“b”）、基本类型的常量（final 修饰的变量），符号引用则包括类和方法的全限定名（例如 String 这个类，它的全限定名就是 Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>当类加载到内存后，JVM 就会将 class 文件<code>常量池</code>中的内容存放到<code>运行时常量池</code>中；在解析阶段，JVM 会把符号引用替换为直接引用（对象的索引值）。</p><p>例如：</p><blockquote><p>类中的一个字符串常量在 class 文件中时，存放在 class 文件常量池中的。</p><p>在 JVM 加载完类之后，JVM 会将这个<code>字符串常量</code>放到<code>运行时常量池</code>中，并在解析阶段，指定该字符串对象的索引值。</p></blockquote><p><code>运行时常量池</code>是全局共享的，多个类共用一个运行时常量池，因此，class 文件中常量池多个相同的字符串在运行时常量池只会存在一份。</p><p>讲到这里，大家是不是有些头晕了，说实话，我在看到这些内容的时候，也是云里雾里的，这里举个例子帮助大家理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"Hello"</span>;</span><br><span class="line">    System.out.println((str == (<span class="string">"Hel"</span> + <span class="string">"lo"</span>)));</span><br><span class="line"></span><br><span class="line">    String loStr = <span class="string">"lo"</span>;</span><br><span class="line">    System.out.println((str == (<span class="string">"Hel"</span> + loStr)));</span><br><span class="line"></span><br><span class="line">    System.out.println(str == (<span class="string">"Hel"</span> + loStr).intern());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><p>第一个为 true，是因为在编译成 class 文件时，能够识别为同一字符串的, JVM 会将其自动优化成字符串常量,引用自同一 String 对象。</p><p>第二个为 false，是因为在运行时创建的字符串具有独立的内存地址,所以不引用自同一 String 对象。</p><p>最后一个为 true，是因为 String 的 intern() 方法会查找在常量池中是否存在一个相等(调用 equals() 方法结果相等)的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。</p><h4 id="涉及到的Error"><a href="#涉及到的Error" class="headerlink" title="涉及到的Error"></a>涉及到的Error</h4><ol><li><code>OutOfMemoryError</code>出现在方法区无法满足内存分配需求的时候，比如一直往常量池中加入数据，<code>运行时常量池</code>就会溢出，从而报错。</li></ol><h3 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h3><p>程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p><p>由于 Java 是多线程语言，当执行的线程数量超过 CPU 数量时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。</p><p>由此可见，程序计数器和上下文切换有关。</p><h3 id="虚拟机栈-VM-Stack"><a href="#虚拟机栈-VM-Stack" class="headerlink" title="虚拟机栈(VM Stack)"></a>虚拟机栈(VM Stack)</h3><blockquote><p>虚拟机栈是线程私有的内存空间，它和 Java 线程一起创建。</p><p>当创建一个线程时，会在虚拟机栈中申请一个线程栈，用来保存方法的局部变量、操作数栈、动态链接方法和返回地址等信息，并参与方法的调用和返回。</p><p>每一个方法的调用都伴随着栈帧的入栈操作，方法的返回则是栈帧的出栈操作。</p></blockquote><p>可以这么理解，虚拟机栈针对当前 Java 应用中所有线程，都有一个其相应的线程栈，每一个线程栈都互相独立、互不影响，里面存储了该线程中独有的信息。</p><h4 id="涉及到的Error-1"><a href="#涉及到的Error-1" class="headerlink" title="涉及到的Error"></a>涉及到的Error</h4><ol><li><code>StackOverflowError</code>出现在栈内存设置成固定值的时候，当程序执行需要的栈内存超过设定的固定值时会抛出这个错误。</li><li><code>OutOfMemoryError</code>出现在栈内存设置成动态增长的时候，当JVM尝试申请的内存大小超过了其可用内存时会抛出这个错误。</li></ol><h3 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h3><blockquote><p>本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理 Java 方法的调用，而本地方法栈则用于管理本地方法的调用。</p><p>但本地方法并不是用 Java 实现的，而是由 C 语言实现的。</p></blockquote><p>也就是说，本地方法栈中并没有我们写的代码逻辑，其由<code>native</code>修饰，由 C 语言实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 JVM 内存模型的基本介绍，大致了解了一下5个分区及其相应的含义和功能，由此可以继续延伸出 Java 内存模型、 GC 算法等等，我也会在之后的文章中进行讲解。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常有人会有这么一个疑惑，难道 Java 开发就一定要懂得 JVM 的原理吗？我不懂 JVM ，但我照样可以开发。确实，但如果懂得了 JVM ，可以让你在技术的这条路上走的更远一些。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Lombok中关于@Data的使用</title>
    <link href="http://yoursite.com/2019/10/10/Lombok%E4%B8%AD%E5%85%B3%E4%BA%8E-Data%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/10/10/Lombok中关于-Data的使用/</id>
    <published>2019-10-10T02:43:30.000Z</published>
    <updated>2019-10-10T03:24:36.493Z</updated>
    
    <content type="html"><![CDATA[<p>当你在使用 Lombok 的 @Data 注解时，其实会有一些坑需要关注，今天就让我们来见识一下。<br><a id="more"></a></p><h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p>先来简单介绍一下 Lombok ，其官方介绍如下：</p><blockquote><p>Project Lombok makes java a spicier language by adding ‘handlers’ that know how to build and compile simple, boilerplate-free, not-quite-java code.</p></blockquote><p>大致意思是 Lombok 通过增加一些”处理程序”，可以让 Java 代码变得简洁、快速。</p><p>Lombok 提供了一系列的注解帮助我们简化代码，比如：</p><table><thead><tr><th style="text-align:center">注解名称</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>@Setter</code></td><td style="text-align:left">自动添加类中所有属性相关的 set 方法</td></tr><tr><td style="text-align:center"><code>@Getter</code></td><td style="text-align:left">自动添加类中所有属性相关的 get 方法</td></tr><tr><td style="text-align:center"><code>@Builder</code></td><td style="text-align:left">使得该类可以通过 builder (建造者模式)构建对象</td></tr><tr><td style="text-align:center"><code>@RequiredArgsConstructor</code></td><td style="text-align:left">生成一个该类的构造方法，禁止无参构造</td></tr><tr><td style="text-align:center"><code>@ToString</code></td><td style="text-align:left">重写该类的<code>toString()</code>方法</td></tr><tr><td style="text-align:center"><code>@EqualsAndHashCode</code></td><td style="text-align:left">重写该类的<code>equals()</code>和<code>hashCode()</code>方法</td></tr><tr><td style="text-align:center"><code>@Data</code></td><td style="text-align:left">等价于上面的<code>@Setter</code>、<code>@Getter</code>、<code>@RequiredArgsConstructor</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code></td></tr></tbody></table><p>看起来似乎这些注解都很正常，并且对我们的代码也有一定的优化，那为什么说<code>@Data</code>注解存在坑呢？</p><h2 id="Data注解"><a href="#Data注解" class="headerlink" title="@Data注解"></a>@Data注解</h2><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>由上面的表格我们可以知道，<code>@Data</code>是包含了<code>@EqualsAndHashCode</code>的功能，那么它究竟是如何重写<code>equals()</code>和<code>hashCode()</code>方法的呢？</p><p>我们定义一个类<code>TestA</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String oldName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将其编译后的 class 文件进行反编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String oldName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOldName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.oldName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOldName</span><span class="params">(String oldName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.oldName = oldName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否是同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否是同一个类</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> TestA)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TestA other = (TestA) o;</span><br><span class="line">            <span class="keyword">if</span> (!other.canEqual(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 比较类中的属性(注意这里，只比较了当前类中的属性)</span></span><br><span class="line">                Object <span class="keyword">this</span>$oldName = <span class="keyword">this</span>.getOldName();</span><br><span class="line">                Object other$oldName = other.getOldName();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$oldName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$oldName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>$oldName.equals(other$oldName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canEqual</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> TestA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> PRIME = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        Object $oldName = <span class="keyword">this</span>.getOldName();</span><br><span class="line">        <span class="keyword">int</span> result = result * <span class="number">59</span> + ($oldName == <span class="keyword">null</span> ? <span class="number">43</span> : $oldName.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TestA(oldName="</span> + <span class="keyword">this</span>.getOldName() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>针对其<code>equals()</code>方法，当它进行属性比较时，其实只比较了当前类中的属性。如果你不信的话，我们再来创建一个类<code>TestB</code>，它是<code>TestA</code>的子类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> <span class="keyword">extends</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将其编译后的 class 文件进行反编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> <span class="keyword">extends</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> TestB)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TestB other = (TestB)o;</span><br><span class="line">            <span class="keyword">if</span> (!other.canEqual(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意这里，真的是只比较了当前类中的属性，并没有比较父类中的属性</span></span><br><span class="line">                Object <span class="keyword">this</span>$name = <span class="keyword">this</span>.getName();</span><br><span class="line">                Object other$name = other.getName();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.getAge() == other.getAge();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>$name.equals(other$name)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.getAge() == other.getAge();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canEqual</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> TestB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> PRIME = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        Object $name = <span class="keyword">this</span>.getName();</span><br><span class="line">        <span class="keyword">int</span> result = result * <span class="number">59</span> + ($name == <span class="keyword">null</span> ? <span class="number">43</span> : $name.hashCode());</span><br><span class="line">        result = result * <span class="number">59</span> + <span class="keyword">this</span>.getAge();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TestB(name="</span> + <span class="keyword">this</span>.getName() + <span class="string">", age="</span> + <span class="keyword">this</span>.getAge() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照代码的理解，如果两个子类对象，其子类中的属性相同、父类中的属性不同时，利用<code>equals()</code>方法时，依旧会认为这两个对象相同，测试一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestB t1 = <span class="keyword">new</span> TestB();</span><br><span class="line">    TestB t2 = <span class="keyword">new</span> TestB();</span><br><span class="line"></span><br><span class="line">    t1.setOldName(<span class="string">"123"</span>);</span><br><span class="line">    t2.setOldName(<span class="string">"12345"</span>);</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"1"</span>;</span><br><span class="line">    t1.name = name;</span><br><span class="line">    t2.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">    t1.age = age;</span><br><span class="line">    t2.age = age;</span><br><span class="line"></span><br><span class="line">    System.out.println(t1.equals(t2));</span><br><span class="line">    System.out.println(t2.equals(t1));</span><br><span class="line">    System.out.println(t1.hashCode());</span><br><span class="line">    System.out.println(t2.hashCode());</span><br><span class="line">    System.out.println(t1 == t2);</span><br><span class="line">    System.out.println(Objects.equals(t1, t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">6373</span><br><span class="line">6373</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><blockquote><p>对于父类是Object且使用了<code>@EqualsAndHashCode(callSuper = true)</code>注解的类，这个类由 Lombok 生成的<code>equals()</code>方法只有在两个对象是同一个对象时，才会返回 true ，否则总为 false ，无论它们的属性是否相同。</p><p>这个行为在大部分时间是不符合预期的，<code>equals()</code>失去了其意义。即使我们期望<code>equals()</code>是这样工作的，那么其余的属性比较代码便是累赘，会大幅度降低代码的分支覆盖率。</p></blockquote><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>用了<code>@Data</code>就不要有继承关系，类似 Kotlin 的做法。</li><li>自己重写<code>equals()</code>， Lombok 不会对显式重写的方法进行生成。</li><li>显式使用<code>@EqualsAndHashCode(callSuper = true)</code>， Lombok 会以显式指定的为准。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是我在使用<code>@Data</code>时碰到的问题以及自己的一些思考，在现在的项目，我干脆不再使用该注解。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你在使用 Lombok 的 @Data 注解时，其实会有一些坑需要关注，今天就让我们来见识一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Lombok" scheme="http://yoursite.com/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>Java中Synchronized的优化原理</title>
    <link href="http://yoursite.com/2019/10/02/Java%E4%B8%ADSynchronized%E7%9A%84%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/10/02/Java中Synchronized的优化原理/</id>
    <published>2019-10-02T07:52:32.000Z</published>
    <updated>2019-10-02T08:36:13.883Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，从 JDK1.6 开始，Java 对 Synchronized 同步锁做了充分的优化，甚至在某些场景下，它的性能已经超越了 Lock 同步锁。那么就让我们来看看，它究竟是如何优化的。<br><a id="more"></a></p><h2 id="原本的问题"><a href="#原本的问题" class="headerlink" title="原本的问题"></a>原本的问题</h2><p><code>Synchronized</code>是基于底层操作系统的 Mutex Lock 实现的，每次获取锁和释放锁的操作都会带来<code>用户态</code>和<code>内核态</code>的切换，从而增加系统性能开销。</p><p>因此，在锁竞争激烈的情况下，<code>Synchronized</code>同步锁在性能上就表现得非常糟糕，它也常被大家称为<code>重量级锁</code>。</p><p>到了 JDK1.5 版本，并发包中新增了 Lock 接口来实现锁功能，它提供了与 Synchronized 关键字类似的同步功能，只是在使用时需要显示获取锁和释放锁。</p><p>在单个线程重复申请锁的情况下，JDK1.5 版本的 Lock 性能要比 Synchronized 锁的性能好很多，也就是当时的 Synchronized 并不具备<code>可重入锁</code>的功能。</p><p>那么当时的 Synchronized 是怎么实现的？又为什么不具备可重入的功能呢？</p><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><p>JVM 中的同步是基于进入和退出管程（Monitor）对象实现的。每个对象实例都会有一个 Monitor，Monitor 可以和对象一起创建、销毁。</p><p>当多个线程同时访问一段同步代码时，多个线程会先被存放在<code>EntryList集合</code>（也可称为<code>阻塞队列</code>）中，处于<code>BLOCKED</code>状态的线程，都会被加入到该列表。</p><p>接下来当线程获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，线程申请 Mutex 成功，则持有该 Mutex，其它线程将无法获取到该 Mutex。</p><p>如果线程调用 wait() 方法，就会释放当前持有的 Mutex，并且该线程会进入<code>WaitSet集合</code>（也可称为<code>等待队列</code>）中，等待下一次被唤醒。此时线程会处于<code>WAITING</code>或者<code>TIMEDWAITING</code>状态，</p><p>如果当前线程顺利执行完方法，也将释放 Mutex。</p><p>总的来说，就是同步锁在这种实现方式中，因 Monitor 是依赖于底层的操作系统实现，存在<code>用户态</code>与<code>内核态</code>之间的切换(可以理解为<code>上下文切换</code>)，所以增加了性能开销。</p><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>为了提升性能，JDK1.6 引入了偏向锁、轻量级锁、重量级锁概念，来减少锁竞争带来的上下文切换，而正是新增的<code>Java对象头</code>实现了<code>锁升级</code>功能。</p><p>所谓<code>锁升级</code>，就是指</p><blockquote><p>Synchronized 同步锁初始为<code>偏向锁</code>，随着线程竞争越来越激烈，<code>偏向锁</code>升级到<code>轻量级锁</code>，最终升级到<code>重量级锁</code>。</p></blockquote><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><code>偏向锁</code>主要用来优化同一线程多次申请同一个锁的竞争，也就是现在的<code>Synchronized锁</code>实际已经拥有了可重入锁的功能。</p><p>为什么要有<code>偏向锁</code>？因为在我们的应用中，可能大部分时间是同一个线程竞争锁资源（比如单线程操作一个线程安全的容器），如果这个线程每次都要获取锁和释放锁，那么就在不断的从<code>内核态</code>与<code>用户态</code>之间切换。</p><p>那么有了<code>偏向锁</code>，当一个线程再次访问这个同步代码或方法时，该线程只需去对象头中去判断一下是否当前线程是否持有该偏向锁就可以了。</p><p>一旦出现其它线程竞争锁资源时，偏向锁就会被撤销。偏向锁的撤销需要等待<code>全局安全点</code>(JVM的<code>stop the world</code>)，暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之则被其它线程抢占。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>当有另外一个线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头中的线程 ID 不是自己的线程 ID，就会进行 CAS 操作获取锁，如果获取成功，直接替换对象头中的线程 ID 为自己的 ID，该锁会保持<code>偏向锁</code>状态；如果获取锁失败，代表当前锁有一定的竞争，偏向锁将升级为<code>轻量级锁</code>。</p><p><code>轻量级锁</code>适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的竞争。</p><p>轻量级锁也支持<code>自旋</code>，因此其他线程再次争抢时，如果<code>CAS</code>失败，将不再会进入<code>阻塞状态</code>，而是不断自旋。</p><p>之所以自旋更好，是因为之前说了，默认线程持有锁的时间都不会太长，如果线程被挂起阻塞可能代价会更高。</p><p>如果自旋锁重试之后抢锁依然失败，那么同步锁就会升级至<code>重量级锁</code>。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>在这个状态下，未抢到锁的线程都会进入 Monitor，之后会被阻塞在<code>WaitSet集合</code>中，也就变成了优化之前的<code>Synchronized锁</code>。</p><h2 id="JVM参数优化"><a href="#JVM参数优化" class="headerlink" title="JVM参数优化"></a>JVM参数优化</h2><p><code>偏向锁</code>升级为<code>轻量级锁</code>时，会发生<code>stop the world</code>，如果系统常常是多线程竞争，那么禁止偏向锁也许是更好的选择，可以通过以下<code>JVM参数</code>进行优化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 关闭偏向锁（默认打开）</span><br><span class="line">-XX:-UseBiasedLocking</span><br><span class="line">// 设置重量级锁</span><br><span class="line">-XX:+UseHeavyMonitors</span><br></pre></td></tr></table></figure><p><code>轻量级锁</code>拥有<code>自旋锁</code>的功能，那么如果线程持有锁的时间很长，那么竞争的线程也会常常处于自旋状态，占用系统 CPU ，增加系统开销，那么此时关闭自旋锁的优化可以更好一些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseSpinning</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是 Java 中针对 Synchronized 锁的优化，也正是因为这个优化，ConcurrentHashMap 在 JDK1.8 之后，再次采用 Synchronized 锁。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，从 JDK1.6 开始，Java 对 Synchronized 同步锁做了充分的优化，甚至在某些场景下，它的性能已经超越了 Lock 同步锁。那么就让我们来看看，它究竟是如何优化的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Synchronized" scheme="http://yoursite.com/tags/Synchronized/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>升级@Scheduled-分布式定时任务</title>
    <link href="http://yoursite.com/2019/09/30/%E5%8D%87%E7%BA%A7@Scheduled-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/09/30/升级@Scheduled-分布式定时任务/</id>
    <published>2019-09-30T09:01:47.000Z</published>
    <updated>2019-10-01T01:16:41.430Z</updated>
    
    <content type="html"><![CDATA[<p>最近我在对项目的定时任务服务升级，希望改造成分布式，原本是利用<code>@Scheduled</code>注解实现，然而它并不支持分布式，如果改成<code>quartz</code>或者<code>Spring Cloud Task</code>，感觉对于自己这个简单的项目也没有必要。因此，我准备手写一个简单的支持分布式定时调度任务的框架。<br><a id="more"></a></p><p>项目地址是<a href="https://github.com/death00/dis-schedule" target="_blank" rel="noopener">https://github.com/death00/dis-schedule</a>，欢迎大家star、提意见。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先分析了一下自己的项目，全都是用的cron表达式，因此执行时间点都是固定的，如果升级为分布式的话，肯定是希望在同一个时间点只有一个应用去执行定时调度。</p><p>场景就变成了：</p><blockquote><p>多个应用在同一个时间都尝试去执行任务，但最终只有一个应用真正执行。</p></blockquote><p>这样的话，立马就会让人联想到使用<code>锁</code>去解决，因为是多个应用，所以就是<code>分布式锁</code>。那么，场景又变了：</p><blockquote><p>多个应用在同一个时间都尝试去获取<code>分布式锁</code>，只有一个应用能抢到这把锁，抢到锁的应用可以执行定时任务，其他应用则直接放弃，等待下一次执行时间。</p></blockquote><p>抢锁的时机是每次定时任务执行之前，这又让我联想到了<code>AOP</code>，那么利用<code>注解</code>也就顺理成章了。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>既然谈到了<code>分布式锁</code>，那么就想一下，这把锁的名称构成是什么。因为定时任务都有自己专门的时间，如果仅仅采用时间的话，那么当有两个任务同时执行时，则就是在抢一把锁，这同样是不合理的。</p><p>所以，锁的名称由两部分组成：任务执行时间、任务名称。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现方案其实已经很成熟了，可以利用<code>Redis</code>、<code>数据库</code>、<code>Zookeeper</code>等，<code>Redis</code>用的命令是<code>setNx</code>，<code>数据库</code>一般都是利用的<code>唯一索引</code>，<code>Zookeeper</code>这点我也不是很了解（如果有感兴趣的同学，欢迎在我的项目中添加）。</p><p>我的项目中实现了<code>Redis</code>、<code>数据库</code>两种方式，可以看类<code>DisScheduleRedisServiceImpl</code>、<code>DisScheduleMongodbServiceImpl</code>。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>其次，我自定义了一个注解<code>DisSchedule</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DisSchedule &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时调度任务的名称(默认是方法名)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务的间隔时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duration</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * duration的时间单位(默认：分钟)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">DisScheduleUnit <span class="title">unit</span><span class="params">()</span> <span class="keyword">default</span> DisScheduleUnit.MINUTES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>name</code>代表此次定时调度任务的名称。</li><li><code>duration</code>代表任务的间隔时间，配合<code>unit</code>。</li><li><code>unit</code>是自定义的时间单位，有秒、分钟。</li></ol><p>该注解需要配合<code>@Scheduled</code>共同使用，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisSchedule</span>(name = <span class="string">"testSchedule"</span>, duration = <span class="number">1</span>, unit = DisScheduleUnit.MINUTES)</span><br><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 0/1 * * * ?"</span>)</span><br></pre></td></tr></table></figure></p><p>该<code>cron</code>表达式代表1分钟执行一次，且是在整数分钟开始的时候执行，因此<code>@DisSchedule</code>也需要设置为1分钟的时间。</p><h2 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h2><p>接下来，我们只需要在<code>Aspect</code>中定义好切入点（有注解<code>@DisSchedule</code>的方法上），针对这些方法，需要使用<code>Around</code>(环绕增强)进行拦截，因为当抢不到锁的时候，就不允许执行。</p><p>具体可以参考类<code>DisScheduleAspect</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我实现的简单的分布式定时任务，虽然简单，但应该可以满足你的基础需求，接下来，我会在这个之上，逐步增加功能（比如监测、失败后预警等）。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近我在对项目的定时任务服务升级，希望改造成分布式，原本是利用&lt;code&gt;@Scheduled&lt;/code&gt;注解实现，然而它并不支持分布式，如果改成&lt;code&gt;quartz&lt;/code&gt;或者&lt;code&gt;Spring Cloud Task&lt;/code&gt;，感觉对于自己这个简单的项目也没有必要。因此，我准备手写一个简单的支持分布式定时调度任务的框架。&lt;br&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Scheduled" scheme="http://yoursite.com/tags/Scheduled/"/>
    
      <category term="定时任务" scheme="http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的负载均衡</title>
    <link href="http://yoursite.com/2019/09/30/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2019/09/30/Nginx的负载均衡/</id>
    <published>2019-09-30T01:34:06.000Z</published>
    <updated>2019-09-30T06:10:47.226Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，Nginx支持负载均衡，可以很方便的帮助我们进行水平扩容，然而它究竟是依据什么原则进行请求的分发，其中又有哪些负载均衡算法可供选择和配置，今天就让我们好好来了解一下。<br><a id="more"></a></p><h2 id="负载均衡的定义"><a href="#负载均衡的定义" class="headerlink" title="负载均衡的定义"></a>负载均衡的定义</h2><p>什么叫负载均衡，我们可以参考一下图片中的这种情况：</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019093001.png?raw=true" alt=""></p><ol><li>当客户端发送请求时，会先到Nginx，然后Nginx会将请求分发到后台不同的服务器上。</li><li>如果后台的服务器群中有一个宕机了，那么Nginx会自动忽略这台服务器，不会将请求再次分发到这台服务器上。</li><li>如果有新加入的服务器，Nginx也会将请求分发到这台服务器上。</li></ol><p>我所理解的负载均衡，就是：</p><blockquote><p>能够将客户端的请求均匀地分发到后台各个应用服务器上，从而缓解服务器压力。</p><p>并且当服务器出现宕机或者扩容时，也能正常运行。</p></blockquote><h2 id="负载均衡的方法"><a href="#负载均衡的方法" class="headerlink" title="负载均衡的方法"></a>负载均衡的方法</h2><p>上面了解了什么是负载均衡，那么Nginx是怎么实现这个功能的呢？</p><h3 id="upstream和server的使用"><a href="#upstream和server的使用" class="headerlink" title="upstream和server的使用"></a>upstream和server的使用</h3><p>Nginx中负责与上游交互的模块，统称为upstream模块。</p><p>而指定上游服务地址是通过<code>upstream</code>和<code>server</code>指令完成的，其关系为：</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019093002.png?raw=true" alt=""></p><p>指定上游服务器的<code>address</code>时，其地址可以是域名、IP地址或者unix socket地址。</p><p>可以在域名或者IP地址后加端口，如果不加端口，那么<code>默认使用80端口</code>。</p><p>在<code>address</code>后面可以添加一些参数，比如：</p><p><code>backup</code>：指定当前server为备份服务，仅当非备份server不可用时，请求才会转发到该server。</p><p><code>down</code>：标识某台服务已经下线，不再服务。</p><p>举个例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="round-robin"><a href="#round-robin" class="headerlink" title="round-robin"></a>round-robin</h3><p>在<code>upstream</code>这个模块中，它还提供了一个最基本的负载均衡算法<code>round-robin</code>。</p><p>其功能是：</p><blockquote><p>以加权轮询的方式访问server指令指定的上游服务。</p></blockquote><p>这个算法是默认集成在Nginx的框架中，无法移除，所以后面讲解的所有算法都是基于此，所有算法在某些特殊情况下最终都会变成<code>round-robin</code>。</p><p>涉及到的指令有：</p><ol><li><code>weight</code>：服务访问的权重，默认是1。</li><li><code>max_conns</code>：server的最大并发连接数，仅作用于单worker进程。</li><li><code>max_fails</code>：在<code>fail_timeout</code>时间内，最大的失败次数。当达到最大失败时，会在<code>fail_timeout</code>时间内不允许再次被选择。</li><li><code>fail_timeout</code>：单位为秒，默认是10秒。指定一段时间内，最大的失败次数<code>max_fails</code>。到达<code>max_fails</code>后，该server不能访问的时间。</li></ol><h3 id="简单的hash模块"><a href="#简单的hash模块" class="headerlink" title="简单的hash模块"></a>简单的hash模块</h3><p>有的时候，正常的轮询算法并不能满足我们的需求，</p><p>比如：带有cookie请求状态的连接，如果应用服务没有设置专门的管理cookie的服务器，那么我们就希望同一个用户能被分配到同一个服务器。</p><p>再比如：我们后端应用需要针对请求当中的参数或者URL，将相同的请求放到相同的服务器上进行处理。</p><p>针对第一种情况，就可以用<code>upstream_ip_hash</code>。针对第二种情况，可以使用<code>upstream_hash</code>。</p><h4 id="upstream-ip-hash"><a href="#upstream-ip-hash" class="headerlink" title="upstream_ip_hash"></a>upstream_ip_hash</h4><p>功能：</p><blockquote><p>以客户端的IP地址作为hash算法的关键字，映射到特定的上游服务器中。</p><ol><li>对IPV4地址使用前3个字节作为关键字，对IPV6则使用完整地址。</li><li>可以使用<code>round-robin</code>算法的参数。</li><li>可以基于<code>realip</code>模块修改用于执行算法的IP地址。</li></ol></blockquote><p>举个例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="upstream-hash"><a href="#upstream-hash" class="headerlink" title="upstream_hash"></a>upstream_hash</h4><p>功能：</p><blockquote><p>通过制定关键字作为hash key，基于hash算法映射到特定的上游服务器中。</p><ol><li>关键字可以含有变量、字符串。</li><li>可以使用<code>round-robin</code>算法的参数。</li></ol></blockquote><p>举个例子(以请求中的参数username作为hash key)：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    <span class="attribute">hash</span> user_<span class="variable">$arg_username</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>hash算法在一定程度上已经可以满足了我们的业务需求，但如果这个时候遇到应用宕机或者应用扩容，那么hash的总数就会变化，这样很有可能带来大量请求原本请求的服务器会更换，路由会失效，这样对于我们的应用服务也会产生极大的影响，这时候就可以采用一致性hash算法。</p><p>对于一致性哈希算法的理解，可以参考这篇文章：<a href="https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">一致性哈希算法的理解与实践</a></p><p>它的使用也十分简单，就是在之前说的<code>upstream_hash</code>模块的<code>hash</code>指令最后，添加参数<code>consistent</code>，这样Nginx就可以使用一致性哈希算法了。</p><p>举个例子(仍以请求中的参数username作为hash key)：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    <span class="attribute">hash</span> user_<span class="variable">$arg_username</span> consistent;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是Nginx中比较常见的负载均衡方法了，还有一些比如<code>最少连接算法</code>等，都是在此之上的一些应用。如果大家有什么疑问，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道，Nginx支持负载均衡，可以很方便的帮助我们进行水平扩容，然而它究竟是依据什么原则进行请求的分发，其中又有哪些负载均衡算法可供选择和配置，今天就让我们好好来了解一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>github博客Hexo引流到微信</title>
    <link href="http://yoursite.com/2019/09/26/github%E5%8D%9A%E5%AE%A2hexo%E5%BC%95%E6%B5%81%E5%88%B0%E5%BE%AE%E4%BF%A1/"/>
    <id>http://yoursite.com/2019/09/26/github博客hexo引流到微信/</id>
    <published>2019-09-26T05:31:59.000Z</published>
    <updated>2019-09-26T06:45:37.453Z</updated>
    
    <content type="html"><![CDATA[<p>相信有不少小伙伴都在github上创建了属于自己的博客，其中用<code>Hexo</code>的<code>Next</code>主题应该不少，那么，我们究竟该如何将博客的流量引流到微信呢？今天就来带你看一看。<br><a id="more"></a></p><h2 id="如何引流"><a href="#如何引流" class="headerlink" title="如何引流"></a>如何引流</h2><p>现在网上有一种套路，当你在看别人博客时，只能看一半，想继续看的话，需要扫码关注别人的公众号才能继续，这样的话，你的公众号粉丝自然就能蹭蹭上涨。</p><p>这里需要解决两个问题：</p><ol><li>文章看到一半就不允许继续观看</li><li>关注你的公众号后才能继续观看</li></ol><p>这里我是借助了<a href="https://openwrite.cn/" target="_blank" rel="noopener">OpenWrite</a>中的引流工具实现的。</p><h2 id="导流"><a href="#导流" class="headerlink" title="导流"></a>导流</h2><p>当你注册进入OpenWrite后，会有一个<code>博客导流公众号</code>功能，添加完相应的信息后，即可获得一段具有隐藏功能的<code>JS代码</code>：</p><p><img src="https://openwrite.cn/wp-content/uploads/2019/09/WeChat7c77e13e57068b5f402ad850e144e03d.png" alt=""></p><h2 id="如何设置文章看到一半"><a href="#如何设置文章看到一半" class="headerlink" title="如何设置文章看到一半"></a>如何设置文章看到一半</h2><p>这就需要我们在文章模块页面增加相应的隐藏功能，并且能够展示二维码并锁住页面。</p><h3 id="增加自定义swig文件"><a href="#增加自定义swig文件" class="headerlink" title="增加自定义swig文件"></a>增加自定义swig文件</h3><p>进入你的博客文件夹，在<code>themes\next\layout\_custom</code>文件夹中，新建一个<code>hide.swig</code>文件（这个文件夹专门用来存放自定义的一些代码），复制上文提到的JS代码，注意<code>id</code>的值，它默认用的是<code>container</code>，我设置成了<code>container-1</code>。</p><h3 id="修改文章模板文件"><a href="#修改文章模板文件" class="headerlink" title="修改文章模板文件"></a>修改文章模板文件</h3><p>进入你的博客文件夹，在<code>themes\next\layout</code>文件夹中，会有一个<code>_layout.swig</code>文件，这就是你的文章模板文件。其中有一段内容是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;main id=<span class="string">"main"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main-inner"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content-wrap"</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">"content"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">          &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p><code>id</code>为<code>content</code>的地方，就是你的文章内容，这时候你可以在外面再嵌套一层<code>div</code>，其<code>id</code>就是上面我设置的<code>container-1</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;main id=<span class="string">"main"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main-inner"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content-wrap"</span>&gt;</span><br><span class="line">      &lt;div id=<span class="string">"container-1"</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">"content"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">          &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>此时就可以发布你的博客，现在你的文章就会产生<code>阅读全文</code>的按钮了：</p><p><img src="https://i.loli.net/2019/09/25/YLjIcqtPlpvwCaZ.png" alt=""></p><p>按下这个按钮，就会弹出相应的二维码和你当初设置的关键字：</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092601.png" alt=""></p><h2 id="微信公众号自动回复设置"><a href="#微信公众号自动回复设置" class="headerlink" title="微信公众号自动回复设置"></a>微信公众号自动回复设置</h2><p>在微信公众号后台页面，选择<code>自动回复</code>-<code>关键词回复</code>，点击<code>添加回复</code>：</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092602.png" alt=""></p><p>填写<code>规则名称</code>、<code>关键词</code>(你当初在OpenWrite中设置的)，<code>回复内容</code>选择<code>文字</code>，填上<code>OpenWrite</code>中返回的那段文字。</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092603.png" alt=""></p><p>此时，当别人关注你的公众号并输入关键字后(比如我设置的关键字就是git)，就会显示回复了</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092604.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你的博客有一定的日活，那就千万不要错过这种微信涨粉、互相引流的机会。如果大家有什么疑问，欢迎在下方留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信有不少小伙伴都在github上创建了属于自己的博客，其中用&lt;code&gt;Hexo&lt;/code&gt;的&lt;code&gt;Next&lt;/code&gt;主题应该不少，那么，我们究竟该如何将博客的流量引流到微信呢？今天就来带你看一看。&lt;br&gt;
    
    </summary>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
      <category term="微信" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java中的interrupt</title>
    <link href="http://yoursite.com/2019/09/25/Java%E4%B8%AD%E7%9A%84interrupt/"/>
    <id>http://yoursite.com/2019/09/25/Java中的interrupt/</id>
    <published>2019-09-25T06:00:00.000Z</published>
    <updated>2019-09-25T07:25:57.555Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，Java中停止一个线程不能用<code>stop</code>，因为<code>stop</code>会瞬间强行停止一个线程，且该线程持有的锁并不能释放。大家多习惯于用<code>interrupt</code>，那么使用它又有什么需要注意的呢？<br><a id="more"></a></p><h2 id="interrupt相关的方法"><a href="#interrupt相关的方法" class="headerlink" title="interrupt相关的方法"></a>interrupt相关的方法</h2><p>Java中和interrupt相关的方法有三个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="boolean-isInterrupted"><a href="#boolean-isInterrupted" class="headerlink" title="boolean isInterrupted()"></a>boolean isInterrupted()</h3><p>每个线程都一个状态位用于标识当前线程对象是否是中断状态。<code>isInterrupted</code>主要用于判断当前线程对象的中断标志位是否被标记了，如果被标记了则返回true，表示当前已经被中断，否则返回false。我们也可以看看它的实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p>底层调用的native方法<code>isInterrupted</code>，传入一个boolean类型的参数，用于指定调用该方法之后是否需要清除该线程的中断标识位。从这里我们也可以看出来，调用<code>isInterrupted()</code>并不会清除线程的中断标识位。</p><h3 id="void-interrupt"><a href="#void-interrupt" class="headerlink" title="void interrupt()"></a>void interrupt()</h3><p><code>interrupt()</code>用于设置当前线程对象的中断标识位，其源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查当前线程是否有权限修改目标线程，如果没有，则会抛出异常SecurityException</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>blockerLock</code>和<code>blocker</code>都和阻塞IO时产生的中断相关，因此推测<code>interrupt()</code>需要当阻塞IO操作执行完之后，才可以执行。</p><p><code>interrupt()</code>其实只是改变了一个标志位，对于线程本身的状态并没有影响。</p><h3 id="boolean-interrupted"><a href="#boolean-interrupted" class="headerlink" title="boolean interrupted()"></a>boolean interrupted()</h3><p>该方法是一个静态的方法，用于返回当前线程是否被中断，其源码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：<code>该方法调用结束的时候会清空中断标识位</code>。</p><h2 id="线程的状态与中断的关系"><a href="#线程的状态与中断的关系" class="headerlink" title="线程的状态与中断的关系"></a>线程的状态与中断的关系</h2><p>我们知道，Java中的线程一共6种状态，分别是<code>NEW</code>，<code>RUNNABLE</code>，<code>BLOCKED</code>，<code>WAITING</code>，<code>TIMED_WAITING</code>，<code>TERMINATED</code>（Thread类中有一个State枚举类型列举了线程的所有状态）。下面我们就将把线程分别置于上述的不同种状态，然后看看中断操作对它们的影响。</p><h3 id="NEW和TERMINATED"><a href="#NEW和TERMINATED" class="headerlink" title="NEW和TERMINATED"></a>NEW和TERMINATED</h3><p><code>NEW</code>状态表示线程还未调用<code>start()</code>方法，<code>TERMINATED</code>状态表示线程已经运行终止。</p><p>这两个状态下调用中断方法来中断线程的时候，Java认为毫无意义，所以并不会设置线程的中断标识位。例如：</p><p><code>NEW</code>状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NEW</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p><code>TERMINATED</code>状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">    <span class="comment">// 开始线程</span></span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    thread.join();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TERMINATED</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>从上述的两个例子来看，处于<code>NEW</code>和<code>TERMINATED</code>状态的线程，对于中断是屏蔽的，也就是说中断操作对这两种状态下的线程是无效的。</p><h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h3><p>处于<code>RUNNABLE</code>状态的线程，当中断线程后，会修改其中断标志位，但并不会影响线程本身。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 什么都不做，就是空转</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure></p><p>中断标志位确实被改变了，但线程依旧继续运行。那我们调用<code>interrupt()</code>方法的意义在哪儿？</p><p>其实Java是将中断线程的权利交给了我们自己的程序，通过中断标志位，我们的程序可以通过<code>boolean isInterrupted()</code>方法来判断当前线程是否中断，从而决定之后的操作。</p><p>我们可以在此基础上，保证执行任务的原子性。例如修改<code>MyThread</code>类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">"exit MyThread"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line"></span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">exit MyThread</span><br><span class="line">TERMINATED</span><br></pre></td></tr></table></figure></p><h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h3><p>当线程处于<code>BLOCKED</code>状态，说明该线程由于竞争某个对象的锁失败而被挂在了该对象的阻塞队列上了。</p><p>那么此时发起中断操作不会对该线程产生任何影响，依然只是设置中断标志位。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 空转</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(thread1.getState());</span><br><span class="line">        System.out.println(thread2.getState());</span><br><span class="line"></span><br><span class="line">        System.out.println(thread2.isInterrupted());</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">        System.out.println(thread2.isInterrupted());</span><br><span class="line">        System.out.println(thread2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br><span class="line">BLOCKED</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">BLOCKED</span><br></pre></td></tr></table></figure></p><p>thread2处于<code>BLOCKED</code>状态，执行中断操作之后，该线程仍然处于<code>BLOCKED</code>状态，但是中断标志位却已被修改。</p><p>这种状态下的线程和处于<code>RUNNABLE</code>状态下的线程是类似的，给了我们程序更大的灵活性去判断和处理中断。</p><h3 id="WAITING-TIMED-WAITING"><a href="#WAITING-TIMED-WAITING" class="headerlink" title="WAITING/TIMED_WAITING"></a>WAITING/TIMED_WAITING</h3><p>这两种状态本质上是同一种状态，只不过<code>TIMED_WAITING</code>在等待一段时间后会自动释放自己，而<code>WAITING</code>则是无限期等待，需要其他线程调用类似<code>notify</code>方法释放自己。但是他们都是线程在运行的过程中由于缺少某些条件而被挂起在某个对象的等待队列上。</p><p>当这些线程遇到中断操作的时候，会抛出一个<code>InterruptedException</code>异常，并清空中断标志位。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"catch InterruptedException"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WAITING</span><br><span class="line">false</span><br><span class="line">catch InterruptedException</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>从运行结果看，当线程启动之后就被挂起到该线程对象的等待队列上，然后我们调用<code>interrupt()</code>方法对该线程进行中断，输出了我们在catch中的输出语句，显然是捕获了<code>InterruptedException</code>异常，接着就看到该线程的中断标志位被清空。</p><p>因此我们要么就在<code>catch</code>语句中结束线程，否则就在<code>catch</code>语句中加上<code>this.interrupt();</code>，再次设置标志位，这样也方便在之后的逻辑或者其他地方继续判断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们介绍了线程在不同状态下对于中断请求的反应：</p><ol><li><code>NEW</code>和<code>TERMINATED</code>对于中断操作几乎是屏蔽的。</li><li><code>RUNNABLE</code>和<code>BLOCKED</code>类似，对于中断操作只是设置中断标志位并没有强制终止线程，对于线程的终止权利依然在程序手中。</li><li><code>WAITING</code>和<code>TIMED_WAITING</code>状态下的线程对于中断操作是敏感的，他们会抛出异常并清空中断标志位。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道，Java中停止一个线程不能用&lt;code&gt;stop&lt;/code&gt;，因为&lt;code&gt;stop&lt;/code&gt;会瞬间强行停止一个线程，且该线程持有的锁并不能释放。大家多习惯于用&lt;code&gt;interrupt&lt;/code&gt;，那么使用它又有什么需要注意的呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="interrupt" scheme="http://yoursite.com/tags/interrupt/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java中的管程</title>
    <link href="http://yoursite.com/2019/06/29/Java%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/06/29/Java中的管程/</id>
    <published>2019-06-29T07:23:46.000Z</published>
    <updated>2019-06-29T09:00:35.927Z</updated>
    
    <content type="html"><![CDATA[<p>Java是利用<code>管程</code>解决并发编程问题的，那么究竟什么是<code>管程</code>？而它又是如何解决并发问题的呢？<br><a id="more"></a></p><h2 id="什么是管程"><a href="#什么是管程" class="headerlink" title="什么是管程"></a>什么是管程</h2><p>管程，英文名是 Monitor ，因此有的时候会被翻译为<code>监视器</code>。其实你也许很早就接触到这个概念了，比如 synchronized<br>关键字，很多文章就介绍过其原理是使用了<code>监视器</code>，只是你那个时候还并不知道<code>监视器</code>和<code>管程</code>，其实是一回事。</p><p>我们来看看维基百科上的概念：</p><blockquote><p>管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。</p></blockquote><p>感觉这句话听得有点迷糊，但下面这句话应该就很好理解了：</p><blockquote><p>管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。</p></blockquote><p>我的理解是：我们通过管程管理 Java 中的类，使得类是线程安全的。</p><p>这应该是<code>管程</code>最终要达到的效果，那么，它是怎么做到的呢？</p><h2 id="管程模型"><a href="#管程模型" class="headerlink" title="管程模型"></a>管程模型</h2><p>管程这个概念最早来源于操作系统，操作系统发展了那么多年，管程的实现也有多种方式，主流的有三种：<code>Hasen模型</code>、<code>Hoare模型</code>和<code>MESA模型</code>， Java 中借鉴的是<code>MESA模型</code>，让我们来重点看一下。</p><p>谈到<code>MESA模型</code>，就不得不提到并发主要解决2个核心问题：一个是<code>互斥</code>，即同一时刻只允许一个线程访问共享资源；另一个是<code>同步</code>，即多个线程之间如何通信、协作。</p><p>如何解决<code>互斥</code>呢？我们可以在操作共享变量之前，增加一个等待队列，每一个线程想要操作共享变量的话，都需要在等待队列中等待，直到管程选出一个线程操作共享变量。</p><p>那又是如何解决<code>同步</code>的呢？线程在操作共享变量时候，它不一定是直接执行，可能有一些自己的执行条件限制（比如取钱操作要求账户里一定要有钱，出队操作要求队列一定不能是空的），我们将这些限制称之为<code>条件变量</code>，每一个<code>条件变量</code>也有自己对应的<code>等待队列</code>，当线程发现自己的<code>条件变量</code>不满足时，就进入相应的<code>等待队列</code>中排队，直至<code>条件变量</code>满足，那么其<code>等待队列</code>中的线程也不会是立马执行，而是到最开始<code>共享变量</code>对应的<code>等待队列</code>中再次排队，重复之前的过程。</p><p>可以参考下面这幅图：</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019062901.png" alt=""></p><p>理论说了那么多，还是来看看用代码是如何实现的吧</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先可以自定一个支持并发的队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class MyQueen &#123;</span><br><span class="line"></span><br><span class="line">    // 共享变量（任何操作之前，都需要获得该锁才可以执行）</span><br><span class="line">    private final Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    // 条件变量：队列不满</span><br><span class="line">    private final Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    // 条件变量：队列不空</span><br><span class="line">    private final Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 存储队列的容器</span><br><span class="line">     */</span><br><span class="line">    private final LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 最大容量</span><br><span class="line">     */</span><br><span class="line">    private int capacity;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当前容器中存储的数量</span><br><span class="line">     */</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public MyQueen(int capacity) &#123;</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">        this.size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入队</span><br><span class="line">     */</span><br><span class="line">    public void enter(int value) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果队列已满，则需要等到队列不满</span><br><span class="line">            while (size &gt;= capacity) &#123;</span><br><span class="line">                notFull.await(1, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 入队</span><br><span class="line">            list.add(value);</span><br><span class="line">            size++;</span><br><span class="line">            System.out.println(value + &quot; has bean entered&quot;);</span><br><span class="line">            // 通知可以出队</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 出队</span><br><span class="line">     */</span><br><span class="line">    public int dequeue() &#123;</span><br><span class="line">        Integer result = null;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果队列已空，则需要等到队列不空</span><br><span class="line">            while (size &lt;= 0) &#123;</span><br><span class="line">                notEmpty.await(1, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 出队</span><br><span class="line">            result = list.removeFirst();</span><br><span class="line">            size--;</span><br><span class="line">            System.out.println(result + &quot; has bean dequeued&quot;);</span><br><span class="line">            // 通知可以入队</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyQueen myQueen = new MyQueen(3);</span><br><span class="line">        new Thread(new Pruducer(&quot;producer1&quot;, myQueen, 0, 2)).start();</span><br><span class="line">        new Thread(new Pruducer(&quot;producer2&quot;, myQueen, 2, 5)).start();</span><br><span class="line">        new Thread(new Consumer(&quot;consumer2&quot;, myQueen, 5)).start();</span><br><span class="line">        new Thread(new Consumer(&quot;consumer1&quot;, myQueen, 3)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义生产者和消费者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class Pruducer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private final MyQueen queen;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 该线程的名字</span><br><span class="line">     */</span><br><span class="line">    private final String name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开始的大小</span><br><span class="line">     */</span><br><span class="line">    private final int start;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 需要生产的资料个数</span><br><span class="line">     */</span><br><span class="line">    private final int size;</span><br><span class="line"></span><br><span class="line">    public Pruducer(String name, MyQueen queen, int start, int size) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.queen = queen;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 1; i &lt;= size; i++) &#123;</span><br><span class="line">            int now = start + i;</span><br><span class="line">//            System.out.println(name + &quot; produce : &quot; + now + &quot; start&quot;);</span><br><span class="line">            queen.enter(now);</span><br><span class="line">//            System.out.println(name + &quot; produce : &quot; + now + &quot; end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Consumer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private final MyQueen queen;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 该线程的名字</span><br><span class="line">     */</span><br><span class="line">    private final String name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 需要消费的资料个数</span><br><span class="line">     */</span><br><span class="line">    private final int size;</span><br><span class="line"></span><br><span class="line">    public Consumer(String name, MyQueen queen, int size) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.queen = queen;</span><br><span class="line">        this.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 1; i &lt;= size; i++) &#123;</span><br><span class="line">//            System.out.println(name + &quot; consume start&quot;);</span><br><span class="line">            int result = queen.dequeue();</span><br><span class="line">//            System.out.println(name + &quot; consume : &quot; + result + &quot; end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>做一个测试的main方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyQueen myQueen = new MyQueen(3);</span><br><span class="line">    new Thread(new Pruducer(&quot;producer1&quot;, myQueen, 0, 2)).start();</span><br><span class="line">    new Thread(new Pruducer(&quot;producer2&quot;, myQueen, 2, 5)).start();</span><br><span class="line">    new Thread(new Consumer(&quot;consumer1&quot;, myQueen, 3)).start();</span><br><span class="line">    new Thread(new Consumer(&quot;consumer2&quot;, myQueen, 5)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 has bean entered</span><br><span class="line">2 has bean entered</span><br><span class="line">3 has bean entered</span><br><span class="line">1 has bean dequeued</span><br><span class="line">2 has bean dequeued</span><br><span class="line">3 has bean dequeued</span><br><span class="line">4 has bean entered</span><br><span class="line">5 has bean entered</span><br><span class="line">6 has bean entered</span><br><span class="line">4 has bean dequeued</span><br><span class="line">5 has bean dequeued</span><br><span class="line">6 has bean dequeued</span><br><span class="line">7 has bean entered</span><br><span class="line">8 has bean entered</span><br><span class="line">9 has bean entered</span><br><span class="line">7 has bean dequeued</span><br><span class="line">8 has bean dequeued</span><br><span class="line">9 has bean dequeued</span><br></pre></td></tr></table></figure></p><p>虽然满足我想要的结果，但显示的内容有些奇怪，总是容器先被填满之后，然后容器被清空，感觉原因应该和<code>可重入锁</code>有关。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我对于管程的一些理解，如果大家有什么疑问，欢迎在下方留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java是利用&lt;code&gt;管程&lt;/code&gt;解决并发编程问题的，那么究竟什么是&lt;code&gt;管程&lt;/code&gt;？而它又是如何解决并发问题的呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="管程" scheme="http://yoursite.com/tags/%E7%AE%A1%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>nginx报错111: Connection refused</title>
    <link href="http://yoursite.com/2019/06/06/Nginx%E6%8A%A5%E9%94%99111-Connection-refused/"/>
    <id>http://yoursite.com/2019/06/06/Nginx报错111-Connection-refused/</id>
    <published>2019-06-06T04:22:41.000Z</published>
    <updated>2019-09-30T01:38:12.826Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了Nginx疯狂抛错，access.log一天一共5W多条，但error.log中有大概9K多条，基本都是<code>111: Connection refused</code>，这到底是为什么呢？<br><a id="more"></a></p><h2 id="从日志看起"><a href="#从日志看起" class="headerlink" title="从日志看起"></a>从日志看起</h2><p>我们还是先来看日志。我提取了一条error.log当中抛错的日志(稍微分一下行，否则实在太长，敏感信息稍微处理了一下):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019/06/06 10:09:45 [error] 28652#0: *883239 connect() failed (111: Connection refused) while connecting to upstream, </span><br><span class="line">client: 124.104.90.145, server: xxx.xxxxx.com, request: &quot;POST /test-service/upload?mcachenum=155978698 HTTP/1.1&quot;, </span><br><span class="line">upstream: &quot;http://[::1]:17000/test-service/upload?mcachenum=155978698&quot;, host: &quot;xxx.xxxxx.com&quot;, </span><br><span class="line">referrer: &quot;https://servicewechat.com/x98b46f69/2/page-frame.html&quot;</span><br></pre></td></tr></table></figure></p><p>看了一下前面的报错和后面的描述，第一眼看上去感觉都是正常。但再看之后发现，<code>upstream</code>中的host有些不一样。<code>[::1]</code>，这实际是一个IPv6的地址。</p><p>这时候你可以查看一下你的机器是否开启了IPv6的地址，linux的命令是：<code>ip address</code>，看看返回结果中是否出现了<code>inet6</code>，如果有，那么恭喜你，原因找到了。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决方法有两种，一个是禁用你机器的IPv6配置，另一个则是修改nginx.conf中的配置。</p><p>个人觉得后一个方法更加保险一些，因为这不涉及到你的机器配置，应该相对而言最少。</p><p>nginx.conf的修改，则是针对<code>server</code>模块中的<code>location</code>，修改<code>proxy_pass</code>中的host，我们在网上经常看到别人用的是：</p><p><code>proxy_pass http://localhost:18000/test-service/;</code></p><p>但为了强制指定IPv4的地址，需要变成：</p><p><code>proxy_pass http://127.0.0.1:18000/test-service/;</code></p><p>这样操作之后，再观察nginx的error.log，应该就不会再报upstream里含有IPv6地址的错误了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我这次错误的整个过程，虽然整个过程不长，但确实让我知道了，作为一个后端开发，我的知识面还是太窄了。而且Bing也是真的好用，最近无法翻墙了，暂时用Bing代替，感觉还是不错的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到了Nginx疯狂抛错，access.log一天一共5W多条，但error.log中有大概9K多条，基本都是&lt;code&gt;111: Connection refused&lt;/code&gt;，这到底是为什么呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
      <category term="[object Object]" scheme="http://yoursite.com/tags/object-Object/"/>
    
      <category term="upstream" scheme="http://yoursite.com/tags/upstream/"/>
    
      <category term="IPv6" scheme="http://yoursite.com/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>力扣-65不同路径</title>
    <link href="http://yoursite.com/2019/05/10/%E5%8A%9B%E6%89%A3-65%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/05/10/力扣-65不同路径/</id>
    <published>2019-05-10T11:10:11.000Z</published>
    <updated>2019-09-11T10:44:43.726Z</updated>
    
    <content type="html"><![CDATA[<p>最近在刷力扣上的题目，刷到了<a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">65不同路径</a>，当初上大学的时候，曾在hihocoder上刷到过这道题目，但是现在已经几乎全忘光了，大概的知识点是动态规划，如今就让我们一起来回顾一下。<br><a id="more"></a></p><h2 id="从题目说起"><a href="#从题目说起" class="headerlink" title="从题目说起"></a>从题目说起</h2><p>题目原文是：</p><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p></blockquote><blockquote><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p></blockquote><blockquote><p>问总共有多少条不同的路径？</p></blockquote><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/20190510.png" alt=""></p><blockquote><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p></blockquote><blockquote><p>说明：m 和 n 的值均不超过 100。</p></blockquote><blockquote><p>示例 1:</p></blockquote><blockquote><blockquote><p>输入: m = 3, n = 2</p></blockquote></blockquote><blockquote><blockquote><p>输出: 3</p></blockquote></blockquote><blockquote><blockquote><p>解释:</p></blockquote></blockquote><blockquote><blockquote><p>从左上角开始，总共有 3 条路径可以到达右下角。</p></blockquote></blockquote><blockquote><blockquote><ol><li>向右 -&gt; 向右 -&gt; 向下</li></ol></blockquote></blockquote><blockquote><blockquote><ol start="2"><li>向右 -&gt; 向下 -&gt; 向右</li></ol></blockquote></blockquote><blockquote><blockquote><ol start="3"><li>向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote></blockquote><blockquote><p>示例 2:</p></blockquote><blockquote><blockquote><p>输入: m = 7, n = 3</p></blockquote></blockquote><blockquote><blockquote><p>输出: 28</p></blockquote></blockquote><h2 id="正向思路"><a href="#正向思路" class="headerlink" title="正向思路"></a>正向思路</h2><p>我们先按照正常思路来想一下，当你处于起点时，你有两个选择，向右或者向下，除非你处于最下面一排或者最右边一列，那你只有一种选择（比如处于最下面一排，你只能往右），其他位置，你都有两种选择。</p><p>因此，我们就根据这个思路，可以写出代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        // 特殊情况：起点即终点</span><br><span class="line">        if (m == 1 &amp;&amp; n == 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当前处于(1,1)，终点为(m,n)</span><br><span class="line">        return walk(1, 1, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int walk(int x, int y, int m, int n)&#123;</span><br><span class="line">        // 已经处于终点</span><br><span class="line">        if (x &gt;= m &amp;&amp; y &gt;= n) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 处于最下面一排或者最右边一列</span><br><span class="line">        if (x &gt;= m || y &gt;= n) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 往下走，有多少种走法</span><br><span class="line">        int down = walk(x, y + 1, m, n);</span><br><span class="line">        // 往右走，有多少种走法</span><br><span class="line">        int right = walk(x + 1, y, m, n);</span><br><span class="line">        // 从当前(x,y)出发，走到(m,n)，共有多少种走法</span><br><span class="line">        return down + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们考虑一下，这种写法，有没有可以优化的地方。</p><p>你们应该一眼就发现，<code>walk</code>方法的第一个判断<code>if (x &gt;= m &amp;&amp; y &gt;= n)</code>，永远都不可能为<code>true</code>，因为下一个判断<code>if (x &gt;= m || y &gt;= n)</code>就已经是临界点情况，直接就已经有返回值，根本不可能达到<code>x &gt;= m &amp;&amp; y &gt;= n</code>的情况。因此，该判断可以删除。</p><p>假设我们从(1,1)的位置出发，终点是(3,3)，那么到达(2,2)这个中间点的话有几种走法呢？两种，先到(1,2)再到(2,2)，或者，先到(2,1)再到(2,2)。</p><p>因此，如果根据我们上面的写法，从(2,2)到终点(3,3)，我们会算两次，虽然这样的思路本身是正确，但这样的情况应该是可以优化的。因为从(1,1)到(3,3)，一共只有6种路径，但已经有2条是重复的路径了，那么随着<code>m</code>与<code>n</code>越来越大，中间点会越来越多，那么重复的路径也会越来越多。</p><p>这就是<code>前面的选择</code>对于<code>后面的选择</code>会有影响，即使<code>后面的选择</code>相同，但由于<code>前面的选择</code>不同，从而也被认为是不同的选择。</p><p>很明显，<code>后面的选择</code>更加唯一，如果我们先在后面做出选择，那么就可以减少重复计算的次数。因此，我们可以试试反向思路。</p><h2 id="反向思路"><a href="#反向思路" class="headerlink" title="反向思路"></a>反向思路</h2><p>如果我们不是从起点出发，而是从终点倒退到起点开始算的话。假设终点是(3,3)，它只能由(2,3)和(3,2)直接到达，(2,3)也只能由(2,2)和(1,3)直接到达，(1,3)只能由(1,2)直接到达，(1,2)只能由(1,1)直接到达，因此(1,3)只能由(1,1)直达。</p><p>我们可以得出规律：除了最左边一列和最上面一排的点，只能由起点(1,1)直达以外，其他的点(x,y)都是由(x-1,y)和(x,y-1)两个点直接到达的。</p><p>因此，根据这个思路，我们可以写出代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] result = new int[m][n];</span><br><span class="line">        int j;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (i == 0 || j == 0) &#123;</span><br><span class="line">                    // 最上面一排的点和最左边一列的点，只能由(1,1)到达</span><br><span class="line">                    result[i][j] = 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 其他的点都可以由左边的点和上面的点到达</span><br><span class="line">                    result[i][j] = result[i - 1][j] + result[i][j - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return result[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实这样的想法就已经是<code>动态规划</code>的范畴了，我们看看维基上的定义</p><blockquote><p>动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p></blockquote><p>一开始我感觉很像<code>分治法</code>，因为都需要将一个大问题分解为子问题，但<code>分治法</code>最终会将子问题合并，但<code>动态规划</code>却不用。</p><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>我们考虑一下，这种写法，有没有可以优化的地方。</p><p>首先是空间上的优化，我们一定要用二维数组吗？可以用一维数组代替吗？</p><p>答案是肯定的，因为每个点的计算只和左边与上边相邻的点有关，因此，不需要更加久远的点。</p><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><p>假如只用一维数组，那么只需要存储上一排的结果，如果计算到下一排的时候，则依次替换，代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] dp = new int[m];</span><br><span class="line">        int j;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if(j == 0) &#123;</span><br><span class="line">                    dp[j] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 其他的点都可以由左边的点和上面的点到达</span><br><span class="line">                    dp[j] += dp[j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[m-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的优化，差不多就结束了。那我们是否可以从思路上进行优化呢？</p><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>因为我们只有向右或向下两种选择，而我们一共要走的路径其实是<code>(m-n-2)</code>，其中有<code>(m-1)</code>的路径是向右，<code>(n-1)</code>的路径是向下，其实可以转变为：</p><blockquote><p>从<code>(m-n-2)</code>中挑出<code>(m-1)</code>，即组合数<code>C((m-n-2), (m-1))</code>的值</p></blockquote><p>那么我们可以写出代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        // 用double，因为计算出的数值会很大</span><br><span class="line">        double num = 1, denom = 1;</span><br><span class="line">        // 找出更小的数，这样可以减少计算次数和计算出的数值</span><br><span class="line">        int small = m &gt; n ? n : m;</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt;= small - 1; ++i) &#123;</span><br><span class="line">            num *= m + n - 1 - i;</span><br><span class="line">            denom *= i;</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">         return (int)(num / denom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##总结</p><p>以上就是我做这道题的一些思路和想法了，虽然题目本身不难，但可以讨论的点还是很多的，如果大家有什么疑问，欢迎在下方留言。</p><p>有兴趣的话可以关注我的公众号，说不定会有意外的惊喜。</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在刷力扣上的题目，刷到了&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;65不同路径&lt;/a&gt;，当初上大学的时候，曾在hihocoder上刷到过这道题目，但是现在已经几乎全忘光了，大概的知识点是动态规划，如今就让我们一起来回顾一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="组合数" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JWT与Session的比较</title>
    <link href="http://yoursite.com/2019/04/24/JWT%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/24/JWT的管理/</id>
    <published>2019-04-24T08:02:37.000Z</published>
    <updated>2019-04-24T11:24:02.723Z</updated>
    
    <content type="html"><![CDATA[<p>如今，越来越多的项目开始采用<code>JWT</code>作为认证授权机制，那么它和之前的<code>Session</code>究竟有什么区别呢？今天就让我们来了解一下。<br><a id="more"></a></p><h2 id="JWT是什么"><a href="#JWT是什么" class="headerlink" title="JWT是什么"></a><code>JWT</code>是什么</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑和自包含的方式，用于在各方之间作为JSON对象安全地传输信息。作为标准，它没有提供技术实现，但是大部分的语言平台都有按照它规定的内容提供了自己的技术实现，所以实际在用的时候，只要根据自己当前项目的技术平台，到官网上选用合适的实现库即可。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>使用JWT来传输数据，实际上传输的是一个字符串，这个字符串就是所谓的json web token字符串。所以广义上，JWT是一个标准的名称；狭义上，JWT指的就是用来传递的那个token字符串。这个串有两个特点：</p><ol><li>紧凑：指的是这个串很小，能通过url 参数，http 请求提交的数据以及http header的方式来传递；</li><li>自包含：这个串可以包含很多信息，比如用户的id、角色等，别人拿到这个串，就能拿到这些关键的业务信息，从而避免再通过数据库查询等方式才能得到它们。</li></ol><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019042401.png" alt="JWT结构"></p><p>它由三部分组成：header（头部）、payload（载荷）、signature（签名），以<code>.</code>进行分割。（这个字符串本来是只有一行的，此处分成3行，只是为了区分其结构）</p><ol><li><code>header</code>用来声明类型（typ）和算法（alg）。</li><li><code>payload</code>一般存放一些不敏感的信息，比如用户名、权限、角色等。</li><li><code>signature</code>则是将<code>header</code>和<code>payload</code>对应的json结构进行base64url编码之后得到的两个串用英文句点号拼接起来，然后根据<code>header</code>里面alg指定的签名算法生成出来的。</li></ol><h2 id="和Session的区别"><a href="#和Session的区别" class="headerlink" title="和Session的区别"></a>和<code>Session</code>的区别</h2><p>为什么我们要把<code>JWT</code>和<code>Session</code>做对比呢？因为我们主要在每一次请求的认证时会用<code>JWT</code>，在此之前我们都是用<code>Session</code>的。那这两者的区别在哪儿呢？</p><h3 id="本身的含义"><a href="#本身的含义" class="headerlink" title="本身的含义"></a>本身的含义</h3><p>看了前面的介绍，我们发现<code>JWT</code>这个字符串其实本身就包含了关于用户的信息，比如用户名、权限、角色等。</p><p><code>Session</code>传递的sessionId虽然是一个更简单的字符串，但它本身并没有任何含义。</p><p>所以一般说来<code>JWT</code>的字符串要比sessionId长，如果你在<code>JWT</code>中存储的信息越长，那么<code>JWT</code>本身也会越长。</p><p>而<code>Cookie</code>的存储容量是有限制的（通常为4KB），所以大家在使用的时候需要注意。</p><h3 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h3><p><code>JWT</code>的header和payload其实是有json转变过来的，而<code>signature</code>其实就是一个加密后的字符串，因此解析起来较为简单，不需要其他辅助的内容。</p><p>sessionId是服务器存储的用户对象的标识，理论上需要一个额外的map才能找出当前用户的信息。</p><h3 id="管理方法"><a href="#管理方法" class="headerlink" title="管理方法"></a>管理方法</h3><p><code>JWT</code>理论上用于无状态的请求，因此其用户管理也只是依赖本身而已。我们一般是在它的<code>payload</code>中加入过期时间，在不增加额外管理的情况下，它只有自动过期的方式。</p><p><code>Session</code>因为它本就是存储在服务器端的，因此管理方案就有很多，而且大多都很成熟。</p><h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p><code>JWT</code>本身就是基于json的，因此它是比较容易跨平台的，可以从官网下载不同平台的包，解析即可。</p><p>session的跨平台可能就不那么好做了，需要考虑的地方在于用户信息存储的格式，ProtoBuf、json、xml等，管理的话可能就需要专门的统一登录平台，这个就不展开了。</p><h3 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h3><p>无状态<code>JWT</code>一旦被生成，就不会再和服务端有任何瓜葛。一旦服务端中的相关数据更新，无状态<code>JWT</code>中存储的数据由于得不到更新，就变成了过期的数据。</p><p>session就不一样了，sessionId本身就没有太多含义，只需修改服务端中存储的数据即可。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a><code>JWT</code></h3><p><code>JWT</code>的最佳用途是<code>一次性授权Token</code>，这种场景下的Token的特性如下：</p><ul><li>有效期短</li><li>只希望被使用一次</li></ul><p>真实场景的例子——文件托管服务，由两部分组成：</p><ul><li>Web 应用：这是一个可以被用户登录并维持状态的应用，用户在应用中挑选想要下载的文件。</li><li>文件下载服务：无状态下载服务，只允许通过密钥下载。</li></ul><p>如何把<code>JWT</code>用在这个场景中呢？</p><ol><li>用户登录到 Web 应用中，挑选好想要下载的文件，点击下载。</li><li><p>认证服务颁发包含下载信息的、具有较短过期时间的JWT。JWT中包含的信息可以是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;file&quot;: &quot;/books/我这一辈子.pdf&quot;,</span><br><span class="line">    &quot;exp&quot;: 1500719759621</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 JWT 从文件下载服务下载文件。</p></li></ol><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a><code>Session</code></h3><p><code>Session</code>比较适用于Web应用的会话管理，其特点一般是：</p><ul><li>权限多，如果用<code>JWT</code>则其长度会很长，很有可能突破Cookie的存储限制。</li><li>基本信息容易变动。如果是一般的后台管理系统，肯定会涉及到人员的变化，那么其权限也会相应变化，如果使用<code>JWT</code>，那就需要服务器端进行主动失效，这样就将原本无状态的<code>JWT</code>变成有状态，改变了其本意。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们使用<code>JWT</code>，并不是说看到它新就用，而应该考虑其适用场景，如果需要进行管理，可以考虑使用<code>Session</code>，毕竟其方案更加成熟。如果大家有什么新发现想和作者探讨的，欢迎在下方留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如今，越来越多的项目开始采用&lt;code&gt;JWT&lt;/code&gt;作为认证授权机制，那么它和之前的&lt;code&gt;Session&lt;/code&gt;究竟有什么区别呢？今天就让我们来了解一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="JWT" scheme="http://yoursite.com/tags/JWT/"/>
    
      <category term="Session" scheme="http://yoursite.com/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>TCP连接及其优化</title>
    <link href="http://yoursite.com/2019/04/18/TCP%E8%BF%9E%E6%8E%A5%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/18/TCP连接及其优化/</id>
    <published>2019-04-18T10:37:33.000Z</published>
    <updated>2019-10-04T02:07:26.144Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个后端程序员，网络连接这块是一个绕不过的砍，当你在做服务器优化的时候，网络优化也是其中一环，那么作为网络连接中最基础的部分-<code>TCP连接</code>你了解吗？今天我们来仔细看看这个部分。<br><a id="more"></a></p><h2 id="TCP建立连接-三次握手"><a href="#TCP建立连接-三次握手" class="headerlink" title="TCP建立连接-三次握手"></a>TCP建立连接-三次握手</h2><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019041801.jpg?raw=true" alt="三次握手"></p><ol><li>客户端和服务器还未建立连接，但服务器一般处于<code>listen</code>状态</li><li>客户端主动建立连接，向服务器发送SYN报文，客户端变为<code>SYN_SENT</code>状态</li><li>服务器收到客户端发送的报文，也回了一个SYN报文，包含了一个ack。此时，服务器变为<code>SYN_RCVD</code>状态</li><li>客户端收到了服务器发送的SYN报文，确认了ack，它将向服务器发送一个ACK报文。此时，客户端变为<code>ESTABLISHED</code></li><li>服务器收到客户端的ACK报文，确认了ack。此时，服务器也变为<code>ESTABLISHED</code></li><li>服务器和客户端可以正常通信了</li></ol><p>其中步骤2~4就是三次握手，那么为什么需要三次握手呢？为什么不是一次或者两次握手呢？</p><p>首先，我们需要知道，只有当服务器和客户端都能确保自己能够发消息和接收消息，这次网络通信才算成功的。</p><p>步骤2的作用是让服务器知道了自己是可以接收消息的。</p><p>步骤3的作用是让客户端知道自己发送消息和接收消息的功能是OK的，发送消息的能力是通过服务器返回的<code>ack=x+1</code>确认的，因为这个值基于当初客户端发送的消息<code>seq=x</code>。接收消息的能力是因为收到了服务器的返回。</p><p>步骤4的作用是让服务器端知道自己发送消息的能力是OK的（和步骤3类似）。</p><h3 id="linux查看"><a href="#linux查看" class="headerlink" title="linux查看"></a>linux查看</h3><p>linux服务器可以利用<code>netstat -anp | grep tcp</code>命令，查看服务器上各个端口和应用的连接状态。</p><p>你还可以通过修改linux的配置文件<code>/etc/sysctl.conf</code>，调整各个状态的数量</p><h4 id="SYN-SENT状态相关"><a href="#SYN-SENT状态相关" class="headerlink" title="SYN_SENT状态相关"></a><code>SYN_SENT</code>状态相关</h4><ul><li><p>主动建立连接时，发SYN（步骤2）的重试次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nct.ipv4.tcp_syn_rctries = 6</span><br></pre></td></tr></table></figure></li><li><p>建立连接时的本地端口可用范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_local_port_range = 32768 60999</span><br></pre></td></tr></table></figure></li></ul><h4 id="SYN-RCVD状态相关"><a href="#SYN-RCVD状态相关" class="headerlink" title="SYN_RCVD状态相关"></a><code>SYN_RCVD</code>状态相关</h4><ul><li><p><code>SYN_RCVD</code>状态连接的最大个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_max_syn_backlog</span><br></pre></td></tr></table></figure></li><li><p>被动建立连接时，发SYN/ACK（步骤3）重试次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_synack_retries</span><br></pre></td></tr></table></figure></li></ul><p>说完了TCP建立连接，接下来，我们再来看看TCP正常断开连接的过程</p><h2 id="TCP断开连接-四次挥手"><a href="#TCP断开连接-四次挥手" class="headerlink" title="TCP断开连接-四次挥手"></a>TCP断开连接-四次挥手</h2><h3 id="详解-1"><a href="#详解-1" class="headerlink" title="详解"></a>详解</h3><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019041802.jpg?raw=true" alt="四次挥手"></p><ol><li>客户端与服务器端正常传输数据</li><li>客户端主动断开连接，向服务器端发送FIN报文，客户端变为<code>FIN_WAIT1</code>状态</li><li>服务器收到客户端的FIN后，向客户端发送ACK报文，服务器变为<code>CLOSE_WAIT</code>状态</li><li>客户端收到服务器的ACK报文后，客户端变为<code>FIN_WAIT2</code>状态</li><li>服务器向客户端发送FIN报文，服务器变为<code>LAST_ACK</code>状态</li><li>客户端收到服务器发送的FIN报文后，向服务器发送ACK报文，客户端变为<code>TIME_WAIT</code>状态</li><li>服务器收到客户端的ACK报文后，服务器变为<code>CLOSED</code>状态</li><li>客户端经过2MSL(max segment lifetime，报文最大生存时间)时间后，也变为<code>CLOSED</code>状态</li></ol><p>其中，步骤2、3、5、6即为4次挥手。</p><h3 id="TIME-WAIT状态及其优化"><a href="#TIME-WAIT状态及其优化" class="headerlink" title="TIME_WAIT状态及其优化"></a><code>TIME_WAIT</code>状态及其优化</h3><p>看完之后，大家想必会有一个疑问，为什么<code>TIME_WAIT</code>状态需要保持2MSL？因为这可以保证至少一次报文的往返时间内，端口是不可复用的。</p><p>假设<code>TIME_WAIT</code>状态的持续时间很短，我们来模拟下面这种场景：<br><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019041901.png?raw=true" alt=""></p><ul><li>客户端向服务器端发送了三条报文，其中第3条报文卡在网络中，服务器只收到了前两条，向客户单发送ACK=2，客户端重新发送第三条报文。</li><li>服务器主动发送FIN报文，客户端收到后发送FIN、ACK，服务器端收到后发送ACK并进入<code>TIME_WAIT</code>状态（假设这个状态很短）。</li><li>现在服务器又再次和客户端建立连接，三次握手之后开始发送正常数据，结果之前卡住的第三条报文，现在终于发送到服务器，但服务器也不知道该如何处理这条报文。</li></ul><p>因此这也是<code>TIME_WAIT</code>状态需要保持2MSL的原因，如果这么长时间也没有收到报文，即使有正确的报文从客户端发出，也已经过期了，因此不会影响到之后的通信。</p><p>但这同样也会带来一个问题，<code>TIME_WAIT</code>状态保持的时间较长，假设服务器端有大量<code>TIME_WAIT</code>状态的TCP连接，就相当于白白浪费掉大量的服务器资源(端口)。此时，我们可以通过修改以下配置进行服务器调优：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br></pre></td></tr></table></figure></p><ul><li>开启后，作为客户端时新连接可以使用仍然处于<code>TIME_WAIT</code>状态的端口</li><li>由于timestamp的存在，操作系统可以拒绝迟到的报文（例如上面说的第三条报文），可以利用以下配置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps = 1</span><br></pre></td></tr></table></figure><h3 id="其他状态的优化"><a href="#其他状态的优化" class="headerlink" title="其他状态的优化"></a>其他状态的优化</h3><h4 id="CLOSE-WAIT状态"><a href="#CLOSE-WAIT状态" class="headerlink" title="CLOSE_WAIT状态"></a><code>CLOSE_WAIT</code>状态</h4><p>如果服务器端有大量<code>CLOSE_WAIT</code>状态的连接，很有可能是应用进程出现bug，没有及时关闭连接。</p><h4 id="FIN-WAIT1状态"><a href="#FIN-WAIT1状态" class="headerlink" title="FIN_WAIT1状态"></a><code>FIN_WAIT1</code>状态</h4><p>调整发送FIN报文的重试次数，0相当于8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_orphan_retries = 0</span><br></pre></td></tr></table></figure></p><h4 id="FIN-WAIT2状态"><a href="#FIN-WAIT2状态" class="headerlink" title="FIN_WAIT2状态"></a><code>FIN_WAIT2</code>状态</h4><p>调整保持在<code>FIN_WAIT2</code>状态的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_fin_timeout = 60</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到这里，想必你应该对TCP连接有了一个大致的了解。现在服务器大多都用了nginx做了负载均衡，因此，我们可能需要在此基础上了解一些nginx相关的配置原理，这样应该会对我们的服务器性能调优会有更大的帮助。有兴趣的同学不妨可以去了解一下，如果有什么新发现想和作者探讨的，欢迎在下方留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个后端程序员，网络连接这块是一个绕不过的砍，当你在做服务器优化的时候，网络优化也是其中一环，那么作为网络连接中最基础的部分-&lt;code&gt;TCP连接&lt;/code&gt;你了解吗？今天我们来仔细看看这个部分。&lt;br&gt;
    
    </summary>
    
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Java中容器的遍历</title>
    <link href="http://yoursite.com/2019/04/17/Java%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/04/17/Java中容器的遍历/</id>
    <published>2019-04-17T10:44:42.000Z</published>
    <updated>2019-04-18T02:05:53.515Z</updated>
    
    <content type="html"><![CDATA[<p>当我们用增强for循环遍历非并发容器（HashMap、ArrayList等），如果修改其结构，会抛出异常<code>ConcurrentModificationException</code>，因此在阿里巴巴的Java规范中有说到：<code>不要在foreach循环里进行元素的remove/add操作，remove元素请使用Iterator方式。</code>，但是不是真的就不可以在增强for循环中修改结构吗？其原理又是什么呢？<br><a id="more"></a></p><h2 id="ConcurrentModificationException的含义"><a href="#ConcurrentModificationException的含义" class="headerlink" title="ConcurrentModificationException的含义"></a>ConcurrentModificationException的含义</h2><p><code>ConcurrentModificationException</code>可以将其通俗的翻译为<code>并发修改异常</code>，那么关注点就在<code>并发</code>和<code>修改</code>了。也许有些人会说，我只是在单线程中修改了，并没有并发操作，但系统也抛了这样的这样的错误，这是为什么呢？别急，我们看看它的源码解释：</p><blockquote><p>This exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible.</p></blockquote><p>这个异常就是应用程序在做一些系统不允许的操作时抛出的。记住，只要是系统不允许的操作，就一定会抛错的。</p><p>后面有一个值得注意的地方</p><blockquote><p>Note that fail-fast behavior cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast operations throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: ConcurrentModificationException should be used only to detect bugs.</p></blockquote><p><code>fail-fast</code>（快速失败）并不能一定被保证，所以<code>fail-fast</code>操作会尽最大努力抛出该异常。既然是尽最大努力，因此无论是不是并发操作，只要是修改了，就一定会报错。</p><p>既然如此，我们来看看for循环中遍历修改容器结构，系统是如何知道的。</p><h2 id="增加for循环的原理"><a href="#增加for循环的原理" class="headerlink" title="增加for循环的原理"></a>增加for循环的原理</h2><p>我们来看看增强for循环遍历修改HashMap的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(10);</span><br><span class="line">// 添加</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  hashMap.put(&quot;key&quot; + i, &quot;value&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">// 遍历修改</span><br><span class="line">for (Entry&lt;String, String&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">  String key = entry.getKey();</span><br><span class="line">  hashMap.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候，你如果运行的话，就会抛出<code>ConcurrentModificationException</code>，这个时候我们需要具体调试一下，发现遍历第一次并删除时没有报错，但第二次遍历，在for循环的括号执行完后，就抛出了异常，这又是为什么呢？</p><p>让我们反编译一下class文件，看看究竟增强for循环做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = new HashMap(10);</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">  hashMap.put(&quot;key&quot; + i, &quot;value&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator var5 = hashMap.entrySet().iterator();</span><br><span class="line">while(var5.hasNext()) &#123;</span><br><span class="line">  Entry&lt;String, String&gt; entry = (Entry)var5.next();</span><br><span class="line">  String key = (String)entry.getKey();</span><br><span class="line">  hashMap.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们发现，虽然写法上是增强for循环，但实际还是使用的<code>while</code>结合<code>iterator</code>进行遍历，现在我们贴上这个代码进行调试。</p><p>发现在第二次<code>var5.next()</code>处抛异常，接下来我们看看<code>next</code>方法究竟做了什么？</p><p>在<code>HashMap</code>的源码中显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final class EntryIterator extends HashIterator</span><br><span class="line">    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">    public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; nextNode() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] t;</span><br><span class="line">    Node&lt;K,V&gt; e = next;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123;</span><br><span class="line">        do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class="line">    &#125;</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们注意到，<code>nextNode()</code>方法的第一个判断就决定了是否抛出<code>ConcurrentModificationException</code>，那么<code>modCount</code>和<code>expectedModCount</code>究竟是什么呢？</p><h2 id="modCount和expectedModCount"><a href="#modCount和expectedModCount" class="headerlink" title="modCount和expectedModCount"></a>modCount和expectedModCount</h2><p>我们来看看<code>modCount</code>和<code>expectedModCount</code>的关系，当我们调用<code>Iterator var5 = hashMap.entrySet().iterator();</code>时，源代码做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    Node&lt;K,V&gt;[] t = table;</span><br><span class="line">    current = next = null;</span><br><span class="line">    index = 0;</span><br><span class="line">    if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry</span><br><span class="line">        do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在一开始，就让<code>expectedModCount</code>等于<code>modCount</code>，而当我们调用<code>hashMap.remove(key);</code>时，实际上修改了<code>modCount</code>的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        else if ((e = p.next) != null) &#123;</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">            else if (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            else</span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>modCount</code>增大1，那么，当我们下一次调用<code>var5.next()</code>时，自然就发现<code>modCount</code>和<code>expectedModCount</code>不等了。</p><h2 id="修改结构的正确姿势"><a href="#修改结构的正确姿势" class="headerlink" title="修改结构的正确姿势"></a>修改结构的正确姿势</h2><p>使用<code>增强for循环</code>，本质还是在使用<code>iterator</code>，那为什么大家都在推介使用<code>iterator.remove()</code>呢？让我们看看源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final void remove() &#123;</span><br><span class="line">    Node&lt;K,V&gt; p = current;</span><br><span class="line">    if (p == null)</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    current = null;</span><br><span class="line">    K key = p.key;</span><br><span class="line">    removeNode(hash(key), key, null, false, false);</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们发现，这个remove方法虽然也调用了<code>removeNode</code>，但它在最后一步再次将<code>modCount</code>的值赋给<code>expectedModCount</code>，因此保证了下一次调用<code>next()</code>方法是不抛错。</p><p>所以，我们要么就直接显示地使用<code>iterator</code>，用它的<code>remove</code>方法移除对象。如果你实在想用<code>增强for循环</code>遍历删除，那么也只能在删除一个后，立刻退出循环。但无论用哪种方法，当多个线程同时修改时，都会有出错的可能性，因为你即时保证单个线程内的<code>modCount</code>和<code>expectedModCount</code>，但这个操作并不能保证原子性。</p><p>因此，如果在多线程环境下，我更推介使用<code>ConcurrentHashMap</code>，因为它没有<code>modCount</code>和<code>expectedModCount</code>的概念，因此，即时你是使用<code>增强for循环</code>遍历删除，也不会出现问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们用增强for循环遍历非并发容器（HashMap、ArrayList等），如果修改其结构，会抛出异常&lt;code&gt;ConcurrentModificationException&lt;/code&gt;，因此在阿里巴巴的Java规范中有说到：&lt;code&gt;不要在foreach循环里进行元素的remove/add操作，remove元素请使用Iterator方式。&lt;/code&gt;，但是不是真的就不可以在增强for循环中修改结构吗？其原理又是什么呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>DDL-事务的一种实现</title>
    <link href="http://yoursite.com/2019/03/09/DDL-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/09/DDL-事务的一种实现/</id>
    <published>2019-03-09T06:07:18.000Z</published>
    <updated>2019-04-17T10:41:34.799Z</updated>
    
    <content type="html"><![CDATA[<p>上次曾和大家说过<a href="https://death00.github.io/2018/10/31/DDL-%E8%84%8F%E6%95%B0%E6%8D%AE%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0/#more" target="_blank" rel="noopener">DDL-脏数据层的实现</a>，当时的我以为使用它的最大好处就是减少IO操作。但最近在项目中使用时，发现它也可以作为事务的一种临时实现。<br><a id="more"></a></p><p>大家知道，在Mongodb4.0之前是不支持事务的。因此，如果你的MongoDB使用的是低于4.0的版本，那么你一般都是在业务层去弥补，而这个DDL也可以做这样的事。</p><p>DDL中，业务场景一般是一个请求过来，直接修改缓存中的数据，我们默认这一步是成功的。后台会有一个专门的线程去定期扫描所有的脏数据，如果脏数据有<code>脏字段</code>，那么就将脏数据入库，入库成功自然便是皆大欢喜了，但如果不成功呢？</p><p>记得当时用MySql数据库，项目用的Spring boot + MyBatis，利用<code>@Transactional</code>注解，将几个数据库操作放在一个方法，这样即便出错，也可以自动回退。</p><p>但现在我们用的是MongoDB，而且我现在的版本是3.2（坑爹的阿里云服务）。数据库本身就不支持事务，这样我的DDL在将脏数据刷入数据库时，如果抛错，那么我的缓存里依旧是正确的数据，我只需要继续记录这些没有成功刷入数据库的脏数据字段，那么缓存里的数据，就依旧是刷入数据库之前的状态。而当后续请求进来后，其访问到的，也还是缓存里的正确数据。你只需要在抛错处设置报警，这样就可以即时知道问题，此时只需要专心修改这些问题，这样脏数据就会在线程下一次运行中，将数据刷入数据库中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次曾和大家说过&lt;a href=&quot;https://death00.github.io/2018/10/31/DDL-%E8%84%8F%E6%95%B0%E6%8D%AE%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DDL-脏数据层的实现&lt;/a&gt;，当时的我以为使用它的最大好处就是减少IO操作。但最近在项目中使用时，发现它也可以作为事务的一种临时实现。&lt;br&gt;
    
    </summary>
    
      <category term="DDL" scheme="http://yoursite.com/categories/DDL/"/>
    
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
</feed>
